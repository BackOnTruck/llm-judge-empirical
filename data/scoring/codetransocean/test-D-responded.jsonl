{"lang": "C++, Java", "input": "#include \"stdafx.h\"\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <boost/tokenizer.hpp>\n#include <boost/algorithm/string/case_conv.hpp>\nusing namespace std;\nusing namespace boost;\n\ntypedef boost::tokenizer<boost::char_separator<char> > Tokenizer;\nstatic const char_separator<char> sep(\" \",\"#;,\");\n\n\nstruct configs{\n\tstring fullname;\n\tstring favoritefruit;\n\tbool needspelling;\n\tbool seedsremoved;\n\tvector<string> otherfamily;\n} conf;\n\nvoid parseLine(const string &line, configs &conf)\n{\n\tif (line[0] == '#' || line.empty())\n\t\treturn;\n\tTokenizer tokenizer(line, sep);\n\tvector<string> tokens;\n\tfor (Tokenizer::iterator iter = tokenizer.begin(); iter != tokenizer.end(); iter++)\n\t\ttokens.push_back(*iter);\n\tif (tokens[0] == \";\"){\n\t\talgorithm::to_lower(tokens[1]);\n\t\tif (tokens[1] == \"needspeeling\")\n\t\t\tconf.needspelling = false;\n\t\tif (tokens[1] == \"seedsremoved\")\n\t\t\tconf.seedsremoved = false;\n\t}\n\talgorithm::to_lower(tokens[0]);\n\tif (tokens[0] == \"needspeeling\")\n\t\tconf.needspelling = true;\n\tif (tokens[0] == \"seedsremoved\")\n\t\tconf.seedsremoved = true;\n\tif (tokens[0] == \"fullname\"){\n\t\tfor (unsigned int i=1; i<tokens.size(); i++)\n\t\t\tconf.fullname += tokens[i] + \" \";\n\t\tconf.fullname.erase(conf.fullname.size() -1, 1);\n\t}\n\tif (tokens[0] == \"favouritefruit\") \n\t\tfor (unsigned int i=1; i<tokens.size(); i++)\n\t\t\tconf.favoritefruit += tokens[i];\n\tif (tokens[0] == \"otherfamily\"){\n\t\tunsigned int i=1;\n\t\tstring tmp;\n\t\twhile (i<=tokens.size()){\t\t\n\t\t\tif ( i == tokens.size() || tokens[i] ==\",\"){\n\t\t\t\ttmp.erase(tmp.size()-1, 1);\n\t\t\t\tconf.otherfamily.push_back(tmp);\n\t\t\t\ttmp = \"\";\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttmp += tokens[i];\n\t\t\t\ttmp += \" \";\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint _tmain(int argc, TCHAR* argv[])\n{\n\tif (argc != 2)\n\t{\n\t\twstring tmp = argv[0];\n\t\twcout << L\"Usage: \" << tmp << L\" <configfile.ini>\" << endl;\n\t\treturn -1;\n\t}\n\tifstream file (argv[1]);\n\t\n\tif (file.is_open())\n\t\twhile(file.good())\n\t\t{\n\t\t\tchar line[255];\n\t\t\tfile.getline(line, 255);\n\t\t\tstring linestring(line);\n\t\t\tparseLine(linestring, conf);\n\t\t}\n\telse\n\t{\n\t\tcout << \"Unable to open the file\" << endl;\n\t\treturn -2;\n\t}\n\n\tcout << \"Fullname= \" << conf.fullname << endl;\n\tcout << \"Favorite Fruit= \" << conf.favoritefruit << endl;\n\tcout << \"Need Spelling= \" << (conf.needspelling?\"True\":\"False\") << endl;\n\tcout << \"Seed Removed= \" << (conf.seedsremoved?\"True\":\"False\") << endl;\n\tstring otherFamily;\n\tfor (unsigned int i = 0; i < conf.otherfamily.size(); i++)\n\t\totherFamily += conf.otherfamily[i] + \", \";\n\totherFamily.erase(otherFamily.size()-2, 2);\n\tcout << \"Other Family= \" << otherFamily << endl;\n\n\treturn 0;\n}", "gold": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class ConfigReader {\n    private static final Pattern             LINE_PATTERN = Pattern.compile( \"([^ =]+)[ =]?(.*)\" );\n    private static final Map<String, Object> DEFAULTS     = new HashMap<String, Object>() {{\n        put( \"needspeeling\", false );\n        put( \"seedsremoved\", false );\n    }};\n\n    public static void main( final String[] args ) {\n        System.out.println( parseFile( args[ 0 ] ) );\n    }\n\n    public static Map<String, Object> parseFile( final String fileName ) {\n        final Map<String, Object> result = new HashMap<String, Object>( DEFAULTS );\n         BufferedReader      reader = null;\n\n        try {\n            reader = new BufferedReader( new FileReader( fileName ) );\n            for ( String line; null != ( line = reader.readLine() );  ) {\n                parseLine( line, result );\n            }\n        } catch ( final IOException x ) {\n            throw new RuntimeException( \"Oops: \" + x, x );\n        } finally {\n            if ( null != reader ) try {\n                reader.close();\n            } catch ( final IOException x2 ) {\n                System.err.println( \"Could not close \" + fileName + \" - \" + x2 );\n            }\n        }\n\n        return result;\n    }\n\n    private static void parseLine( final String line, final Map<String, Object> map ) {\n        if ( \"\".equals( line.trim() ) || line.startsWith( \"#\" ) || line.startsWith( \";\" ) )\n            return;\n\n        final Matcher matcher = LINE_PATTERN.matcher( line );\n\n        if ( ! matcher.matches() ) {\n            System.err.println( \"Bad config line: \" + line );\n            return;\n        }\n\n        final String key   = matcher.group( 1 ).trim().toLowerCase();\n        final String value = matcher.group( 2 ).trim();\n\n        if ( \"\".equals( value ) ) {\n            map.put( key, true );\n        } else if ( -1 == value.indexOf( ',' ) ) {\n            map.put( key, value );\n        } else {\n            final String[] values = value.split( \",\" );\n\n            for ( int i = 0; i < values.length; i++ ) {\n                values[ i ] = values[ i ].trim();\n            }\n            map.put( key, Arrays.asList( values ) );\n        }\n    }\n}", "llm": "dsc-33b", "output": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    static class Configs {\n        String fullname;\n        String favoritefruit;\n        boolean needspelling;\n        boolean seedsremoved;\n        List<String> otherfamily;\n    }\n\n    static Configs conf = new Configs();\n\n    public static void parseLine(String line, Configs conf) {\n        if (line.charAt(0) == '#' || line.isEmpty())\n            return;\n        StringTokenizer tokenizer = new StringTokenizer(line, \" ,;\");\n        List<String> tokens = new ArrayList<>();\n        while (tokenizer.hasMoreTokens())\n            tokens.add(tokenizer.nextToken());\n        if (tokens.get(0).equals(\";\")) {\n            if (tokens.get(1).equals(\"needspeeling\"))\n                conf.needspelling = false;\n            if (tokens.get(1).equals(\"seedsremoved\"))\n                conf.seedsremoved = false;\n        }\n        if (tokens.get(0).equals(\"needspeeling\"))\n            conf.needspelling = true;\n        if (tokens.get(0).equals(\"seedsremoved\"))\n            conf.seedsremoved = true;\n        if (tokens.get(0).equals(\"fullname\")) {\n            for (int i = 1; i < tokens.size(); i++)\n                conf.fullname += tokens.get(i) + \" \";\n            conf.fullname = conf.fullname.substring(0, conf.fullname.length() - 1);\n        }\n        if (tokens.get(0).equals(\"favouritefruit\"))\n            for (int i = 1; i < tokens.size(); i++)\n                conf.favoritefruit += tokens.get(i);\n        if (tokens.get(0).equals(\"otherfamily\")) {\n            int i = 1;\n            String tmp = \"\";\n            while (i <= tokens.size()) {\n                if (i == tokens.size() || tokens.get(i).equals(\",\")) {\n                    tmp = tmp.substring(0, tmp.length() - 1);\n                    conf.otherfamily.add(tmp);\n                    tmp = \"\";\n                    i++;\n                } else {\n                    tmp += tokens.get(i) + \" \";\n                    i++;\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: \" + args[0] + \" <configfile.ini>\");\n            System.exit(-1);\n        }\n        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {\n            String line;\n            while ((line = br.readLine()) != null) {\n                parseLine(line, conf);\n            }\n        } catch (IOException e) {\n            System.out.println(\"Unable to open the file\");\n            System.exit(-2);\n        }\n\n        System.out.println(\"Fullname= \" + conf.fullname);\n        System.out.println(\"Favorite Fruit= \" + conf.favoritefruit);\n        System.out.println(\"Need Spelling= \" + (conf.needspelling ? \"True\" : \"False\"));\n        System.out.println(\"Seed Removed= \" + (conf.seedsremoved ? \"True\" : \"False\"));\n        String otherFamily = \"\";\n        for (int i = 0; i < conf.otherfamily.size(); i++)\n            otherFamily += conf.otherfamily.get(i) + \", \";\n        otherFamily = otherFamily.substring(0, otherFamily.length() - 2);\n        System.out.println(\"Other Family= \" + otherFamily);\n    }\n}", "index": 0}
{"lang": "C++, Java", "input": "#include \"stdafx.h\"\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <boost/tokenizer.hpp>\n#include <boost/algorithm/string/case_conv.hpp>\nusing namespace std;\nusing namespace boost;\n\ntypedef boost::tokenizer<boost::char_separator<char> > Tokenizer;\nstatic const char_separator<char> sep(\" \",\"#;,\");\n\n\nstruct configs{\n\tstring fullname;\n\tstring favoritefruit;\n\tbool needspelling;\n\tbool seedsremoved;\n\tvector<string> otherfamily;\n} conf;\n\nvoid parseLine(const string &line, configs &conf)\n{\n\tif (line[0] == '#' || line.empty())\n\t\treturn;\n\tTokenizer tokenizer(line, sep);\n\tvector<string> tokens;\n\tfor (Tokenizer::iterator iter = tokenizer.begin(); iter != tokenizer.end(); iter++)\n\t\ttokens.push_back(*iter);\n\tif (tokens[0] == \";\"){\n\t\talgorithm::to_lower(tokens[1]);\n\t\tif (tokens[1] == \"needspeeling\")\n\t\t\tconf.needspelling = false;\n\t\tif (tokens[1] == \"seedsremoved\")\n\t\t\tconf.seedsremoved = false;\n\t}\n\talgorithm::to_lower(tokens[0]);\n\tif (tokens[0] == \"needspeeling\")\n\t\tconf.needspelling = true;\n\tif (tokens[0] == \"seedsremoved\")\n\t\tconf.seedsremoved = true;\n\tif (tokens[0] == \"fullname\"){\n\t\tfor (unsigned int i=1; i<tokens.size(); i++)\n\t\t\tconf.fullname += tokens[i] + \" \";\n\t\tconf.fullname.erase(conf.fullname.size() -1, 1);\n\t}\n\tif (tokens[0] == \"favouritefruit\") \n\t\tfor (unsigned int i=1; i<tokens.size(); i++)\n\t\t\tconf.favoritefruit += tokens[i];\n\tif (tokens[0] == \"otherfamily\"){\n\t\tunsigned int i=1;\n\t\tstring tmp;\n\t\twhile (i<=tokens.size()){\t\t\n\t\t\tif ( i == tokens.size() || tokens[i] ==\",\"){\n\t\t\t\ttmp.erase(tmp.size()-1, 1);\n\t\t\t\tconf.otherfamily.push_back(tmp);\n\t\t\t\ttmp = \"\";\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttmp += tokens[i];\n\t\t\t\ttmp += \" \";\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint _tmain(int argc, TCHAR* argv[])\n{\n\tif (argc != 2)\n\t{\n\t\twstring tmp = argv[0];\n\t\twcout << L\"Usage: \" << tmp << L\" <configfile.ini>\" << endl;\n\t\treturn -1;\n\t}\n\tifstream file (argv[1]);\n\t\n\tif (file.is_open())\n\t\twhile(file.good())\n\t\t{\n\t\t\tchar line[255];\n\t\t\tfile.getline(line, 255);\n\t\t\tstring linestring(line);\n\t\t\tparseLine(linestring, conf);\n\t\t}\n\telse\n\t{\n\t\tcout << \"Unable to open the file\" << endl;\n\t\treturn -2;\n\t}\n\n\tcout << \"Fullname= \" << conf.fullname << endl;\n\tcout << \"Favorite Fruit= \" << conf.favoritefruit << endl;\n\tcout << \"Need Spelling= \" << (conf.needspelling?\"True\":\"False\") << endl;\n\tcout << \"Seed Removed= \" << (conf.seedsremoved?\"True\":\"False\") << endl;\n\tstring otherFamily;\n\tfor (unsigned int i = 0; i < conf.otherfamily.size(); i++)\n\t\totherFamily += conf.otherfamily[i] + \", \";\n\totherFamily.erase(otherFamily.size()-2, 2);\n\tcout << \"Other Family= \" << otherFamily << endl;\n\n\treturn 0;\n}", "gold": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class ConfigReader {\n    private static final Pattern             LINE_PATTERN = Pattern.compile( \"([^ =]+)[ =]?(.*)\" );\n    private static final Map<String, Object> DEFAULTS     = new HashMap<String, Object>() {{\n        put( \"needspeeling\", false );\n        put( \"seedsremoved\", false );\n    }};\n\n    public static void main( final String[] args ) {\n        System.out.println( parseFile( args[ 0 ] ) );\n    }\n\n    public static Map<String, Object> parseFile( final String fileName ) {\n        final Map<String, Object> result = new HashMap<String, Object>( DEFAULTS );\n         BufferedReader      reader = null;\n\n        try {\n            reader = new BufferedReader( new FileReader( fileName ) );\n            for ( String line; null != ( line = reader.readLine() );  ) {\n                parseLine( line, result );\n            }\n        } catch ( final IOException x ) {\n            throw new RuntimeException( \"Oops: \" + x, x );\n        } finally {\n            if ( null != reader ) try {\n                reader.close();\n            } catch ( final IOException x2 ) {\n                System.err.println( \"Could not close \" + fileName + \" - \" + x2 );\n            }\n        }\n\n        return result;\n    }\n\n    private static void parseLine( final String line, final Map<String, Object> map ) {\n        if ( \"\".equals( line.trim() ) || line.startsWith( \"#\" ) || line.startsWith( \";\" ) )\n            return;\n\n        final Matcher matcher = LINE_PATTERN.matcher( line );\n\n        if ( ! matcher.matches() ) {\n            System.err.println( \"Bad config line: \" + line );\n            return;\n        }\n\n        final String key   = matcher.group( 1 ).trim().toLowerCase();\n        final String value = matcher.group( 2 ).trim();\n\n        if ( \"\".equals( value ) ) {\n            map.put( key, true );\n        } else if ( -1 == value.indexOf( ',' ) ) {\n            map.put( key, value );\n        } else {\n            final String[] values = value.split( \",\" );\n\n            for ( int i = 0; i < values.length; i++ ) {\n                values[ i ] = values[ i ].trim();\n            }\n            map.put( key, Arrays.asList( values ) );\n        }\n    }\n}", "llm": "q2.5-1.5b", "output": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class ConfigParser {\n    public static void main(String[] args) {\n        if (args.length != 2) {\n            System.out.println(\"Usage: \" + args[0] + \" <configfile.ini>\");\n            return;\n        }\n\n        try (BufferedReader reader = new BufferedReader(new FileReader(args[1]))) {\n            String line;\n            Config config = new Config();\n            while ((line = reader.readLine()) != null) {\n                parseLine(line, config);\n            }\n\n            System.out.println(\"Fullname= \" + config.fullname);\n            System.out.println(\"Favorite Fruit= \" + config.favoritefruit);\n            System.out.println(\"Need Spelling= \" + (config.needspelling ? \"True\" : \"False\"));\n            System.out.println(\"Seed Removed= \" + (config.seedsremoved ? \"True\" : \"False\"));\n            System.out.println(\"Other Family= \" + config.otherfamily.toString());\n        } catch (IOException e) {\n            System.out.println(\"Unable to open the file\");\n            e.printStackTrace();\n        }\n    }\n\n    static class Config {\n        private String fullname;\n        private String favoritefruit;\n        private boolean needspelling;\n        private boolean seedsremoved;\n        private List<String> otherfamily = new ArrayList<>();\n\n        public String getFullname() {\n            return fullname;\n        }\n\n        public void setFullname(String fullname) {\n            this.fullname = fullname;\n        }\n\n        public String getFavoritefruit() {\n            return favoritefruit;\n        }\n\n        public void setFavoritefruit(String favoritefruit) {\n            this.favoritefruit = favoritefruit;\n        }\n\n        public boolean isNeedspelling() {\n            return needspelling;\n        }\n\n        public void setNeedspelling(boolean needspelling) {\n            this.needspelling = needspelling;\n        }\n\n        public boolean isSeedsremoved() {\n            return seedsremoved;\n        }\n\n        public void setSeedsremoved(boolean seedsremoved) {\n            this.seedsremoved = seedsremoved;\n        }\n\n        public List<String> getOtherfamily() {\n            return otherfamily;\n        }\n\n        public void setOtherfamily(List<String> otherfamily) {\n            this.otherfamily = otherfamily;\n        }\n    }\n\n    static void parseLine(String line, Config config) {\n        if (line.startsWith(\"#\") || line.isEmpty()) {\n            return;\n        }\n\n        String[] tokens = line.split(\" \");\n        if (tokens[0].equals(\";\")) {\n            if (tokens[1].equalsIgnoreCase(\"needspeeling\")) {\n                config.setNeedspelling(false);\n            }\n            if (tokens[1].equalsIgnoreCase(\"seedsremoved\")) {\n                config.setSeedsremoved(false);\n            }\n        } else {\n            if (tokens[0].equalsIgnoreCase(\"needspeeling\")) {\n                config.setNeedspelling(true);\n            }\n            if (tokens[0].equalsIgnoreCase(\"seedsremoved\")) {\n                config.setSeedsremoved(true);\n            }\n            if (tokens[0].equalsIgnoreCase(\"fullname\")) {\n                for (int i = 1; i < tokens.length; i++) {\n                    config.setFullname(config.getFullname() + tokens[i] + \" \");\n                }\n                config.setFullname(config.getFullname().trim());\n            }\n            if (tokens[0].equalsIgnoreCase(\"favouritefruit\")) {\n                for (int i = 1; i < tokens.length; i++) {\n                    config.setFavoritefruit(config.getFavoritefruit() + tokens[i]);\n                }\n            }\n            if (tokens[0].equalsIgnoreCase(\"otherfamily\")) {\n                int i = 1;\n                String tmp = \"\";\n                while (i <= tokens.length) {\n                    if (i == tokens.length || tokens[i].equals(\",\")) {\n                        tmp = tmp.trim();\n                        config.getOtherfamily().add(tmp);\n                        tmp = \"\";\n                        i++;\n                    } else {\n                        tmp += tokens[i] + \" \";\n                        i++;\n                    }\n                }\n            }\n        }\n    }\n}", "index": 1}
{"lang": "C++, Java", "input": "#include \"stdafx.h\"\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <boost/tokenizer.hpp>\n#include <boost/algorithm/string/case_conv.hpp>\nusing namespace std;\nusing namespace boost;\n\ntypedef boost::tokenizer<boost::char_separator<char> > Tokenizer;\nstatic const char_separator<char> sep(\" \",\"#;,\");\n\n\nstruct configs{\n\tstring fullname;\n\tstring favoritefruit;\n\tbool needspelling;\n\tbool seedsremoved;\n\tvector<string> otherfamily;\n} conf;\n\nvoid parseLine(const string &line, configs &conf)\n{\n\tif (line[0] == '#' || line.empty())\n\t\treturn;\n\tTokenizer tokenizer(line, sep);\n\tvector<string> tokens;\n\tfor (Tokenizer::iterator iter = tokenizer.begin(); iter != tokenizer.end(); iter++)\n\t\ttokens.push_back(*iter);\n\tif (tokens[0] == \";\"){\n\t\talgorithm::to_lower(tokens[1]);\n\t\tif (tokens[1] == \"needspeeling\")\n\t\t\tconf.needspelling = false;\n\t\tif (tokens[1] == \"seedsremoved\")\n\t\t\tconf.seedsremoved = false;\n\t}\n\talgorithm::to_lower(tokens[0]);\n\tif (tokens[0] == \"needspeeling\")\n\t\tconf.needspelling = true;\n\tif (tokens[0] == \"seedsremoved\")\n\t\tconf.seedsremoved = true;\n\tif (tokens[0] == \"fullname\"){\n\t\tfor (unsigned int i=1; i<tokens.size(); i++)\n\t\t\tconf.fullname += tokens[i] + \" \";\n\t\tconf.fullname.erase(conf.fullname.size() -1, 1);\n\t}\n\tif (tokens[0] == \"favouritefruit\") \n\t\tfor (unsigned int i=1; i<tokens.size(); i++)\n\t\t\tconf.favoritefruit += tokens[i];\n\tif (tokens[0] == \"otherfamily\"){\n\t\tunsigned int i=1;\n\t\tstring tmp;\n\t\twhile (i<=tokens.size()){\t\t\n\t\t\tif ( i == tokens.size() || tokens[i] ==\",\"){\n\t\t\t\ttmp.erase(tmp.size()-1, 1);\n\t\t\t\tconf.otherfamily.push_back(tmp);\n\t\t\t\ttmp = \"\";\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttmp += tokens[i];\n\t\t\t\ttmp += \" \";\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint _tmain(int argc, TCHAR* argv[])\n{\n\tif (argc != 2)\n\t{\n\t\twstring tmp = argv[0];\n\t\twcout << L\"Usage: \" << tmp << L\" <configfile.ini>\" << endl;\n\t\treturn -1;\n\t}\n\tifstream file (argv[1]);\n\t\n\tif (file.is_open())\n\t\twhile(file.good())\n\t\t{\n\t\t\tchar line[255];\n\t\t\tfile.getline(line, 255);\n\t\t\tstring linestring(line);\n\t\t\tparseLine(linestring, conf);\n\t\t}\n\telse\n\t{\n\t\tcout << \"Unable to open the file\" << endl;\n\t\treturn -2;\n\t}\n\n\tcout << \"Fullname= \" << conf.fullname << endl;\n\tcout << \"Favorite Fruit= \" << conf.favoritefruit << endl;\n\tcout << \"Need Spelling= \" << (conf.needspelling?\"True\":\"False\") << endl;\n\tcout << \"Seed Removed= \" << (conf.seedsremoved?\"True\":\"False\") << endl;\n\tstring otherFamily;\n\tfor (unsigned int i = 0; i < conf.otherfamily.size(); i++)\n\t\totherFamily += conf.otherfamily[i] + \", \";\n\totherFamily.erase(otherFamily.size()-2, 2);\n\tcout << \"Other Family= \" << otherFamily << endl;\n\n\treturn 0;\n}", "gold": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class ConfigReader {\n    private static final Pattern             LINE_PATTERN = Pattern.compile( \"([^ =]+)[ =]?(.*)\" );\n    private static final Map<String, Object> DEFAULTS     = new HashMap<String, Object>() {{\n        put( \"needspeeling\", false );\n        put( \"seedsremoved\", false );\n    }};\n\n    public static void main( final String[] args ) {\n        System.out.println( parseFile( args[ 0 ] ) );\n    }\n\n    public static Map<String, Object> parseFile( final String fileName ) {\n        final Map<String, Object> result = new HashMap<String, Object>( DEFAULTS );\n         BufferedReader      reader = null;\n\n        try {\n            reader = new BufferedReader( new FileReader( fileName ) );\n            for ( String line; null != ( line = reader.readLine() );  ) {\n                parseLine( line, result );\n            }\n        } catch ( final IOException x ) {\n            throw new RuntimeException( \"Oops: \" + x, x );\n        } finally {\n            if ( null != reader ) try {\n                reader.close();\n            } catch ( final IOException x2 ) {\n                System.err.println( \"Could not close \" + fileName + \" - \" + x2 );\n            }\n        }\n\n        return result;\n    }\n\n    private static void parseLine( final String line, final Map<String, Object> map ) {\n        if ( \"\".equals( line.trim() ) || line.startsWith( \"#\" ) || line.startsWith( \";\" ) )\n            return;\n\n        final Matcher matcher = LINE_PATTERN.matcher( line );\n\n        if ( ! matcher.matches() ) {\n            System.err.println( \"Bad config line: \" + line );\n            return;\n        }\n\n        final String key   = matcher.group( 1 ).trim().toLowerCase();\n        final String value = matcher.group( 2 ).trim();\n\n        if ( \"\".equals( value ) ) {\n            map.put( key, true );\n        } else if ( -1 == value.indexOf( ',' ) ) {\n            map.put( key, value );\n        } else {\n            final String[] values = value.split( \",\" );\n\n            for ( int i = 0; i < values.length; i++ ) {\n                values[ i ] = values[ i ].trim();\n            }\n            map.put( key, Arrays.asList( values ) );\n        }\n    }\n}", "llm": "cg4-9b", "output": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    static class Configs {\n        String fullname;\n        String favoritefruit;\n        boolean needspelling;\n        boolean seedsremoved;\n        List<String> otherfamily;\n\n        public Configs() {\n            fullname = \"\";\n            favoritefruit = \"\";\n            needspelling = false;\n            seedsremoved = false;\n            otherfamily = new ArrayList<>();\n        }\n    }\n\n    static Configs conf = new Configs();\n\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: Main <configfile.ini>\");\n            return;\n        }\n\n        try (BufferedReader file = new BufferedReader(new FileReader(args[0]))) {\n            String line;\n            while ((line = file.readLine()) != null) {\n                parseLine(line, conf);\n            }\n        } catch (IOException e) {\n            System.out.println(\"Unable to open the file\");\n            return;\n        }\n\n        System.out.println(\"Fullname= \" + conf.fullname);\n        System.out.println(\"Favorite Fruit= \" + conf.favoritefruit);\n        System.out.println(\"Need Spelling= \" + (conf.needspelling ? \"True\" : \"False\"));\n        System.out.println(\"Seed Removed= \" + (conf.seedsremoved ? \"True\" : \"False\"));\n        String otherFamily = String.join(\", \", conf.otherfamily);\n        System.out.println(\"Other Family= \" + otherFamily);\n    }\n\n    public static void parseLine(String line, Configs conf) {\n        if (line.charAt(0) == '#' || line.isEmpty()) {\n            return;\n        }\n\n        StringTokenizer tokenizer = new StringTokenizer(line, \" #;,\");\n        List<String> tokens = new ArrayList<>();\n        while (tokenizer.hasMoreTokens()) {\n            tokens.add(tokenizer.nextToken());\n        }\n\n        if (tokens.get(0).equals(\";\")) {\n            tokens.get(1).toLowerCase();\n            if (tokens.get(1).equals(\"needspeeling\")) {\n                conf.needspelling = false;\n            }\n            if (tokens.get(1).equals(\"seedsremoved\")) {\n                conf.seedsremoved = false;\n            }\n        }\n\n        tokens.get(0).toLowerCase();\n        if (tokens.get(0).equals(\"needspeeling\")) {\n            conf.needspelling = true;\n        }\n        if (tokens.get(0).equals(\"seedsremoved\")) {\n            conf.seedsremoved = true;\n        }\n        if (tokens.get(0).equals(\"fullname\")) {\n            for (int i = 1; i < tokens.size(); i++) {\n                conf.fullname += tokens.get(i) + \" \";\n            }\n            conf.fullname = conf.fullname.substring(0, conf.fullname.length() - 1);\n        }\n        if (tokens.get(0).equals(\"favouritefruit\")) {\n            for (int i = 1; i < tokens.size(); i++) {\n                conf.favoritefruit += tokens.get(i);\n            }\n        }\n        if (tokens.get(0).equals(\"otherfamily\")) {\n            int i = 1;\n            String tmp = \"\";\n            while (i <= tokens.size()) {\n                if (i == tokens.size() || tokens.get(i).equals(\",\")) {\n                    tmp = tmp.substring(0, tmp.length() - 1);\n                    conf.otherfamily.add(tmp);\n                    tmp = \"\";\n                    i++;\n                } else {\n                    tmp += tokens.get(i) + \" \";\n                    i++;\n                }\n            }\n        }\n    }\n}", "index": 2}
{"lang": "C++, Java", "input": "#include <algorithm>\n#include <iostream>\n#include <numeric>\n#include <sstream>\n#include <vector>\n\n\ntemplate <typename iterator>\nbool sum_of_any_subset(int n, iterator begin, iterator end) {\n    if (begin == end)\n        return false;\n    if (std::find(begin, end, n) != end)\n        return true;\n    int total = std::accumulate(begin, end, 0);\n    if (n == total)\n        return true;\n    if (n > total)\n        return false;\n    --end;\n    int d = n - *end;\n    return (d > 0 && sum_of_any_subset(d, begin, end)) ||\n           sum_of_any_subset(n, begin, end);\n}\n\n\nstd::vector<int> factors(int n) {\n    std::vector<int> f{1};\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) {\n            f.push_back(i);\n            if (i * i != n)\n                f.push_back(n / i);\n        }\n    }\n    std::sort(f.begin(), f.end());\n    return f;\n}\n\nbool is_practical(int n) {\n    std::vector<int> f = factors(n);\n    for (int i = 1; i < n; ++i) {\n        if (!sum_of_any_subset(i, f.begin(), f.end()))\n            return false;\n    }\n    return true;\n}\n\nstd::string shorten(const std::vector<int>& v, size_t n) {\n    std::ostringstream out;\n    size_t size = v.size(), i = 0;\n    if (n > 0 && size > 0)\n        out << v[i++];\n    for (; i < n && i < size; ++i)\n        out << \", \" << v[i];\n    if (size > i + n) {\n        out << \", ...\";\n        i = size - n;\n    }\n    for (; i < size; ++i)\n        out << \", \" << v[i];\n    return out.str();\n}\n\nint main() {\n    std::vector<int> practical;\n    for (int n = 1; n <= 333; ++n) {\n        if (is_practical(n))\n            practical.push_back(n);\n    }\n    std::cout << \"Found \" << practical.size() << \" practical numbers:\\n\"\n              << shorten(practical, 10) << '\\n';\n    for (int n : {666, 6666, 66666, 672, 720, 222222})\n        std::cout << n << \" is \" << (is_practical(n) ? \"\" : \"not \")\n                  << \"a practical number.\\n\";\n    return 0;\n}", "gold": "import java.util.*;\n\npublic class PracticalNumbers {\n    public static void main(String[] args) {\n        final int from = 1;\n        final int to = 333;\n        List<Integer> practical = new ArrayList<>();\n        for (int i = from; i <= to; ++i) {\n            if (isPractical(i))\n                practical.add(i);\n        }\n        System.out.printf(\"Found %d practical numbers between %d and %d:\\n%s\\n\",\n                practical.size(), from, to, shorten(practical, 10));\n\n        printPractical(666);\n        printPractical(6666);\n        printPractical(66666);\n        printPractical(672);\n        printPractical(720);\n        printPractical(222222);\n    }\n\n    private static void printPractical(int n) {\n        if (isPractical(n))\n            System.out.printf(\"%d is a practical number.\\n\", n);\n        else\n            System.out.printf(\"%d is not a practical number.\\n\", n);\n    }\n\n    private static boolean isPractical(int n) {\n        int[] divisors = properDivisors(n);\n        for (int i = 1; i < n; ++i) {\n            if (!sumOfAnySubset(i, divisors, divisors.length))\n                return false;\n        }\n        return true;\n    }\n\n    private static boolean sumOfAnySubset(int n, int[] f, int len) {\n        if (len == 0)\n            return false;\n        int total = 0;\n        for (int i = 0; i < len; ++i) {\n            if (n == f[i])\n                return true;\n            total += f[i];\n        }\n        if (n == total)\n            return true;\n        if (n > total)\n            return false;\n        --len;\n        int d = n - f[len];\n        return (d > 0 && sumOfAnySubset(d, f, len)) || sumOfAnySubset(n, f, len);\n    }\n\n    private static int[] properDivisors(int n) {\n        List<Integer> divisors = new ArrayList<>();\n        divisors.add(1);\n        for (int i = 2;; ++i) {\n            int i2 = i * i;\n            if (i2 > n)\n                break;\n            if (n % i == 0) {\n                divisors.add(i);\n                if (i2 != n)\n                    divisors.add(n / i);\n            }\n        }\n        int[] result = new int[divisors.size()];\n        for (int i = 0; i < result.length; ++i)\n            result[i] = divisors.get(i);\n        Arrays.sort(result);\n        return result;\n    }\n\n    private static String shorten(List<Integer> list, int n) {\n        StringBuilder str = new StringBuilder();\n        int len = list.size(), i = 0;\n        if (n > 0 && len > 0)\n            str.append(list.get(i++));\n        for (; i < n && i < len; ++i) {\n            str.append(\", \");\n            str.append(list.get(i));\n        }\n        if (len > i + n) {\n            if (n > 0)\n                str.append(\", ...\");\n            i = len - n;\n        }\n        for (; i < len; ++i) {\n            str.append(\", \");\n            str.append(list.get(i));\n        }\n        return str.toString();\n    }\n}", "llm": "dsc-1b", "output": "import java.util.*;\nimport java.util.stream.IntStream;\n\npublic class Main {\n\n    public static boolean sumOfAnySubset(int n, List<Integer> list) {\n        if (list.isEmpty())\n            return false;\n        if (list.contains(n))\n            return true;\n        int total = list.stream().mapToInt(Integer::intValue).sum();\n        if (n == total)\n            return true;\n        if (n > total)\n            return false;\n        list.remove(list.size() - 1);\n        int d = n - list.get(list.size() - 1);\n        return (d > 0 && sumOfAnySubset(d, list)) ||\n                sumOfAnySubset(n, list);\n    }\n\n    public static List<Integer> factors(int n) {\n        List<Integer> list = new ArrayList<>();\n        list.add(1);\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) {\n                list.add(i);\n                if (i * i != n)\n                    list.add(n / i);\n            }\n        }\n        Collections.sort(list);\n        return list;\n    }\n\n    public static boolean isPractical(int n) {\n        List<Integer> list = factors(n);\n        for (int i = 1; i < n; i++) {\n            if (!sumOfAnySubset(i, list))\n                return false;\n        }\n        return true;\n    }\n\n    public static String shorten(List<Integer> list, int n) {\n        StringBuilder sb = new StringBuilder();\n        int size = list.size();\n        if (n > 0 && size > 0)\n            sb.append(list.get(0));\n        for (int i = 1; i < n && i < size; i++)\n            sb.append(\", \").append(list.get(i));\n        if (size > i + n) {\n            sb.append(\", ...\");\n            i = size - n;\n        }\n        for (; i < size; i++)\n            sb.append(\", \").append(list.get(i));\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        List<Integer> practical = new ArrayList<>();\n        for (int n = 1; n <= 333; n++) {\n            if (isPractical(n))\n                practical.add(n);\n        }\n        System.out.println(\"Found \" + practical.size() + \" practical numbers:\");\n        System.out.println(shorten(practical, 10));\n        for (int n : new int[]{666, 6666, 66666, 672, 720, 222222})\n            System.out.println(n + \" is \" + (isPractical(n) ? \"\" : \"not \") + \"a practical number.\");\n    }\n}", "index": 3}
{"lang": "C++, Java", "input": "#include <algorithm>\n#include <iostream>\n#include <numeric>\n#include <sstream>\n#include <vector>\n\n\ntemplate <typename iterator>\nbool sum_of_any_subset(int n, iterator begin, iterator end) {\n    if (begin == end)\n        return false;\n    if (std::find(begin, end, n) != end)\n        return true;\n    int total = std::accumulate(begin, end, 0);\n    if (n == total)\n        return true;\n    if (n > total)\n        return false;\n    --end;\n    int d = n - *end;\n    return (d > 0 && sum_of_any_subset(d, begin, end)) ||\n           sum_of_any_subset(n, begin, end);\n}\n\n\nstd::vector<int> factors(int n) {\n    std::vector<int> f{1};\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) {\n            f.push_back(i);\n            if (i * i != n)\n                f.push_back(n / i);\n        }\n    }\n    std::sort(f.begin(), f.end());\n    return f;\n}\n\nbool is_practical(int n) {\n    std::vector<int> f = factors(n);\n    for (int i = 1; i < n; ++i) {\n        if (!sum_of_any_subset(i, f.begin(), f.end()))\n            return false;\n    }\n    return true;\n}\n\nstd::string shorten(const std::vector<int>& v, size_t n) {\n    std::ostringstream out;\n    size_t size = v.size(), i = 0;\n    if (n > 0 && size > 0)\n        out << v[i++];\n    for (; i < n && i < size; ++i)\n        out << \", \" << v[i];\n    if (size > i + n) {\n        out << \", ...\";\n        i = size - n;\n    }\n    for (; i < size; ++i)\n        out << \", \" << v[i];\n    return out.str();\n}\n\nint main() {\n    std::vector<int> practical;\n    for (int n = 1; n <= 333; ++n) {\n        if (is_practical(n))\n            practical.push_back(n);\n    }\n    std::cout << \"Found \" << practical.size() << \" practical numbers:\\n\"\n              << shorten(practical, 10) << '\\n';\n    for (int n : {666, 6666, 66666, 672, 720, 222222})\n        std::cout << n << \" is \" << (is_practical(n) ? \"\" : \"not \")\n                  << \"a practical number.\\n\";\n    return 0;\n}", "gold": "import java.util.*;\n\npublic class PracticalNumbers {\n    public static void main(String[] args) {\n        final int from = 1;\n        final int to = 333;\n        List<Integer> practical = new ArrayList<>();\n        for (int i = from; i <= to; ++i) {\n            if (isPractical(i))\n                practical.add(i);\n        }\n        System.out.printf(\"Found %d practical numbers between %d and %d:\\n%s\\n\",\n                practical.size(), from, to, shorten(practical, 10));\n\n        printPractical(666);\n        printPractical(6666);\n        printPractical(66666);\n        printPractical(672);\n        printPractical(720);\n        printPractical(222222);\n    }\n\n    private static void printPractical(int n) {\n        if (isPractical(n))\n            System.out.printf(\"%d is a practical number.\\n\", n);\n        else\n            System.out.printf(\"%d is not a practical number.\\n\", n);\n    }\n\n    private static boolean isPractical(int n) {\n        int[] divisors = properDivisors(n);\n        for (int i = 1; i < n; ++i) {\n            if (!sumOfAnySubset(i, divisors, divisors.length))\n                return false;\n        }\n        return true;\n    }\n\n    private static boolean sumOfAnySubset(int n, int[] f, int len) {\n        if (len == 0)\n            return false;\n        int total = 0;\n        for (int i = 0; i < len; ++i) {\n            if (n == f[i])\n                return true;\n            total += f[i];\n        }\n        if (n == total)\n            return true;\n        if (n > total)\n            return false;\n        --len;\n        int d = n - f[len];\n        return (d > 0 && sumOfAnySubset(d, f, len)) || sumOfAnySubset(n, f, len);\n    }\n\n    private static int[] properDivisors(int n) {\n        List<Integer> divisors = new ArrayList<>();\n        divisors.add(1);\n        for (int i = 2;; ++i) {\n            int i2 = i * i;\n            if (i2 > n)\n                break;\n            if (n % i == 0) {\n                divisors.add(i);\n                if (i2 != n)\n                    divisors.add(n / i);\n            }\n        }\n        int[] result = new int[divisors.size()];\n        for (int i = 0; i < result.length; ++i)\n            result[i] = divisors.get(i);\n        Arrays.sort(result);\n        return result;\n    }\n\n    private static String shorten(List<Integer> list, int n) {\n        StringBuilder str = new StringBuilder();\n        int len = list.size(), i = 0;\n        if (n > 0 && len > 0)\n            str.append(list.get(i++));\n        for (; i < n && i < len; ++i) {\n            str.append(\", \");\n            str.append(list.get(i));\n        }\n        if (len > i + n) {\n            if (n > 0)\n                str.append(\", ...\");\n            i = len - n;\n        }\n        for (; i < len; ++i) {\n            str.append(\", \");\n            str.append(list.get(i));\n        }\n        return str.toString();\n    }\n}", "llm": "dsc-7b", "output": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static boolean sumOfAnySubset(int n, List<Integer> list) {\n        if (list.isEmpty())\n            return false;\n        if (list.contains(n))\n            return true;\n        int total = list.stream().reduce(0, Integer::sum);\n        if (n == total)\n            return true;\n        if (n > total)\n            return false;\n        int end = list.size() - 1;\n        int d = n - list.get(end);\n        return (d > 0 && sumOfAnySubset(d, list.subList(0, end))) ||\n               sumOfAnySubset(n, list.subList(0, end));\n    }\n\n    public static List<Integer> factors(int n) {\n        List<Integer> f = new ArrayList<>(Arrays.asList(1));\n        for (int i = 2; i * i <= n; ++i) {\n            if (n % i == 0) {\n                f.add(i);\n                if (i * i != n)\n                    f.add(n / i);\n            }\n        }\n        f.sort(Integer::compareTo);\n        return f;\n    }\n\n    public static boolean isPractical(int n) {\n        List<Integer> f = factors(n);\n        for (int i = 1; i < n; ++i) {\n            if (!sumOfAnySubset(i, new ArrayList<>(f)))\n                return false;\n        }\n        return true;\n    }\n\n    public static String shorten(List<Integer> list, int n) {\n        StringBuilder out = new StringBuilder();\n        int size = list.size(), i = 0;\n        if (n > 0 && size > 0)\n            out.append(list.get(i++));\n        for (; i < n && i < size; ++i)\n            out.append(\", \").append(list.get(i));\n        if (size > i + n) {\n            out.append(\", ...\");\n            i = size - n;\n        }\n        for (; i < size; ++i)\n            out.append(\", \").append(list.get(i));\n        return out.toString();\n    }\n\n    public static void main(String[] args) {\n        List<Integer> practical = new ArrayList<>();\n        for (int n = 1; n <= 333; ++n) {\n            if (isPractical(n))\n                practical.add(n);\n        }\n        System.out.println(\"Found \" + practical.size() + \" practical numbers:\\n\" +\n                           shorten(practical, 10) + '\\n');\n        for (int n : Arrays.asList(666, 6666, 66666, 672, 720, 222222))\n            System.out.println(n + \" is \" + (isPractical(n) ? \"\" : \"not \") +\n                               \"a practical number.\\n\");\n    }\n}", "index": 4}
{"lang": "C++, Java", "input": "#include <algorithm>\n#include <iostream>\n#include <numeric>\n#include <sstream>\n#include <vector>\n\n\ntemplate <typename iterator>\nbool sum_of_any_subset(int n, iterator begin, iterator end) {\n    if (begin == end)\n        return false;\n    if (std::find(begin, end, n) != end)\n        return true;\n    int total = std::accumulate(begin, end, 0);\n    if (n == total)\n        return true;\n    if (n > total)\n        return false;\n    --end;\n    int d = n - *end;\n    return (d > 0 && sum_of_any_subset(d, begin, end)) ||\n           sum_of_any_subset(n, begin, end);\n}\n\n\nstd::vector<int> factors(int n) {\n    std::vector<int> f{1};\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) {\n            f.push_back(i);\n            if (i * i != n)\n                f.push_back(n / i);\n        }\n    }\n    std::sort(f.begin(), f.end());\n    return f;\n}\n\nbool is_practical(int n) {\n    std::vector<int> f = factors(n);\n    for (int i = 1; i < n; ++i) {\n        if (!sum_of_any_subset(i, f.begin(), f.end()))\n            return false;\n    }\n    return true;\n}\n\nstd::string shorten(const std::vector<int>& v, size_t n) {\n    std::ostringstream out;\n    size_t size = v.size(), i = 0;\n    if (n > 0 && size > 0)\n        out << v[i++];\n    for (; i < n && i < size; ++i)\n        out << \", \" << v[i];\n    if (size > i + n) {\n        out << \", ...\";\n        i = size - n;\n    }\n    for (; i < size; ++i)\n        out << \", \" << v[i];\n    return out.str();\n}\n\nint main() {\n    std::vector<int> practical;\n    for (int n = 1; n <= 333; ++n) {\n        if (is_practical(n))\n            practical.push_back(n);\n    }\n    std::cout << \"Found \" << practical.size() << \" practical numbers:\\n\"\n              << shorten(practical, 10) << '\\n';\n    for (int n : {666, 6666, 66666, 672, 720, 222222})\n        std::cout << n << \" is \" << (is_practical(n) ? \"\" : \"not \")\n                  << \"a practical number.\\n\";\n    return 0;\n}", "gold": "import java.util.*;\n\npublic class PracticalNumbers {\n    public static void main(String[] args) {\n        final int from = 1;\n        final int to = 333;\n        List<Integer> practical = new ArrayList<>();\n        for (int i = from; i <= to; ++i) {\n            if (isPractical(i))\n                practical.add(i);\n        }\n        System.out.printf(\"Found %d practical numbers between %d and %d:\\n%s\\n\",\n                practical.size(), from, to, shorten(practical, 10));\n\n        printPractical(666);\n        printPractical(6666);\n        printPractical(66666);\n        printPractical(672);\n        printPractical(720);\n        printPractical(222222);\n    }\n\n    private static void printPractical(int n) {\n        if (isPractical(n))\n            System.out.printf(\"%d is a practical number.\\n\", n);\n        else\n            System.out.printf(\"%d is not a practical number.\\n\", n);\n    }\n\n    private static boolean isPractical(int n) {\n        int[] divisors = properDivisors(n);\n        for (int i = 1; i < n; ++i) {\n            if (!sumOfAnySubset(i, divisors, divisors.length))\n                return false;\n        }\n        return true;\n    }\n\n    private static boolean sumOfAnySubset(int n, int[] f, int len) {\n        if (len == 0)\n            return false;\n        int total = 0;\n        for (int i = 0; i < len; ++i) {\n            if (n == f[i])\n                return true;\n            total += f[i];\n        }\n        if (n == total)\n            return true;\n        if (n > total)\n            return false;\n        --len;\n        int d = n - f[len];\n        return (d > 0 && sumOfAnySubset(d, f, len)) || sumOfAnySubset(n, f, len);\n    }\n\n    private static int[] properDivisors(int n) {\n        List<Integer> divisors = new ArrayList<>();\n        divisors.add(1);\n        for (int i = 2;; ++i) {\n            int i2 = i * i;\n            if (i2 > n)\n                break;\n            if (n % i == 0) {\n                divisors.add(i);\n                if (i2 != n)\n                    divisors.add(n / i);\n            }\n        }\n        int[] result = new int[divisors.size()];\n        for (int i = 0; i < result.length; ++i)\n            result[i] = divisors.get(i);\n        Arrays.sort(result);\n        return result;\n    }\n\n    private static String shorten(List<Integer> list, int n) {\n        StringBuilder str = new StringBuilder();\n        int len = list.size(), i = 0;\n        if (n > 0 && len > 0)\n            str.append(list.get(i++));\n        for (; i < n && i < len; ++i) {\n            str.append(\", \");\n            str.append(list.get(i));\n        }\n        if (len > i + n) {\n            if (n > 0)\n                str.append(\", ...\");\n            i = len - n;\n        }\n        for (; i < len; ++i) {\n            str.append(\", \");\n            str.append(list.get(i));\n        }\n        return str.toString();\n    }\n}", "llm": "q2.5-7b", "output": "import java.util.*;\n\npublic class Main {\n    public static <T extends Number> boolean sumOfAnySubset(int n, Iterator<T> begin, Iterator<T> end) {\n        if (!begin.hasNext())\n            return false;\n        if (find(begin, end, n) != null)\n            return true;\n        int total = accumulate(begin, end);\n        if (n == total)\n            return true;\n        if (n > total)\n            return false;\n        end.next();\n        int d = n - end.next().intValue();\n        return (d > 0 && sumOfAnySubset(d, begin, end)) || sumOfAnySubset(n, begin, end);\n    }\n\n    public static <T extends Number> T find(Iterator<T> begin, Iterator<T> end, int n) {\n        while (begin.hasNext()) {\n            T value = begin.next();\n            if (value.intValue() == n)\n                return value;\n        }\n        return null;\n    }\n\n    public static <T extends Number> int accumulate(Iterator<T> begin, Iterator<T> end) {\n        int sum = 0;\n        while (begin.hasNext()) {\n            sum += begin.next().intValue();\n        }\n        return sum;\n    }\n\n    public static List<Integer> factors(int n) {\n        List<Integer> f = new ArrayList<>();\n        f.add(1);\n        for (int i = 2; i * i <= n; ++i) {\n            if (n % i == 0) {\n                f.add(i);\n                if (i * i != n)\n                    f.add(n / i);\n            }\n        }\n        Collections.sort(f);\n        return f;\n    }\n\n    public static boolean isPractical(int n) {\n        List<Integer> f = factors(n);\n        for (int i = 1; i < n; ++i) {\n            if (!sumOfAnySubset(i, f.iterator(), f.iterator()))\n                return false;\n        }\n        return true;\n    }\n\n    public static String shorten(List<Integer> v, int n) {\n        StringBuilder out = new StringBuilder();\n        int size = v.size(), i = 0;\n        if (n > 0 && size > 0)\n            out.append(v.get(i++));\n        for (; i < n && i < size; ++i)\n            out.append(\", \").append(v.get(i));\n        if (size > i + n) {\n            out.append(\", ...\");\n            i = size - n;\n        }\n        for (; i < size; ++i)\n            out.append(\", \").append(v.get(i));\n        return out.toString();\n    }\n\n    public static void main(String[] args) {\n        List<Integer> practical = new ArrayList<>();\n        for (int n = 1; n <= 333; ++n) {\n            if (isPractical(n))\n                practical.add(n);\n        }\n        System.out.println(\"Found \" + practical.size() + \" practical numbers:\\n\"\n                + shorten(practical, 10) + '\\n');\n        for (int n : Arrays.asList(666, 6666, 66666, 672, 720, 222222))\n            System.out.println(n + \" is \" + (isPractical(n) ? \"\" : \"not \")\n                    + \"a practical number.\");\n    }\n}", "index": 5}
{"lang": "C++, C", "input": "#include <algorithm>\n#include <string>\n#include <cctype>\n\n\n\nvoid str_toupper(std::string &str) {\n  std::transform(str.begin(), \n                 str.end(), \n                 str.begin(),\n                 (int(*)(int)) std::toupper);\n}\n\n\n\nvoid str_tolower(std::string &str) {\n  std::transform(str.begin(), \n                 str.end(), \n                 str.begin(),\n                 (int(*)(int)) std::tolower);\n}", "gold": "#include <ctype.h>\n#include <stdio.h>\n\n\nvoid str_toupper(char *s)\n{\n    while(*s)\n    {\n        *s=toupper(*s);\n        s++;\n    }\n}\n\n\n\nvoid str_tolower(char *s)\n{\n    while(*s)\n    {\n        *s=tolower(*s);\n        s++;\n    }\n}\n\nint main(int argc, char *argv[])\n{\n    char t[255]=\"alphaBETA\";\n    str_toupper(t);\n    printf(\"uppercase: %s\\n\", t);\n    str_tolower(t);\n    printf(\"lowercase: %s\\n\", t);\n    return 0;\n}", "llm": "q2.5-1.5b", "output": "#include <algorithm>\n#include <string>\n#include <cctype>\n\n\n\nvoid str_toupper(std::string &str) {\n  std::transform(str.begin(), \n                 str.end(), \n                 str.begin(),\n                 (int(*)(int)) std::toupper);\n}\n\n\n\nvoid str_tolower(std::string &str) {\n  std::transform(str.begin(), \n                 str.end(), \n                 str.begin(),\n                 (int(*)(int)) std::tolower);\n}", "index": 6}
{"lang": "C++, C", "input": "#include <algorithm>\n#include <string>\n#include <cctype>\n\n\n\nvoid str_toupper(std::string &str) {\n  std::transform(str.begin(), \n                 str.end(), \n                 str.begin(),\n                 (int(*)(int)) std::toupper);\n}\n\n\n\nvoid str_tolower(std::string &str) {\n  std::transform(str.begin(), \n                 str.end(), \n                 str.begin(),\n                 (int(*)(int)) std::tolower);\n}", "gold": "#include <ctype.h>\n#include <stdio.h>\n\n\nvoid str_toupper(char *s)\n{\n    while(*s)\n    {\n        *s=toupper(*s);\n        s++;\n    }\n}\n\n\n\nvoid str_tolower(char *s)\n{\n    while(*s)\n    {\n        *s=tolower(*s);\n        s++;\n    }\n}\n\nint main(int argc, char *argv[])\n{\n    char t[255]=\"alphaBETA\";\n    str_toupper(t);\n    printf(\"uppercase: %s\\n\", t);\n    str_tolower(t);\n    printf(\"lowercase: %s\\n\", t);\n    return 0;\n}", "llm": "magic-7b", "output": "#include <ctype.h>\n#include <string.h>\n\nvoid str_toupper(char *str) {\n  for (char *p = str; *p; p++)\n    *p = toupper((unsigned char)*p);\n}\n\nvoid str_tolower(char *str) {\n  for (char *p = str; *p; p++)\n    *p = tolower((unsigned char)*p);\n}", "index": 7}
{"lang": "C++, C", "input": "#include <algorithm>\n#include <string>\n#include <cctype>\n\n\n\nvoid str_toupper(std::string &str) {\n  std::transform(str.begin(), \n                 str.end(), \n                 str.begin(),\n                 (int(*)(int)) std::toupper);\n}\n\n\n\nvoid str_tolower(std::string &str) {\n  std::transform(str.begin(), \n                 str.end(), \n                 str.begin(),\n                 (int(*)(int)) std::tolower);\n}", "gold": "#include <ctype.h>\n#include <stdio.h>\n\n\nvoid str_toupper(char *s)\n{\n    while(*s)\n    {\n        *s=toupper(*s);\n        s++;\n    }\n}\n\n\n\nvoid str_tolower(char *s)\n{\n    while(*s)\n    {\n        *s=tolower(*s);\n        s++;\n    }\n}\n\nint main(int argc, char *argv[])\n{\n    char t[255]=\"alphaBETA\";\n    str_toupper(t);\n    printf(\"uppercase: %s\\n\", t);\n    str_tolower(t);\n    printf(\"lowercase: %s\\n\", t);\n    return 0;\n}", "llm": "cg4-9b", "output": "#include <ctype.h>\n#include <string.h>\n\nvoid str_toupper(char *str) {\n  int len = strlen(str);\n  for (int i = 0; i < len; i++) {\n    str[i] = toupper(str[i]);\n  }\n}\n\nvoid str_tolower(char *str) {\n  int len = strlen(str);\n  for (int i = 0; i < len; i++) {\n    str[i] = tolower(str[i]);\n  }\n}", "index": 8}
{"lang": "C++, C", "input": "#include <iostream>\n\n#define MAX 15\n\nusing namespace std;\n\nint count_divisors(int n) {\n    int count = 0;\n    for (int i = 1; i * i <= n; ++i) {\n        if (!(n % i)) {\n            if (i == n / i)\n                count++;\n            else\n                count += 2;\n        }\n    }\n    return count;\n}\n\nint main() {\n    int i, k, n, seq[MAX];\n    for (i = 0; i < MAX; ++i) seq[i] = 0;\n    cout << \"The first \" << MAX << \" terms of the sequence are:\" << endl;\n    for (i = 1, n = 0; n <  MAX; ++i) {\n        k = count_divisors(i);\n        if (k <= MAX && seq[k - 1] == 0) {\n            seq[k - 1] = i;\n            ++n;\n        }\n    }\n    for (i = 0; i < MAX; ++i) cout << seq[i] << \" \";\n    cout << endl;\n    return 0;\n}", "gold": "#include <stdio.h>\n\n#define MAX 15\n\nint count_divisors(int n) {\n    int i, count = 0;\n    for (i = 1; i * i <= n; ++i) {\n        if (!(n % i)) {\n            if (i == n / i)\n                count++;\n            else\n                count += 2;\n        }\n    }\n    return count;\n}\n\nint main() {\n    int i, k, n, seq[MAX];\n    for (i = 0; i < MAX; ++i) seq[i] = 0;\n    printf(\"The first %d terms of the sequence are:\\n\", MAX);\n    for (i = 1, n = 0; n <  MAX; ++i) {\n        k = count_divisors(i);\n        if (k <= MAX && seq[k - 1] == 0) {\n            seq[k - 1] = i;\n            ++n;\n        }\n    }\n    for (i = 0; i < MAX; ++i) printf(\"%d \", seq[i]);\n    printf(\"\\n\");\n    return 0;\n}", "llm": "cl-7b", "output": "#include <iostream>\n\n#define MAX 15\n\nint count_divisors(int n) {\n    int count = 0;\n    for (int i = 1; i * i <= n; ++i) {\n        if (!(n % i)) {\n            if (i == n / i)\n                count++;\n            else\n                count += 2;\n        }\n    }\n    return count;\n}\n\nint main() {\n    int i, k, n, seq[MAX];\n    for (i = 0; i < MAX; ++i) seq[i] = 0;\n    cout << \"The first \" << MAX << \" terms of the sequence are:\" << endl;\n    for (i = 1, n = 0; n <  MAX; ++i) {\n        k = count_divisors(i);\n        if (k <= MAX && seq[k - 1] == 0) {\n            seq[k - 1] = i;\n            ++n;\n        }\n    }\n    for (i = 0; i < MAX; ++i) cout << seq[i] << \" \";\n    cout << endl;\n    return 0;\n}", "index": 9}
{"lang": "C++, C", "input": "#include <iostream>\n\n#define MAX 15\n\nusing namespace std;\n\nint count_divisors(int n) {\n    int count = 0;\n    for (int i = 1; i * i <= n; ++i) {\n        if (!(n % i)) {\n            if (i == n / i)\n                count++;\n            else\n                count += 2;\n        }\n    }\n    return count;\n}\n\nint main() {\n    int i, k, n, seq[MAX];\n    for (i = 0; i < MAX; ++i) seq[i] = 0;\n    cout << \"The first \" << MAX << \" terms of the sequence are:\" << endl;\n    for (i = 1, n = 0; n <  MAX; ++i) {\n        k = count_divisors(i);\n        if (k <= MAX && seq[k - 1] == 0) {\n            seq[k - 1] = i;\n            ++n;\n        }\n    }\n    for (i = 0; i < MAX; ++i) cout << seq[i] << \" \";\n    cout << endl;\n    return 0;\n}", "gold": "#include <stdio.h>\n\n#define MAX 15\n\nint count_divisors(int n) {\n    int i, count = 0;\n    for (i = 1; i * i <= n; ++i) {\n        if (!(n % i)) {\n            if (i == n / i)\n                count++;\n            else\n                count += 2;\n        }\n    }\n    return count;\n}\n\nint main() {\n    int i, k, n, seq[MAX];\n    for (i = 0; i < MAX; ++i) seq[i] = 0;\n    printf(\"The first %d terms of the sequence are:\\n\", MAX);\n    for (i = 1, n = 0; n <  MAX; ++i) {\n        k = count_divisors(i);\n        if (k <= MAX && seq[k - 1] == 0) {\n            seq[k - 1] = i;\n            ++n;\n        }\n    }\n    for (i = 0; i < MAX; ++i) printf(\"%d \", seq[i]);\n    printf(\"\\n\");\n    return 0;\n}", "llm": "dsc-33b", "output": "#include <stdio.h>\n\n#define MAX 15\n\nint count_divisors(int n) {\n    int count = 0;\n    for (int i = 1; i * i <= n; ++i) {\n        if (!(n % i)) {\n            if (i == n / i)\n                count++;\n            else\n                count += 2;\n        }\n    }\n    return count;\n}\n\nint main() {\n    int i, k, n, seq[MAX];\n    for (i = 0; i < MAX; ++i) seq[i] = 0;\n    printf(\"The first %d terms of the sequence are:\\n\", MAX);\n    for (i = 1, n = 0; n <  MAX; ++i) {\n        k = count_divisors(i);\n        if (k <= MAX && seq[k - 1] == 0) {\n            seq[k - 1] = i;\n            ++n;\n        }\n    }\n    for (i = 0; i < MAX; ++i) printf(\"%d \", seq[i]);\n    printf(\"\\n\");\n    return 0;\n}", "index": 10}
{"lang": "C++, C", "input": "#include <iostream>\n\n#define MAX 15\n\nusing namespace std;\n\nint count_divisors(int n) {\n    int count = 0;\n    for (int i = 1; i * i <= n; ++i) {\n        if (!(n % i)) {\n            if (i == n / i)\n                count++;\n            else\n                count += 2;\n        }\n    }\n    return count;\n}\n\nint main() {\n    int i, k, n, seq[MAX];\n    for (i = 0; i < MAX; ++i) seq[i] = 0;\n    cout << \"The first \" << MAX << \" terms of the sequence are:\" << endl;\n    for (i = 1, n = 0; n <  MAX; ++i) {\n        k = count_divisors(i);\n        if (k <= MAX && seq[k - 1] == 0) {\n            seq[k - 1] = i;\n            ++n;\n        }\n    }\n    for (i = 0; i < MAX; ++i) cout << seq[i] << \" \";\n    cout << endl;\n    return 0;\n}", "gold": "#include <stdio.h>\n\n#define MAX 15\n\nint count_divisors(int n) {\n    int i, count = 0;\n    for (i = 1; i * i <= n; ++i) {\n        if (!(n % i)) {\n            if (i == n / i)\n                count++;\n            else\n                count += 2;\n        }\n    }\n    return count;\n}\n\nint main() {\n    int i, k, n, seq[MAX];\n    for (i = 0; i < MAX; ++i) seq[i] = 0;\n    printf(\"The first %d terms of the sequence are:\\n\", MAX);\n    for (i = 1, n = 0; n <  MAX; ++i) {\n        k = count_divisors(i);\n        if (k <= MAX && seq[k - 1] == 0) {\n            seq[k - 1] = i;\n            ++n;\n        }\n    }\n    for (i = 0; i < MAX; ++i) printf(\"%d \", seq[i]);\n    printf(\"\\n\");\n    return 0;\n}", "llm": "cg4-9b", "output": "#include <stdio.h>\n\n#define MAX 15\n\nint count_divisors(int n) {\n    int count = 0;\n    for (int i = 1; i * i <= n; ++i) {\n        if (!(n % i)) {\n            if (i == n / i)\n                count++;\n            else\n                count += 2;\n        }\n    }\n    return count;\n}\n\nint main() {\n    int i, k, n, seq[MAX];\n    for (i = 0; i < MAX; ++i) seq[i] = 0;\n    printf(\"The first %d terms of the sequence are:\\n\", MAX);\n    for (i = 1, n = 0; n <  MAX; ++i) {\n        k = count_divisors(i);\n        if (k <= MAX && seq[k - 1] == 0) {\n            seq[k - 1] = i;\n            ++n;\n        }\n    }\n    for (i = 0; i < MAX; ++i) printf(\"%d \", seq[i]);\n    printf(\"\\n\");\n    return 0;\n}", "index": 11}
{"lang": "C++, Python", "input": "#include <iostream>\n#include <functional>\n#include <map>\n#include <vector>\n\nstruct Node {\n    int length;\n    std::map<char, int> edges;\n    int suffix;\n\n    Node(int l) : length(l), suffix(0) {\n        \n    }\n\n    Node(int l, const std::map<char, int>& m, int s) : length(l), edges(m), suffix(s) {\n        \n    }\n};\n\nconstexpr int evenRoot = 0;\nconstexpr int oddRoot = 1;\n\nstd::vector<Node> eertree(const std::string& s) {\n    std::vector<Node> tree = {\n        Node(0, {}, oddRoot),\n        Node(-1, {}, oddRoot)\n    };\n    int suffix = oddRoot;\n    int n, k;\n\n    for (size_t i = 0; i < s.length(); ++i) {\n        char c = s[i];\n        for (n = suffix; ; n = tree[n].suffix) {\n            k = tree[n].length;\n            int b = i - k - 1;\n            if (b >= 0 && s[b] == c) {\n                break;\n            }\n        }\n\n        auto it = tree[n].edges.find(c);\n        auto end = tree[n].edges.end();\n        if (it != end) {\n            suffix = it->second;\n            continue;\n        }\n        suffix = tree.size();\n        tree.push_back(Node(k + 2));\n        tree[n].edges[c] = suffix;\n        if (tree[suffix].length == 1) {\n            tree[suffix].suffix = 0;\n            continue;\n        }\n        while (true) {\n            n = tree[n].suffix;\n            int b = i - tree[n].length - 1;\n            if (b >= 0 && s[b] == c) {\n                break;\n            }\n        }\n        tree[suffix].suffix = tree[n].edges[c];\n    }\n\n    return tree;\n}\n\nstd::vector<std::string> subPalindromes(const std::vector<Node>& tree) {\n    std::vector<std::string> s;\n\n    std::function<void(int, std::string)> children;\n    children = [&children, &tree, &s](int n, std::string p) {\n        auto it = tree[n].edges.cbegin();\n        auto end = tree[n].edges.cend();\n        for (; it != end; it = std::next(it)) {\n            auto c = it->first;\n            auto m = it->second;\n\n            std::string pl = c + p + c;\n            s.push_back(pl);\n            children(m, pl);\n        }\n    };\n    children(0, \"\");\n\n    auto it = tree[1].edges.cbegin();\n    auto end = tree[1].edges.cend();\n    for (; it != end; it = std::next(it)) {\n        auto c = it->first;\n        auto n = it->second;\n\n        std::string ct(1, c);\n        s.push_back(ct);\n\n        children(n, ct);\n    }\n\n    return s;\n}\n\nint main() {\n    using namespace std;\n\n    auto tree = eertree(\"eertree\");\n    auto pal = subPalindromes(tree);\n\n    auto it = pal.cbegin();\n    auto end = pal.cend();\n\n    cout << \"[\";\n    if (it != end) {\n        cout << it->c_str();\n        it++;\n    }\n    while (it != end) {\n        cout << \", \" << it->c_str();\n        it++;\n    }\n    cout << \"]\" << endl;\n\n    return 0;\n}", "gold": "from __future__ import print_function\n\nclass Node(object):\n\tdef __init__(self):\n\t\tself.edges = {} \n\t\tself.link = None \n\t\tself.len = 0 \n\nclass Eertree(object):\n\tdef __init__(self):\n\t\tself.nodes = []\n\t\t\n\t\tself.rto = Node() \n\t\tself.rte = Node() \n\n\t\t\n\t\tself.rto.link = self.rte.link = self.rto;\n\t\tself.rto.len = -1\n\t\tself.rte.len = 0\n\t\tself.S = [0] \n\t\tself.maxSufT = self.rte \n\n\tdef get_max_suffix_pal(self, startNode, a):\n\t\t\n\t\t\n\t\t\n\t\tu = startNode\n\t\ti = len(self.S)\n\t\tk = u.len\n\t\twhile id(u) != id(self.rto) and self.S[i - k - 1] != a:\n\t\t\tassert id(u) != id(u.link) \n\t\t\tu = u.link\n\t\t\tk = u.len\n\n\t\treturn u\n\t\n\tdef add(self, a):\n\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tQ = self.get_max_suffix_pal(self.maxSufT, a)\n\n\t\t\n\t\tcreateANewNode = not a in Q.edges\n\n\t\tif createANewNode:\n\t\t\t\n\t\t\tP = Node()\n\t\t\tself.nodes.append(P)\n\t\t\tP.len = Q.len + 2\n\t\t\tif P.len == 1:\n\t\t\t\t\n\t\t\t\tP.link = self.rte\n\t\t\telse:\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tP.link = self.get_max_suffix_pal(Q.link, a).edges[a]\n\n\t\t\t\n\t\t\tQ.edges[a] = P\n\n\t\t\n\t\tself.maxSufT = Q.edges[a]\n\n\t\t\n\t\tself.S.append(a)\n\n\t\treturn createANewNode\n\t\n\tdef get_sub_palindromes(self, nd, nodesToHere, charsToHere, result):\n\t\t\n\t\t\n\n\t\t\n\t\tfor lnkName in nd.edges:\n\t\t\tnd2 = nd.edges[lnkName] \n\t\t\tself.get_sub_palindromes(nd2, nodesToHere+[nd2], charsToHere+[lnkName], result)\n\n\t\t\n\t\tif id(nd) != id(self.rto) and id(nd) != id(self.rte): \n\t\t\ttmp = \"\".join(charsToHere)\n\t\t\tif id(nodesToHere[0]) == id(self.rte): \n\t\t\t\tassembled = tmp[::-1] + tmp\n\t\t\telse: \n\t\t\t\tassembled = tmp[::-1] + tmp[1:]\n\t\t\tresult.append(assembled)\n\nif __name__==\"__main__\":\n\tst = \"eertree\"\n\tprint (\"Processing string\", st)\n\teertree = Eertree()\n\tfor ch in st:\n\t\teertree.add(ch)\n\n\tprint (\"Number of sub-palindromes:\", len(eertree.nodes))\n\n\t\n\tresult = []\n\teertree.get_sub_palindromes(eertree.rto, [eertree.rto], [], result) \n\teertree.get_sub_palindromes(eertree.rte, [eertree.rte], [], result) \n\tprint (\"Sub-palindromes:\", result)", "llm": "q2.5-7b", "output": "class Node:\n    def __init__(self, length, edges=None, suffix=0):\n        self.length = length\n        self.edges = edges if edges is not None else {}\n        self.suffix = suffix\n\nevenRoot = 0\noddRoot = 1\n\ndef eertree(s):\n    tree = [Node(0, {}, oddRoot), Node(-1, {}, oddRoot)]\n    suffix = oddRoot\n    n, k = 0, 0\n\n    for i, c in enumerate(s):\n        for n in range(suffix, -1, -1):\n            k = tree[n].length\n            b = i - k - 1\n            if b >= 0 and s[b] == c:\n                break\n\n        if c in tree[n].edges:\n            suffix = tree[n].edges[c]\n            continue\n        suffix = len(tree)\n        tree.append(Node(k + 2))\n        tree[n].edges[c] = suffix\n        if tree[suffix].length == 1:\n            tree[suffix].suffix = 0\n            continue\n        while True:\n            n = tree[n].suffix\n            b = i - tree[n].length - 1\n            if b >= 0 and s[b] == c:\n                break\n        tree[suffix].suffix = tree[n].edges[c]\n\n    return tree\n\ndef subPalindromes(tree):\n    s = []\n\n    def children(n, p):\n        for c, m in tree[n].edges.items():\n            pl = c + p + c\n            s.append(pl)\n            children(m, pl)\n\n    children(0, \"\")\n    for c, n in tree[1].edges.items():\n        ct = c\n        s.append(ct)\n        children(n, ct)\n\n    return s\n\ndef main():\n    tree = eertree(\"eertree\")\n    pal = subPalindromes(tree)\n\n    print(\"[\", end=\"\")\n    if pal:\n        print(pal[0], end=\"\")\n        for p in pal[1:]:\n            print(\", \" + p, end=\"\")\n    print(\"]\")\n\nif __name__ == \"__main__\":\n    main()", "index": 12}
{"lang": "C++, Python", "input": "#include <iostream>\n#include <functional>\n#include <map>\n#include <vector>\n\nstruct Node {\n    int length;\n    std::map<char, int> edges;\n    int suffix;\n\n    Node(int l) : length(l), suffix(0) {\n        \n    }\n\n    Node(int l, const std::map<char, int>& m, int s) : length(l), edges(m), suffix(s) {\n        \n    }\n};\n\nconstexpr int evenRoot = 0;\nconstexpr int oddRoot = 1;\n\nstd::vector<Node> eertree(const std::string& s) {\n    std::vector<Node> tree = {\n        Node(0, {}, oddRoot),\n        Node(-1, {}, oddRoot)\n    };\n    int suffix = oddRoot;\n    int n, k;\n\n    for (size_t i = 0; i < s.length(); ++i) {\n        char c = s[i];\n        for (n = suffix; ; n = tree[n].suffix) {\n            k = tree[n].length;\n            int b = i - k - 1;\n            if (b >= 0 && s[b] == c) {\n                break;\n            }\n        }\n\n        auto it = tree[n].edges.find(c);\n        auto end = tree[n].edges.end();\n        if (it != end) {\n            suffix = it->second;\n            continue;\n        }\n        suffix = tree.size();\n        tree.push_back(Node(k + 2));\n        tree[n].edges[c] = suffix;\n        if (tree[suffix].length == 1) {\n            tree[suffix].suffix = 0;\n            continue;\n        }\n        while (true) {\n            n = tree[n].suffix;\n            int b = i - tree[n].length - 1;\n            if (b >= 0 && s[b] == c) {\n                break;\n            }\n        }\n        tree[suffix].suffix = tree[n].edges[c];\n    }\n\n    return tree;\n}\n\nstd::vector<std::string> subPalindromes(const std::vector<Node>& tree) {\n    std::vector<std::string> s;\n\n    std::function<void(int, std::string)> children;\n    children = [&children, &tree, &s](int n, std::string p) {\n        auto it = tree[n].edges.cbegin();\n        auto end = tree[n].edges.cend();\n        for (; it != end; it = std::next(it)) {\n            auto c = it->first;\n            auto m = it->second;\n\n            std::string pl = c + p + c;\n            s.push_back(pl);\n            children(m, pl);\n        }\n    };\n    children(0, \"\");\n\n    auto it = tree[1].edges.cbegin();\n    auto end = tree[1].edges.cend();\n    for (; it != end; it = std::next(it)) {\n        auto c = it->first;\n        auto n = it->second;\n\n        std::string ct(1, c);\n        s.push_back(ct);\n\n        children(n, ct);\n    }\n\n    return s;\n}\n\nint main() {\n    using namespace std;\n\n    auto tree = eertree(\"eertree\");\n    auto pal = subPalindromes(tree);\n\n    auto it = pal.cbegin();\n    auto end = pal.cend();\n\n    cout << \"[\";\n    if (it != end) {\n        cout << it->c_str();\n        it++;\n    }\n    while (it != end) {\n        cout << \", \" << it->c_str();\n        it++;\n    }\n    cout << \"]\" << endl;\n\n    return 0;\n}", "gold": "from __future__ import print_function\n\nclass Node(object):\n\tdef __init__(self):\n\t\tself.edges = {} \n\t\tself.link = None \n\t\tself.len = 0 \n\nclass Eertree(object):\n\tdef __init__(self):\n\t\tself.nodes = []\n\t\t\n\t\tself.rto = Node() \n\t\tself.rte = Node() \n\n\t\t\n\t\tself.rto.link = self.rte.link = self.rto;\n\t\tself.rto.len = -1\n\t\tself.rte.len = 0\n\t\tself.S = [0] \n\t\tself.maxSufT = self.rte \n\n\tdef get_max_suffix_pal(self, startNode, a):\n\t\t\n\t\t\n\t\t\n\t\tu = startNode\n\t\ti = len(self.S)\n\t\tk = u.len\n\t\twhile id(u) != id(self.rto) and self.S[i - k - 1] != a:\n\t\t\tassert id(u) != id(u.link) \n\t\t\tu = u.link\n\t\t\tk = u.len\n\n\t\treturn u\n\t\n\tdef add(self, a):\n\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tQ = self.get_max_suffix_pal(self.maxSufT, a)\n\n\t\t\n\t\tcreateANewNode = not a in Q.edges\n\n\t\tif createANewNode:\n\t\t\t\n\t\t\tP = Node()\n\t\t\tself.nodes.append(P)\n\t\t\tP.len = Q.len + 2\n\t\t\tif P.len == 1:\n\t\t\t\t\n\t\t\t\tP.link = self.rte\n\t\t\telse:\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tP.link = self.get_max_suffix_pal(Q.link, a).edges[a]\n\n\t\t\t\n\t\t\tQ.edges[a] = P\n\n\t\t\n\t\tself.maxSufT = Q.edges[a]\n\n\t\t\n\t\tself.S.append(a)\n\n\t\treturn createANewNode\n\t\n\tdef get_sub_palindromes(self, nd, nodesToHere, charsToHere, result):\n\t\t\n\t\t\n\n\t\t\n\t\tfor lnkName in nd.edges:\n\t\t\tnd2 = nd.edges[lnkName] \n\t\t\tself.get_sub_palindromes(nd2, nodesToHere+[nd2], charsToHere+[lnkName], result)\n\n\t\t\n\t\tif id(nd) != id(self.rto) and id(nd) != id(self.rte): \n\t\t\ttmp = \"\".join(charsToHere)\n\t\t\tif id(nodesToHere[0]) == id(self.rte): \n\t\t\t\tassembled = tmp[::-1] + tmp\n\t\t\telse: \n\t\t\t\tassembled = tmp[::-1] + tmp[1:]\n\t\t\tresult.append(assembled)\n\nif __name__==\"__main__\":\n\tst = \"eertree\"\n\tprint (\"Processing string\", st)\n\teertree = Eertree()\n\tfor ch in st:\n\t\teertree.add(ch)\n\n\tprint (\"Number of sub-palindromes:\", len(eertree.nodes))\n\n\t\n\tresult = []\n\teertree.get_sub_palindromes(eertree.rto, [eertree.rto], [], result) \n\teertree.get_sub_palindromes(eertree.rte, [eertree.rte], [], result) \n\tprint (\"Sub-palindromes:\", result)", "llm": "magic-7b", "output": "class Node:\n    def __init__(self, l, m=None, s=0):\n        self.length = l\n        self.edges = m if m is not None else {}\n        self.suffix = s\n\ndef eertree(s):\n    tree = [Node(0, {}, 1), Node(-1, {}, 1)]\n    suffix = 1\n    n, k = 0, 0\n\n    for i in range(len(s)):\n        c = s[i]\n        for n in range(suffix, -1, -1):\n            k = tree[n].length\n            b = i - k - 1\n            if b >= 0 and s[b] == c:\n                break\n\n        if c in tree[n].edges:\n            suffix = tree[n].edges[c]\n            continue\n        suffix = len(tree)\n        tree.append(Node(k + 2))\n        tree[n].edges[c] = suffix\n        if tree[suffix].length == 1:\n            tree[suffix].suffix = 0\n            continue\n        while True:\n            n = tree[n].suffix\n            b = i - tree[n].length - 1\n            if b >= 0 and s[b] == c:\n                break\n        tree[suffix].suffix = tree[n].edges[c]\n\n    return tree\n\ndef subPalindromes(tree):\n    s = []\n\n    def children(n, p):\n        for c, m in tree[n].edges.items():\n            pl = c + p + c\n            s.append(pl)\n            children(m, pl)\n\n    children(0, \"\")\n\n    for c, n in tree[1].edges.items():\n        ct = c\n        s.append(ct)\n        children(n, ct)\n\n    return s\n\ntree = eertree(\"eertree\")\npal = subPalindromes(tree)\n\nprint(pal)", "index": 13}
{"lang": "C++, Python", "input": "#include <iostream>\n#include <functional>\n#include <map>\n#include <vector>\n\nstruct Node {\n    int length;\n    std::map<char, int> edges;\n    int suffix;\n\n    Node(int l) : length(l), suffix(0) {\n        \n    }\n\n    Node(int l, const std::map<char, int>& m, int s) : length(l), edges(m), suffix(s) {\n        \n    }\n};\n\nconstexpr int evenRoot = 0;\nconstexpr int oddRoot = 1;\n\nstd::vector<Node> eertree(const std::string& s) {\n    std::vector<Node> tree = {\n        Node(0, {}, oddRoot),\n        Node(-1, {}, oddRoot)\n    };\n    int suffix = oddRoot;\n    int n, k;\n\n    for (size_t i = 0; i < s.length(); ++i) {\n        char c = s[i];\n        for (n = suffix; ; n = tree[n].suffix) {\n            k = tree[n].length;\n            int b = i - k - 1;\n            if (b >= 0 && s[b] == c) {\n                break;\n            }\n        }\n\n        auto it = tree[n].edges.find(c);\n        auto end = tree[n].edges.end();\n        if (it != end) {\n            suffix = it->second;\n            continue;\n        }\n        suffix = tree.size();\n        tree.push_back(Node(k + 2));\n        tree[n].edges[c] = suffix;\n        if (tree[suffix].length == 1) {\n            tree[suffix].suffix = 0;\n            continue;\n        }\n        while (true) {\n            n = tree[n].suffix;\n            int b = i - tree[n].length - 1;\n            if (b >= 0 && s[b] == c) {\n                break;\n            }\n        }\n        tree[suffix].suffix = tree[n].edges[c];\n    }\n\n    return tree;\n}\n\nstd::vector<std::string> subPalindromes(const std::vector<Node>& tree) {\n    std::vector<std::string> s;\n\n    std::function<void(int, std::string)> children;\n    children = [&children, &tree, &s](int n, std::string p) {\n        auto it = tree[n].edges.cbegin();\n        auto end = tree[n].edges.cend();\n        for (; it != end; it = std::next(it)) {\n            auto c = it->first;\n            auto m = it->second;\n\n            std::string pl = c + p + c;\n            s.push_back(pl);\n            children(m, pl);\n        }\n    };\n    children(0, \"\");\n\n    auto it = tree[1].edges.cbegin();\n    auto end = tree[1].edges.cend();\n    for (; it != end; it = std::next(it)) {\n        auto c = it->first;\n        auto n = it->second;\n\n        std::string ct(1, c);\n        s.push_back(ct);\n\n        children(n, ct);\n    }\n\n    return s;\n}\n\nint main() {\n    using namespace std;\n\n    auto tree = eertree(\"eertree\");\n    auto pal = subPalindromes(tree);\n\n    auto it = pal.cbegin();\n    auto end = pal.cend();\n\n    cout << \"[\";\n    if (it != end) {\n        cout << it->c_str();\n        it++;\n    }\n    while (it != end) {\n        cout << \", \" << it->c_str();\n        it++;\n    }\n    cout << \"]\" << endl;\n\n    return 0;\n}", "gold": "from __future__ import print_function\n\nclass Node(object):\n\tdef __init__(self):\n\t\tself.edges = {} \n\t\tself.link = None \n\t\tself.len = 0 \n\nclass Eertree(object):\n\tdef __init__(self):\n\t\tself.nodes = []\n\t\t\n\t\tself.rto = Node() \n\t\tself.rte = Node() \n\n\t\t\n\t\tself.rto.link = self.rte.link = self.rto;\n\t\tself.rto.len = -1\n\t\tself.rte.len = 0\n\t\tself.S = [0] \n\t\tself.maxSufT = self.rte \n\n\tdef get_max_suffix_pal(self, startNode, a):\n\t\t\n\t\t\n\t\t\n\t\tu = startNode\n\t\ti = len(self.S)\n\t\tk = u.len\n\t\twhile id(u) != id(self.rto) and self.S[i - k - 1] != a:\n\t\t\tassert id(u) != id(u.link) \n\t\t\tu = u.link\n\t\t\tk = u.len\n\n\t\treturn u\n\t\n\tdef add(self, a):\n\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tQ = self.get_max_suffix_pal(self.maxSufT, a)\n\n\t\t\n\t\tcreateANewNode = not a in Q.edges\n\n\t\tif createANewNode:\n\t\t\t\n\t\t\tP = Node()\n\t\t\tself.nodes.append(P)\n\t\t\tP.len = Q.len + 2\n\t\t\tif P.len == 1:\n\t\t\t\t\n\t\t\t\tP.link = self.rte\n\t\t\telse:\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tP.link = self.get_max_suffix_pal(Q.link, a).edges[a]\n\n\t\t\t\n\t\t\tQ.edges[a] = P\n\n\t\t\n\t\tself.maxSufT = Q.edges[a]\n\n\t\t\n\t\tself.S.append(a)\n\n\t\treturn createANewNode\n\t\n\tdef get_sub_palindromes(self, nd, nodesToHere, charsToHere, result):\n\t\t\n\t\t\n\n\t\t\n\t\tfor lnkName in nd.edges:\n\t\t\tnd2 = nd.edges[lnkName] \n\t\t\tself.get_sub_palindromes(nd2, nodesToHere+[nd2], charsToHere+[lnkName], result)\n\n\t\t\n\t\tif id(nd) != id(self.rto) and id(nd) != id(self.rte): \n\t\t\ttmp = \"\".join(charsToHere)\n\t\t\tif id(nodesToHere[0]) == id(self.rte): \n\t\t\t\tassembled = tmp[::-1] + tmp\n\t\t\telse: \n\t\t\t\tassembled = tmp[::-1] + tmp[1:]\n\t\t\tresult.append(assembled)\n\nif __name__==\"__main__\":\n\tst = \"eertree\"\n\tprint (\"Processing string\", st)\n\teertree = Eertree()\n\tfor ch in st:\n\t\teertree.add(ch)\n\n\tprint (\"Number of sub-palindromes:\", len(eertree.nodes))\n\n\t\n\tresult = []\n\teertree.get_sub_palindromes(eertree.rto, [eertree.rto], [], result) \n\teertree.get_sub_palindromes(eertree.rte, [eertree.rte], [], result) \n\tprint (\"Sub-palindromes:\", result)", "llm": "cs-22b", "output": "class Node:\n    def __init__(self, l, m=None, s=0):\n        self.length = l\n        self.edges = m if m else {}\n        self.suffix = s\n\nevenRoot = 0\noddRoot = 1\n\ndef eertree(s):\n    tree = [Node(0, {}, oddRoot), Node(-1, {}, oddRoot)]\n    suffix = oddRoot\n    n, k = 0, 0\n\n    for i in range(len(s)):\n        c = s[i]\n        n = suffix\n        while True:\n            k = tree[n].length\n            b = i - k - 1\n            if b >= 0 and s[b] == c:\n                break\n            n = tree[n].suffix\n\n        if c in tree[n].edges:\n            suffix = tree[n].edges[c]\n            continue\n\n        suffix = len(tree)\n        tree.append(Node(k + 2))\n        tree[n].edges[c] = suffix\n        if tree[suffix].length == 1:\n            tree[suffix].suffix = 0\n            continue\n\n        while True:\n            n = tree[n].suffix\n            b = i - tree[n].length - 1\n            if b >= 0 and s[b] == c:\n                break\n\n        tree[suffix].suffix = tree[n].edges[c]\n\n    return tree\n\ndef subPalindromes(tree):\n    s = []\n\n    def children(n, p):\n        for c, m in tree[n].edges.items():\n            pl = c + p + c\n            s.append(pl)\n            children(m, pl)\n\n    children(0, \"\")\n\n    for c, n in tree[1].edges.items():\n        ct = c\n        s.append(ct)\n        children(n, ct)\n\n    return s\n\ntree = eertree(\"eertree\")\npal = subPalindromes(tree)\nprint(pal)", "index": 14}
{"lang": "C++, Python", "input": "#include <iostream>\n#include <map>\n#include <string>\n\nint main() {\n  std::map<std::string, int> dict {\n    {\"One\", 1},\n    {\"Two\", 2},\n    {\"Three\", 7}\n  };\n\n  dict[\"Three\"] = 3;\n\n  std::cout << \"One: \" << dict[\"One\"] << std::endl;\n  std::cout << \"Key/Value pairs: \" << std::endl;\n  for(auto& kv: dict) {\n    std::cout << \"  \" << kv.first << \": \" << kv.second << std::endl;\n  }\n\n  return 0;\n}", "gold": "myDict = { \"hello\": 13,\n\t   \"world\": 31,\n\t   \"!\"    : 71 }\n\n\nfor key, value in myDict.items():\n    print (\"key = %s, value = %s\" % (key, value))\n\n\nfor key in myDict:\n    print (\"key = %s\" % key)\n\nfor key in myDict.keys():\n    print (\"key = %s\" % key)\n\n\nfor value in myDict.values():\n    print (\"value = %s\" % value)", "llm": "cl-13b", "output": "import sys\n\ndict = {\n    \"One\": 1,\n    \"Two\": 2,\n    \"Three\": 7\n}\n\ndict[\"Three\"] = 3\n\nprint(\"One:\", dict[\"One\"])\nprint(\"Key/Value pairs:\")\nfor key, value in dict.items():\n    print(\"  \", key, \":\", value)\n\nsys.exit(0)", "index": 15}
{"lang": "C++, Python", "input": "#include <iostream>\n#include <map>\n#include <string>\n\nint main() {\n  std::map<std::string, int> dict {\n    {\"One\", 1},\n    {\"Two\", 2},\n    {\"Three\", 7}\n  };\n\n  dict[\"Three\"] = 3;\n\n  std::cout << \"One: \" << dict[\"One\"] << std::endl;\n  std::cout << \"Key/Value pairs: \" << std::endl;\n  for(auto& kv: dict) {\n    std::cout << \"  \" << kv.first << \": \" << kv.second << std::endl;\n  }\n\n  return 0;\n}", "gold": "myDict = { \"hello\": 13,\n\t   \"world\": 31,\n\t   \"!\"    : 71 }\n\n\nfor key, value in myDict.items():\n    print (\"key = %s, value = %s\" % (key, value))\n\n\nfor key in myDict:\n    print (\"key = %s\" % key)\n\nfor key in myDict.keys():\n    print (\"key = %s\" % key)\n\n\nfor value in myDict.values():\n    print (\"value = %s\" % value)", "llm": "q2.5-1.5b", "output": "{\n  \"One\": 1,\n  \"Two\": 2,\n  \"Three\": 3\n}", "index": 16}
{"lang": "C++, Python", "input": "#include <iostream>\n#include <map>\n#include <string>\n\nint main() {\n  std::map<std::string, int> dict {\n    {\"One\", 1},\n    {\"Two\", 2},\n    {\"Three\", 7}\n  };\n\n  dict[\"Three\"] = 3;\n\n  std::cout << \"One: \" << dict[\"One\"] << std::endl;\n  std::cout << \"Key/Value pairs: \" << std::endl;\n  for(auto& kv: dict) {\n    std::cout << \"  \" << kv.first << \": \" << kv.second << std::endl;\n  }\n\n  return 0;\n}", "gold": "myDict = { \"hello\": 13,\n\t   \"world\": 31,\n\t   \"!\"    : 71 }\n\n\nfor key, value in myDict.items():\n    print (\"key = %s, value = %s\" % (key, value))\n\n\nfor key in myDict:\n    print (\"key = %s\" % key)\n\nfor key in myDict.keys():\n    print (\"key = %s\" % key)\n\n\nfor value in myDict.values():\n    print (\"value = %s\" % value)", "llm": "cg4-9b", "output": "dict = {\"One\": 1, \"Two\": 2, \"Three\": 7}\ndict[\"Three\"] = 3\nprint(\"One:\", dict[\"One\"])\nprint(\"Key/Value pairs:\")\nfor kv in dict.items():\n    print(\"  {}: {}\".format(kv[0], kv[1]))", "index": 17}
{"lang": "C++, C", "input": "#include <iostream>\n#include <ostream>\n#include <set>\n#include <vector>\n\ntemplate<typename T>\nstd::ostream& operator<<(std::ostream& os, const std::vector<T>& v) {\n    auto i = v.cbegin();\n    auto e = v.cend();\n    os << '[';\n    if (i != e) {\n        os << *i;\n        i = std::next(i);\n    }\n    while (i != e) {\n        os << \", \" << *i;\n        i = std::next(i);\n    }\n    return os << ']';\n}\n\nint main() {\n    using namespace std;\n\n    vector<int> a{ 0 };\n    set<int> used{ 0 };\n    set<int> used1000{ 0 };\n    bool foundDup = false;\n    int n = 1;\n    while (n <= 15 || !foundDup || used1000.size() < 1001) {\n        int next = a[n - 1] - n;\n        if (next < 1 || used.find(next) != used.end()) {\n            next += 2 * n;\n        }\n        bool alreadyUsed = used.find(next) != used.end();\n        a.push_back(next);\n        if (!alreadyUsed) {\n            used.insert(next);\n            if (0 <= next && next <= 1000) {\n                used1000.insert(next);\n            }\n        }\n        if (n == 14) {\n            cout << \"The first 15 terms of the Recaman sequence are: \" << a << '\\n';\n        }\n        if (!foundDup && alreadyUsed) {\n            cout << \"The first duplicated term is a[\" << n << \"] = \" << next << '\\n';\n            foundDup = true;\n        }\n        if (used1000.size() == 1001) {\n            cout << \"Terms up to a[\" << n << \"] are needed to generate 0 to 1000\\n\";\n        }\n        n++;\n    }\n\n    return 0;\n}", "gold": "#include <stdio.h>\n#include <stdlib.h>\n#include <gmodule.h>\n\ntypedef int bool;\n\nint main() {\n    int i, n, k = 0, next, *a;\n    bool foundDup = FALSE;\n    gboolean alreadyUsed;\n    GHashTable* used = g_hash_table_new(g_direct_hash, g_direct_equal);\n    GHashTable* used1000 = g_hash_table_new(g_direct_hash, g_direct_equal);\n    a = malloc(400000 * sizeof(int));\n    a[0] = 0;\n    g_hash_table_add(used, GINT_TO_POINTER(0));\n    g_hash_table_add(used1000, GINT_TO_POINTER(0));\n\n    for (n = 1; n <= 15 || !foundDup || k < 1001; ++n) {\n        next = a[n - 1] - n;\n        if (next < 1 || g_hash_table_contains(used, GINT_TO_POINTER(next))) {\n            next += 2 * n;\n        }\n        alreadyUsed = g_hash_table_contains(used, GINT_TO_POINTER(next));\n        a[n] = next;\n\n        if (!alreadyUsed) {\n            g_hash_table_add(used, GINT_TO_POINTER(next));\n            if (next >= 0 && next <= 1000) {\n                g_hash_table_add(used1000, GINT_TO_POINTER(next));\n            }\n        }\n\n        if (n == 14) {\n            printf(\"The first 15 terms of the Recaman's sequence are: \");\n            printf(\"[\");\n            for (i = 0; i < 15; ++i) printf(\"%d \", a[i]);\n            printf(\"\\b]\\n\");\n        }\n\n        if (!foundDup && alreadyUsed) {\n            printf(\"The first duplicated term is a[%d] = %d\\n\", n, next);\n            foundDup = TRUE;\n        }\n        k = g_hash_table_size(used1000);\n\n        if (k == 1001) {\n            printf(\"Terms up to a[%d] are needed to generate 0 to 1000\\n\", n);\n        }\n    }\n    g_hash_table_destroy(used);\n    g_hash_table_destroy(used1000);\n    free(a);\n    return 0;\n}", "llm": "cl-13b", "output": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <string.h>\n\ntypedef struct {\n    int *data;\n    size_t size;\n} vector;\n\ntypedef struct {\n    int *data;\n    size_t size;\n} set;\n\nvoid vector_init(vector *v, size_t size) {\n    v->data = malloc(size * sizeof(int));\n    v->size = size;\n}\n\nvoid vector_push_back(vector *v, int value) {\n    v->data[v->size++] = value;\n}\n\nint vector_get(vector *v, size_t index) {\n    return v->data[index];\n}\n\nvoid set_init(set *s, size_t size) {\n    s->data = malloc(size * sizeof(int));\n    s->size = size;\n}\n\nvoid set_insert(set *s, int value) {\n    s->data[s->size++] = value;\n}\n\nbool set_find(set *s, int value) {\n    for (size_t i = 0; i < s->size; i++) {\n        if (s->data[i] == value) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid print_vector(vector *v) {\n    printf(\"[\");\n    for (size_t i = 0; i < v->size; i++) {\n        if (i > 0) {\n            printf(\", \");\n        }\n        printf(\"%d\", v->data[i]);\n    }\n    printf(\"]\");\n}\n\nint main() {\n    vector a;\n    vector_init(&a, 1);\n    set used;\n    set_init(&used, 1);\n    set used1000;\n    set_init(&used1000, 1);\n    bool foundDup = false;\n    int n = 1;\n    while (n <= 15 || !foundDup || used1000.size < 1001) {\n        int next = a.data[n - 1] - n;\n        if (next < 1 || set_find(&used, next)) {\n            next += 2 * n;\n        }\n        bool alreadyUsed = set_find(&used, next);\n        vector_push_back(&a, next);\n        if (!alreadyUsed) {\n            set_insert(&used, next);\n            if (0 <= next && next <= 1000) {\n                set_insert(&used1000, next);\n            }\n        }\n        if (n == 14) {\n            printf(\"The first 15 terms of the Recaman sequence are: \");\n            print_vector(&a);\n            printf(\"\\n\");\n        }\n        if (!foundDup && alreadyUsed) {\n            printf(\"The first duplicated term is a[%d] = %d\\n\", n, next);\n            foundDup = true;\n        }\n        if (used1000.size == 1001) {\n            printf(\"Terms up to a[%d] are needed to generate 0 to 1000\\n\", n);\n        }\n        n++;\n    }\n\n    return 0;\n}", "index": 18}
{"lang": "C++, C", "input": "#include <iostream>\n#include <ostream>\n#include <set>\n#include <vector>\n\ntemplate<typename T>\nstd::ostream& operator<<(std::ostream& os, const std::vector<T>& v) {\n    auto i = v.cbegin();\n    auto e = v.cend();\n    os << '[';\n    if (i != e) {\n        os << *i;\n        i = std::next(i);\n    }\n    while (i != e) {\n        os << \", \" << *i;\n        i = std::next(i);\n    }\n    return os << ']';\n}\n\nint main() {\n    using namespace std;\n\n    vector<int> a{ 0 };\n    set<int> used{ 0 };\n    set<int> used1000{ 0 };\n    bool foundDup = false;\n    int n = 1;\n    while (n <= 15 || !foundDup || used1000.size() < 1001) {\n        int next = a[n - 1] - n;\n        if (next < 1 || used.find(next) != used.end()) {\n            next += 2 * n;\n        }\n        bool alreadyUsed = used.find(next) != used.end();\n        a.push_back(next);\n        if (!alreadyUsed) {\n            used.insert(next);\n            if (0 <= next && next <= 1000) {\n                used1000.insert(next);\n            }\n        }\n        if (n == 14) {\n            cout << \"The first 15 terms of the Recaman sequence are: \" << a << '\\n';\n        }\n        if (!foundDup && alreadyUsed) {\n            cout << \"The first duplicated term is a[\" << n << \"] = \" << next << '\\n';\n            foundDup = true;\n        }\n        if (used1000.size() == 1001) {\n            cout << \"Terms up to a[\" << n << \"] are needed to generate 0 to 1000\\n\";\n        }\n        n++;\n    }\n\n    return 0;\n}", "gold": "#include <stdio.h>\n#include <stdlib.h>\n#include <gmodule.h>\n\ntypedef int bool;\n\nint main() {\n    int i, n, k = 0, next, *a;\n    bool foundDup = FALSE;\n    gboolean alreadyUsed;\n    GHashTable* used = g_hash_table_new(g_direct_hash, g_direct_equal);\n    GHashTable* used1000 = g_hash_table_new(g_direct_hash, g_direct_equal);\n    a = malloc(400000 * sizeof(int));\n    a[0] = 0;\n    g_hash_table_add(used, GINT_TO_POINTER(0));\n    g_hash_table_add(used1000, GINT_TO_POINTER(0));\n\n    for (n = 1; n <= 15 || !foundDup || k < 1001; ++n) {\n        next = a[n - 1] - n;\n        if (next < 1 || g_hash_table_contains(used, GINT_TO_POINTER(next))) {\n            next += 2 * n;\n        }\n        alreadyUsed = g_hash_table_contains(used, GINT_TO_POINTER(next));\n        a[n] = next;\n\n        if (!alreadyUsed) {\n            g_hash_table_add(used, GINT_TO_POINTER(next));\n            if (next >= 0 && next <= 1000) {\n                g_hash_table_add(used1000, GINT_TO_POINTER(next));\n            }\n        }\n\n        if (n == 14) {\n            printf(\"The first 15 terms of the Recaman's sequence are: \");\n            printf(\"[\");\n            for (i = 0; i < 15; ++i) printf(\"%d \", a[i]);\n            printf(\"\\b]\\n\");\n        }\n\n        if (!foundDup && alreadyUsed) {\n            printf(\"The first duplicated term is a[%d] = %d\\n\", n, next);\n            foundDup = TRUE;\n        }\n        k = g_hash_table_size(used1000);\n\n        if (k == 1001) {\n            printf(\"Terms up to a[%d] are needed to generate 0 to 1000\\n\", n);\n        }\n    }\n    g_hash_table_destroy(used);\n    g_hash_table_destroy(used1000);\n    free(a);\n    return 0;\n}", "llm": "dsc-7b", "output": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX_SIZE 1000\n\nint main() {\n    int a[MAX_SIZE];\n    bool used[MAX_SIZE + 1];\n    bool used1000[MAX_SIZE + 1];\n    bool foundDup = false;\n    int n = 1;\n    int i;\n\n    a[0] = 0;\n    for (i = 0; i <= MAX_SIZE; i++) {\n        used[i] = false;\n        used1000[i] = false;\n    }\n    used[0] = true;\n    used1000[0] = true;\n\n    while (n <= MAX_SIZE || !foundDup || used1000[MAX_SIZE]) {\n        int next = a[n - 1] - n;\n        if (next < 1 || used[next]) {\n            next += 2 * n;\n        }\n        bool alreadyUsed = used[next];\n        a[n] = next;\n        if (!alreadyUsed) {\n            used[next] = true;\n            if (0 <= next && next <= MAX_SIZE) {\n                used1000[next] = true;\n            }\n        }\n        if (n == MAX_SIZE - 1) {\n            printf(\"The first %d terms of the Recaman sequence are: [\", MAX_SIZE);\n            for (i = 0; i < MAX_SIZE; i++) {\n                printf(\"%d, \", a[i]);\n            }\n            printf(\"%d]\\n\", a[MAX_SIZE]);\n        }\n        if (!foundDup && alreadyUsed) {\n            printf(\"The first duplicated term is a[%d] = %d\\n\", n, next);\n            foundDup = true;\n        }\n        if (used1000[MAX_SIZE]) {\n            printf(\"Terms up to a[%d] are needed to generate 0 to %d\\n\", n, MAX_SIZE);\n        }\n        n++;\n    }\n\n    return 0;\n}", "index": 19}
{"lang": "C++, C", "input": "#include <iostream>\n#include <ostream>\n#include <set>\n#include <vector>\n\ntemplate<typename T>\nstd::ostream& operator<<(std::ostream& os, const std::vector<T>& v) {\n    auto i = v.cbegin();\n    auto e = v.cend();\n    os << '[';\n    if (i != e) {\n        os << *i;\n        i = std::next(i);\n    }\n    while (i != e) {\n        os << \", \" << *i;\n        i = std::next(i);\n    }\n    return os << ']';\n}\n\nint main() {\n    using namespace std;\n\n    vector<int> a{ 0 };\n    set<int> used{ 0 };\n    set<int> used1000{ 0 };\n    bool foundDup = false;\n    int n = 1;\n    while (n <= 15 || !foundDup || used1000.size() < 1001) {\n        int next = a[n - 1] - n;\n        if (next < 1 || used.find(next) != used.end()) {\n            next += 2 * n;\n        }\n        bool alreadyUsed = used.find(next) != used.end();\n        a.push_back(next);\n        if (!alreadyUsed) {\n            used.insert(next);\n            if (0 <= next && next <= 1000) {\n                used1000.insert(next);\n            }\n        }\n        if (n == 14) {\n            cout << \"The first 15 terms of the Recaman sequence are: \" << a << '\\n';\n        }\n        if (!foundDup && alreadyUsed) {\n            cout << \"The first duplicated term is a[\" << n << \"] = \" << next << '\\n';\n            foundDup = true;\n        }\n        if (used1000.size() == 1001) {\n            cout << \"Terms up to a[\" << n << \"] are needed to generate 0 to 1000\\n\";\n        }\n        n++;\n    }\n\n    return 0;\n}", "gold": "#include <stdio.h>\n#include <stdlib.h>\n#include <gmodule.h>\n\ntypedef int bool;\n\nint main() {\n    int i, n, k = 0, next, *a;\n    bool foundDup = FALSE;\n    gboolean alreadyUsed;\n    GHashTable* used = g_hash_table_new(g_direct_hash, g_direct_equal);\n    GHashTable* used1000 = g_hash_table_new(g_direct_hash, g_direct_equal);\n    a = malloc(400000 * sizeof(int));\n    a[0] = 0;\n    g_hash_table_add(used, GINT_TO_POINTER(0));\n    g_hash_table_add(used1000, GINT_TO_POINTER(0));\n\n    for (n = 1; n <= 15 || !foundDup || k < 1001; ++n) {\n        next = a[n - 1] - n;\n        if (next < 1 || g_hash_table_contains(used, GINT_TO_POINTER(next))) {\n            next += 2 * n;\n        }\n        alreadyUsed = g_hash_table_contains(used, GINT_TO_POINTER(next));\n        a[n] = next;\n\n        if (!alreadyUsed) {\n            g_hash_table_add(used, GINT_TO_POINTER(next));\n            if (next >= 0 && next <= 1000) {\n                g_hash_table_add(used1000, GINT_TO_POINTER(next));\n            }\n        }\n\n        if (n == 14) {\n            printf(\"The first 15 terms of the Recaman's sequence are: \");\n            printf(\"[\");\n            for (i = 0; i < 15; ++i) printf(\"%d \", a[i]);\n            printf(\"\\b]\\n\");\n        }\n\n        if (!foundDup && alreadyUsed) {\n            printf(\"The first duplicated term is a[%d] = %d\\n\", n, next);\n            foundDup = TRUE;\n        }\n        k = g_hash_table_size(used1000);\n\n        if (k == 1001) {\n            printf(\"Terms up to a[%d] are needed to generate 0 to 1000\\n\", n);\n        }\n    }\n    g_hash_table_destroy(used);\n    g_hash_table_destroy(used1000);\n    free(a);\n    return 0;\n}", "llm": "q2.5-7b", "output": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct {\n    int *data;\n    size_t size;\n    size_t capacity;\n} Vector;\n\ntypedef struct {\n    int *data;\n    size_t size;\n} Set;\n\nvoid vector_init(Vector *v, size_t capacity) {\n    v->data = (int *)malloc(capacity * sizeof(int));\n    v->size = 0;\n    v->capacity = capacity;\n}\n\nvoid vector_push_back(Vector *v, int value) {\n    if (v->size == v->capacity) {\n        v->capacity *= 2;\n        v->data = (int *)realloc(v->data, v->capacity * sizeof(int));\n    }\n    v->data[v->size++] = value;\n}\n\nvoid set_init(Set *s) {\n    s->data = NULL;\n    s->size = 0;\n}\n\nvoid set_insert(Set *s, int value) {\n    for (size_t i = 0; i < s->size; i++) {\n        if (s->data[i] == value) {\n            return;\n        }\n    }\n    s->data = (int *)realloc(s->data, (s->size + 1) * sizeof(int));\n    s->data[s->size++] = value;\n}\n\nbool set_contains(Set *s, int value) {\n    for (size_t i = 0; i < s->size; i++) {\n        if (s->data[i] == value) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid print_vector(Vector *v) {\n    printf(\"[\");\n    for (size_t i = 0; i < v->size; i++) {\n        if (i != 0) {\n            printf(\", \");\n        }\n        printf(\"%d\", v->data[i]);\n    }\n    printf(\"]\\n\");\n}\n\nint main() {\n    Vector a;\n    Set used;\n    Set used1000;\n    bool foundDup = false;\n    int n = 1;\n    vector_init(&a, 1);\n    set_init(&used);\n    set_init(&used1000);\n\n    while (n <= 15 || !foundDup || used1000.size < 1001) {\n        int next = a.data[n - 1] - n;\n        if (next < 1 || set_contains(&used, next)) {\n            next += 2 * n;\n        }\n        bool alreadyUsed = set_contains(&used, next);\n        vector_push_back(&a, next);\n        if (!alreadyUsed) {\n            set_insert(&used, next);\n            if (0 <= next && next <= 1000) {\n                set_insert(&used1000, next);\n            }\n        }\n        if (n == 14) {\n            print_vector(&a);\n        }\n        if (!foundDup && alreadyUsed) {\n            printf(\"The first duplicated term is a[%d] = %d\\n\", n, next);\n            foundDup = true;\n        }\n        if (used1000.size == 1001) {\n            printf(\"Terms up to a[%d] are needed to generate 0 to 1000\\n\", n);\n        }\n        n++;\n    }\n\n    free(a.data);\n    free(used.data);\n    free(used1000.data);\n\n    return 0;\n}", "index": 20}
{"lang": "C++, C", "input": "#include <iostream>\n#include <string>\n#include <random>\n \nint main()\n{\n    std::random_device rd;\n    std::uniform_int_distribution<int> dist(1, 10);\n    std::mt19937 mt(rd());\n    \n    std::cout << \"Random Number (hardware): \" << dist(rd) << std::endl;\n    std::cout << \"Mersenne twister (hardware seeded): \" << dist(mt) << std::endl;\n}", "gold": "#include <stdio.h>\n#include <stdlib.h>\n\n\nint\nmain()\n{\n\tint i;\n\tsrand(time(NULL));\n\tfor (i = 0; i < 10; i++)\n\t\tputs((rand() % 2) ? \"heads\" : \"tails\");\n\treturn 0;\n}", "llm": "cl-34b", "output": "#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nint main()\n{\n    srand(time(NULL));\n    int dist = rand() % 10 + 1;\n    printf(\"Random Number (hardware): %d\\n\", dist);\n    printf(\"Mersenne twister (hardware seeded): %d\\n\", dist);\n    return 0;\n}", "index": 21}
{"lang": "C++, C", "input": "#include <iostream>\n#include <string>\n#include <random>\n \nint main()\n{\n    std::random_device rd;\n    std::uniform_int_distribution<int> dist(1, 10);\n    std::mt19937 mt(rd());\n    \n    std::cout << \"Random Number (hardware): \" << dist(rd) << std::endl;\n    std::cout << \"Mersenne twister (hardware seeded): \" << dist(mt) << std::endl;\n}", "gold": "#include <stdio.h>\n#include <stdlib.h>\n\n\nint\nmain()\n{\n\tint i;\n\tsrand(time(NULL));\n\tfor (i = 0; i < 10; i++)\n\t\tputs((rand() % 2) ? \"heads\" : \"tails\");\n\treturn 0;\n}", "llm": "cs-22b", "output": "#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nint main()\n{\n    srand(time(0));\n    int random_number = (rand() % 10) + 1;\n    printf(\"Random Number (hardware): %d\\n\", random_number);\n\n    srand(time(0));\n    int mersenne_twister = (rand() % 10) + 1;\n    printf(\"Mersenne twister (hardware seeded): %d\\n\", mersenne_twister);\n\n    return 0;\n}", "index": 22}
{"lang": "C++, C", "input": "#include <iostream>\n#include <string>\n#include <random>\n \nint main()\n{\n    std::random_device rd;\n    std::uniform_int_distribution<int> dist(1, 10);\n    std::mt19937 mt(rd());\n    \n    std::cout << \"Random Number (hardware): \" << dist(rd) << std::endl;\n    std::cout << \"Mersenne twister (hardware seeded): \" << dist(mt) << std::endl;\n}", "gold": "#include <stdio.h>\n#include <stdlib.h>\n\n\nint\nmain()\n{\n\tint i;\n\tsrand(time(NULL));\n\tfor (i = 0; i < 10; i++)\n\t\tputs((rand() % 2) ? \"heads\" : \"tails\");\n\treturn 0;\n}", "llm": "cg4-9b", "output": "#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nint main()\n{\n    srand(time(NULL));\n    \n    printf(\"Random Number (hardware): %d\\n\", rand() % 10 + 1);\n    printf(\"Mersenne twister (hardware seeded): %d\\n\", rand() % 10 + 1);\n}", "index": 23}
{"lang": "C++, Python", "input": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n\ntemplate <typename T>\nauto operator>>(const vector<T>& monad, auto f)\n{\n    \n    vector<remove_reference_t<decltype(f(monad.front()).front())>> result;\n    for(auto& item : monad)\n    {\n        \n        \n        const auto r = f(item);\n        \n        result.insert(result.end(), begin(r), end(r));\n    }\n    \n    return result;\n}\n\n\nauto Pure(auto t)\n{\n    return vector{t};\n}\n\n\nauto Double(int i)\n{\n    return Pure(2 * i);\n}\n\n\nauto Increment(int i)\n{\n    return Pure(i + 1);\n}\n\n\nauto NiceNumber(int i)\n{\n    return Pure(to_string(i) + \" is a nice number\\n\");\n}\n\n\n\nauto UpperSequence = [](auto startingVal)\n{\n    const int MaxValue = 500;\n    vector<decltype(startingVal)> sequence;\n    while(startingVal <= MaxValue) \n        sequence.push_back(startingVal++);\n    return sequence;\n};\n\n\nvoid PrintVector(const auto& vec)\n{\n    cout << \" \";\n    for(auto value : vec)\n    {\n        cout << value << \" \";\n    }\n    cout << \"\\n\";\n}\n\n\nvoid PrintTriples(const auto& vec)\n{\n    cout << \"Pythagorean triples:\\n\";\n    for(auto it = vec.begin(); it != vec.end();)\n    {\n        auto x = *it++;\n        auto y = *it++;\n        auto z = *it++;\n        \n        cout << x << \", \" << y << \", \" << z << \"\\n\";\n    }\n    cout << \"\\n\";\n}\n\nint main()\n{\n    \n    auto listMonad = \n        vector<int> {2, 3, 4} >> \n        Increment >> \n        Double >>\n        NiceNumber;\n        \n    PrintVector(listMonad);\n    \n    \n    \n    \n    \n    auto pythagoreanTriples = UpperSequence(1) >> \n        [](int x){return UpperSequence(x) >>\n        [x](int y){return UpperSequence(y) >>\n        [x, y](int z){return (x*x + y*y == z*z) ? vector{x, y, z} : vector<int>{};};};};\n    \n    PrintTriples(pythagoreanTriples);\n}", "gold": "from __future__ import annotations\nfrom itertools import chain\n\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Iterable\nfrom typing import List\nfrom typing import TypeVar\n\n\nT = TypeVar(\"T\")\n\n\nclass MList(List[T]):\n    @classmethod\n    def unit(cls, value: Iterable[T]) -> MList[T]:\n        return cls(value)\n\n    def bind(self, func: Callable[[T], MList[Any]]) -> MList[Any]:\n        return MList(chain.from_iterable(map(func, self)))\n\n    def __rshift__(self, func: Callable[[T], MList[Any]]) -> MList[Any]:\n        return self.bind(func)\n\n\nif __name__ == \"__main__\":\n    \n    print(\n        MList([1, 99, 4])\n        .bind(lambda val: MList([val + 1]))\n        .bind(lambda val: MList([f\"${val}.00\"]))\n    )\n\n    \n    print(\n        MList([1, 99, 4])\n        >> (lambda val: MList([val + 1]))\n        >> (lambda val: MList([f\"${val}.00\"]))\n    )\n\n    \n    print(\n        MList(range(1, 6)).bind(\n            lambda x: MList(range(6, 11)).bind(lambda y: MList([(x, y)]))\n        )\n    )\n\n    \n    print(\n        MList(range(1, 26)).bind(\n            lambda x: MList(range(x + 1, 26)).bind(\n                lambda y: MList(range(y + 1, 26)).bind(\n                    lambda z: MList([(x, y, z)])\n                    if x * x + y * y == z * z\n                    else MList([])\n                )\n            )\n        )\n    )", "llm": "cl-13b", "output": "import io\nimport itertools\n\ndef operator_gt(monad, f):\n    result = []\n    for item in monad:\n        r = f(item)\n        result.extend(r)\n    return result\n\ndef pure(t):\n    return [t]\n\ndef double(i):\n    return pure(2 * i)\n\ndef increment(i):\n    return pure(i + 1)\n\ndef nice_number(i):\n    return pure(str(i) + \" is a nice number\\n\")\n\ndef upper_sequence(starting_val):\n    max_value = 500\n    sequence = []\n    while starting_val <= max_value:\n        sequence.append(starting_val)\n        starting_val += 1\n    return sequence\n\ndef print_vector(vec):\n    print(\" \", end=\"\")\n    for value in vec:\n        print(value, end=\" \")\n    print()\n\ndef print_triples(vec):\n    print(\"Pythagorean triples:\")\n    for it in itertools.islice(vec, 3):\n        x, y, z = it\n        print(x, y, z)\n    print()\n\nlist_monad = [2, 3, 4] >> increment >> double >> nice_number\nprint_vector(list_monad)\n\npythagorean_triples = upper_sequence(1) >> (lambda x: upper_sequence(x) >> (lambda y: upper_sequence(y) >> (lambda z: (x*x + y*y == z*z) and [x, y, z] or [])))\nprint_triples(pythagorean_triples)", "index": 24}
{"lang": "C++, Python", "input": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n\ntemplate <typename T>\nauto operator>>(const vector<T>& monad, auto f)\n{\n    \n    vector<remove_reference_t<decltype(f(monad.front()).front())>> result;\n    for(auto& item : monad)\n    {\n        \n        \n        const auto r = f(item);\n        \n        result.insert(result.end(), begin(r), end(r));\n    }\n    \n    return result;\n}\n\n\nauto Pure(auto t)\n{\n    return vector{t};\n}\n\n\nauto Double(int i)\n{\n    return Pure(2 * i);\n}\n\n\nauto Increment(int i)\n{\n    return Pure(i + 1);\n}\n\n\nauto NiceNumber(int i)\n{\n    return Pure(to_string(i) + \" is a nice number\\n\");\n}\n\n\n\nauto UpperSequence = [](auto startingVal)\n{\n    const int MaxValue = 500;\n    vector<decltype(startingVal)> sequence;\n    while(startingVal <= MaxValue) \n        sequence.push_back(startingVal++);\n    return sequence;\n};\n\n\nvoid PrintVector(const auto& vec)\n{\n    cout << \" \";\n    for(auto value : vec)\n    {\n        cout << value << \" \";\n    }\n    cout << \"\\n\";\n}\n\n\nvoid PrintTriples(const auto& vec)\n{\n    cout << \"Pythagorean triples:\\n\";\n    for(auto it = vec.begin(); it != vec.end();)\n    {\n        auto x = *it++;\n        auto y = *it++;\n        auto z = *it++;\n        \n        cout << x << \", \" << y << \", \" << z << \"\\n\";\n    }\n    cout << \"\\n\";\n}\n\nint main()\n{\n    \n    auto listMonad = \n        vector<int> {2, 3, 4} >> \n        Increment >> \n        Double >>\n        NiceNumber;\n        \n    PrintVector(listMonad);\n    \n    \n    \n    \n    \n    auto pythagoreanTriples = UpperSequence(1) >> \n        [](int x){return UpperSequence(x) >>\n        [x](int y){return UpperSequence(y) >>\n        [x, y](int z){return (x*x + y*y == z*z) ? vector{x, y, z} : vector<int>{};};};};\n    \n    PrintTriples(pythagoreanTriples);\n}", "gold": "from __future__ import annotations\nfrom itertools import chain\n\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Iterable\nfrom typing import List\nfrom typing import TypeVar\n\n\nT = TypeVar(\"T\")\n\n\nclass MList(List[T]):\n    @classmethod\n    def unit(cls, value: Iterable[T]) -> MList[T]:\n        return cls(value)\n\n    def bind(self, func: Callable[[T], MList[Any]]) -> MList[Any]:\n        return MList(chain.from_iterable(map(func, self)))\n\n    def __rshift__(self, func: Callable[[T], MList[Any]]) -> MList[Any]:\n        return self.bind(func)\n\n\nif __name__ == \"__main__\":\n    \n    print(\n        MList([1, 99, 4])\n        .bind(lambda val: MList([val + 1]))\n        .bind(lambda val: MList([f\"${val}.00\"]))\n    )\n\n    \n    print(\n        MList([1, 99, 4])\n        >> (lambda val: MList([val + 1]))\n        >> (lambda val: MList([f\"${val}.00\"]))\n    )\n\n    \n    print(\n        MList(range(1, 6)).bind(\n            lambda x: MList(range(6, 11)).bind(lambda y: MList([(x, y)]))\n        )\n    )\n\n    \n    print(\n        MList(range(1, 26)).bind(\n            lambda x: MList(range(x + 1, 26)).bind(\n                lambda y: MList(range(y + 1, 26)).bind(\n                    lambda z: MList([(x, y, z)])\n                    if x * x + y * y == z * z\n                    else MList([])\n                )\n            )\n        )\n    )", "llm": "q2.5-1.5b", "output": "import typing\n\ndef operator_rshift(monad: typing.List[int], f: typing.Callable[[int], typing.List[int]]) -> typing.List[int]:\n    result = []\n    for item in monad:\n        r = f(item)\n        result.extend(r)\n    return result\n\ndef Pure(t: int) -> typing.List[int]:\n    return [t]\n\ndef Double(i: int) -> typing.List[int]:\n    return [2 * i]\n\ndef Increment(i: int) -> typing.List[int]:\n    return [i + 1]\n\ndef NiceNumber(i: int) -> typing.List[int]:\n    return [f\"{i} is a nice number\\n\"]\n\ndef UpperSequence(startingVal: int) -> typing.List[int]:\n    MaxValue = 500\n    sequence = []\n    while startingVal <= MaxValue:\n        sequence.append(startingVal)\n        startingVal += 1\n    return sequence\n\ndef PrintVector(vec: typing.List[int]) -> None:\n    print(\" \", end=\"\")\n    for value in vec:\n        print(value, end=\" \")\n    print(\"\\n\")\n\ndef PrintTriples(vec: typing.List[int]) -> None:\n    print(\"Pythagorean triples:\\n\")\n    for it in vec:\n        x = it[0]\n        y = it[1]\n        z = it[2]\n        print(f\"{x}, {y}, {z}\\n\")\n    print(\"\\n\")\n\nif __name__ == \"__main__\":\n    listMonad = operator_rshift([2, 3, 4], Increment) >> operator_rshift([2, 3, 4], Double) >> operator_rshift([2, 3, 4], NiceNumber)\n    PrintVector(listMonad)\n    \n    pythagoreanTriples = operator_rshift(UpperSequence(1), lambda x: operator_rshift(UpperSequence(x), lambda y: operator_rshift(UpperSequence(y), lambda z: [x, y, z] if x*x + y*y == z*z else [])))\n    PrintTriples(pythagoreanTriples)", "index": 25}
{"lang": "C++, Python", "input": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n\ntemplate <typename T>\nauto operator>>(const vector<T>& monad, auto f)\n{\n    \n    vector<remove_reference_t<decltype(f(monad.front()).front())>> result;\n    for(auto& item : monad)\n    {\n        \n        \n        const auto r = f(item);\n        \n        result.insert(result.end(), begin(r), end(r));\n    }\n    \n    return result;\n}\n\n\nauto Pure(auto t)\n{\n    return vector{t};\n}\n\n\nauto Double(int i)\n{\n    return Pure(2 * i);\n}\n\n\nauto Increment(int i)\n{\n    return Pure(i + 1);\n}\n\n\nauto NiceNumber(int i)\n{\n    return Pure(to_string(i) + \" is a nice number\\n\");\n}\n\n\n\nauto UpperSequence = [](auto startingVal)\n{\n    const int MaxValue = 500;\n    vector<decltype(startingVal)> sequence;\n    while(startingVal <= MaxValue) \n        sequence.push_back(startingVal++);\n    return sequence;\n};\n\n\nvoid PrintVector(const auto& vec)\n{\n    cout << \" \";\n    for(auto value : vec)\n    {\n        cout << value << \" \";\n    }\n    cout << \"\\n\";\n}\n\n\nvoid PrintTriples(const auto& vec)\n{\n    cout << \"Pythagorean triples:\\n\";\n    for(auto it = vec.begin(); it != vec.end();)\n    {\n        auto x = *it++;\n        auto y = *it++;\n        auto z = *it++;\n        \n        cout << x << \", \" << y << \", \" << z << \"\\n\";\n    }\n    cout << \"\\n\";\n}\n\nint main()\n{\n    \n    auto listMonad = \n        vector<int> {2, 3, 4} >> \n        Increment >> \n        Double >>\n        NiceNumber;\n        \n    PrintVector(listMonad);\n    \n    \n    \n    \n    \n    auto pythagoreanTriples = UpperSequence(1) >> \n        [](int x){return UpperSequence(x) >>\n        [x](int y){return UpperSequence(y) >>\n        [x, y](int z){return (x*x + y*y == z*z) ? vector{x, y, z} : vector<int>{};};};};\n    \n    PrintTriples(pythagoreanTriples);\n}", "gold": "from __future__ import annotations\nfrom itertools import chain\n\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Iterable\nfrom typing import List\nfrom typing import TypeVar\n\n\nT = TypeVar(\"T\")\n\n\nclass MList(List[T]):\n    @classmethod\n    def unit(cls, value: Iterable[T]) -> MList[T]:\n        return cls(value)\n\n    def bind(self, func: Callable[[T], MList[Any]]) -> MList[Any]:\n        return MList(chain.from_iterable(map(func, self)))\n\n    def __rshift__(self, func: Callable[[T], MList[Any]]) -> MList[Any]:\n        return self.bind(func)\n\n\nif __name__ == \"__main__\":\n    \n    print(\n        MList([1, 99, 4])\n        .bind(lambda val: MList([val + 1]))\n        .bind(lambda val: MList([f\"${val}.00\"]))\n    )\n\n    \n    print(\n        MList([1, 99, 4])\n        >> (lambda val: MList([val + 1]))\n        >> (lambda val: MList([f\"${val}.00\"]))\n    )\n\n    \n    print(\n        MList(range(1, 6)).bind(\n            lambda x: MList(range(6, 11)).bind(lambda y: MList([(x, y)]))\n        )\n    )\n\n    \n    print(\n        MList(range(1, 26)).bind(\n            lambda x: MList(range(x + 1, 26)).bind(\n                lambda y: MList(range(y + 1, 26)).bind(\n                    lambda z: MList([(x, y, z)])\n                    if x * x + y * y == z * z\n                    else MList([])\n                )\n            )\n        )\n    )", "llm": "cg4-9b", "output": "from typing import List, Callable, Any\n\nclass Monad:\n    def __init__(self, value: Any):\n        self.value = value\n\n    def __rshift__(self, other: Callable[[Any], 'Monad']) -> 'Monad':\n        return other(self.value)\n\ndef pure(t: Any) -> Monad:\n    return Monad(t)\n\ndef double(i: int) -> Monad:\n    return pure(2 * i)\n\ndef increment(i: int) -> Monad:\n    return pure(i + 1)\n\ndef nice_number(i: int) -> Monad:\n    return pure(str(i) + \" is a nice number\\n\")\n\ndef upper_sequence(starting_val: int) -> List[int]:\n    max_value = 500\n    sequence = []\n    while starting_val <= max_value:\n        sequence.append(starting_val)\n        starting_val += 1\n    return sequence\n\ndef print_vector(vec: List[Any]) -> None:\n    print(\" \", *vec, sep=\" \", end=\"\\n\")\n\ndef print_triples(vec: List[int]) -> None:\n    print(\"Pythagorean triples:\")\n    for i in range(0, len(vec), 3):\n        x, y, z = vec[i:i+3]\n        print(x, y, z)\n\nif __name__ == \"__main__\":\n    list_monad = Monad([2, 3, 4]) >> increment >> double >> nice_number\n    print_vector(list_monad.value)\n\n    pythagorean_triples = Monad(1) >> \\\n        lambda x: Monad(upper_sequence(x)) >> \\\n        lambda y: Monad(upper_sequence(y)) >> \\\n        lambda z: Monad([x, y, z] if x*x + y*y == z*z else []) >> \\\n        lambda triples: Monad(triples)\n    print_triples(pythagorean_triples.value)", "index": 26}
{"lang": "C++, C", "input": "#include <iostream>\nusing namespace std;\n\nbool steady(int n) {\n    int mask = 1;\n    for (int d = n; d != 0; d /= 10) \n        mask *= 10;\n    return (n * n) % mask == n;\n}\n \nint main() {\n    for (int i = 1; i < 10000; i++)\n        if (steady(i)) printf(\"%4d^2 = %8d\\n\", i, i * i);\n}", "gold": "#include <stdio.h>\n#include <stdbool.h>\n \nbool steady(int n)\n{\n    int mask = 1;\n    for (int d = n; d != 0; d /= 10) \n        mask *= 10;\n    return (n * n) % mask == n;\n}\n \nint main()\n{\n    for (int i = 1; i < 10000; i++)\n        if (steady(i))\n            printf(\"%4d^2 = %8d\\n\", i, i * i);\n    return 0;\n}", "llm": "cl-13b", "output": "#include <stdio.h>\n\nbool steady(int n) {\n    int mask = 1;\n    for (int d = n; d != 0; d /= 10) \n        mask *= 10;\n    return (n * n) % mask == n;\n}\n \nint main() {\n    for (int i = 1; i < 10000; i++)\n        if (steady(i)) printf(\"%4d^2 = %8d\\n\", i, i * i);\n}", "index": 27}
{"lang": "C++, C", "input": "#include <iostream>\nusing namespace std;\n\nbool steady(int n) {\n    int mask = 1;\n    for (int d = n; d != 0; d /= 10) \n        mask *= 10;\n    return (n * n) % mask == n;\n}\n \nint main() {\n    for (int i = 1; i < 10000; i++)\n        if (steady(i)) printf(\"%4d^2 = %8d\\n\", i, i * i);\n}", "gold": "#include <stdio.h>\n#include <stdbool.h>\n \nbool steady(int n)\n{\n    int mask = 1;\n    for (int d = n; d != 0; d /= 10) \n        mask *= 10;\n    return (n * n) % mask == n;\n}\n \nint main()\n{\n    for (int i = 1; i < 10000; i++)\n        if (steady(i))\n            printf(\"%4d^2 = %8d\\n\", i, i * i);\n    return 0;\n}", "llm": "dsc2-16b", "output": "#include <stdio.h>\n#include <stdbool.h>\n\nbool steady(int n) {\n    int mask = 1;\n    for (int d = n; d != 0; d /= 10) \n        mask *= 10;\n    return (n * n) % mask == n;\n}\n\nint main() {\n    for (int i = 1; i < 10000; i++)\n        if (steady(i)) printf(\"%4d^2 = %8d\\n\", i, i * i);\n}", "index": 28}
{"lang": "C++, C", "input": "#include <iostream>\nusing namespace std;\n\nbool steady(int n) {\n    int mask = 1;\n    for (int d = n; d != 0; d /= 10) \n        mask *= 10;\n    return (n * n) % mask == n;\n}\n \nint main() {\n    for (int i = 1; i < 10000; i++)\n        if (steady(i)) printf(\"%4d^2 = %8d\\n\", i, i * i);\n}", "gold": "#include <stdio.h>\n#include <stdbool.h>\n \nbool steady(int n)\n{\n    int mask = 1;\n    for (int d = n; d != 0; d /= 10) \n        mask *= 10;\n    return (n * n) % mask == n;\n}\n \nint main()\n{\n    for (int i = 1; i < 10000; i++)\n        if (steady(i))\n            printf(\"%4d^2 = %8d\\n\", i, i * i);\n    return 0;\n}", "llm": "cs-22b", "output": "#include <stdio.h>\n#include <stdbool.h>\n\nbool steady(int n) {\n    int mask = 1;\n    for (int d = n; d != 0; d /= 10)\n        mask *= 10;\n    return (n * n) % mask == n;\n}\n\nint main() {\n    for (int i = 1; i < 10000; i++)\n        if (steady(i)) printf(\"%4d^2 = %8d\\n\", i, i * i);\n    return 0;\n}", "index": 29}
{"lang": "C, Java", "input": "#include <math.h>\n#include <stdio.h>\n\n#define DEG 0.017453292519943295769236907684886127134  \n#define RE 6371000.0 \n#define DD 0.001 \n#define FIN 10000000.0 \n\nstatic double rho(double a) {\n    \n    return exp(-a / 8500.0);\n}\n\nstatic double height(double a, double z, double d) {\n    \n    \n    \n    double aa = RE + a;\n    double hh = sqrt(aa * aa + d * d - 2.0 * d * aa * cos((180 - z) * DEG));\n    return hh - RE;\n}\n\nstatic double column_density(double a, double z) {\n    \n    double sum = 0.0, d = 0.0;\n    while (d < FIN) {\n        \n        double delta = DD * d;\n        if (delta < DD)\n            delta = DD;\n        sum += rho(height(a, z, d + 0.5 * delta)) * delta;\n        d += delta;\n    }\n    return sum;\n}\n\nstatic double airmass(double a, double z) {\n    return column_density(a, z) / column_density(a, 0.0);\n}\n\nint main() {\n    puts(\"Angle     0 m              13700 m\");\n    puts(\"------------------------------------\");\n    for (double z = 0; z <= 90; z+= 5) {\n        printf(\"%2.0f      %11.8f      %11.8f\\n\",\n               z, airmass(0.0, z), airmass(13700.0, z));\n    }\n}", "gold": "public class AirMass {\n    public static void main(String[] args) {\n        System.out.println(\"Angle     0 m              13700 m\");\n        System.out.println(\"------------------------------------\");\n        for (double z = 0; z <= 90; z+= 5) {\n            System.out.printf(\"%2.0f      %11.8f      %11.8f\\n\",\n                            z, airmass(0.0, z), airmass(13700.0, z));\n        }\n    }\n\n    private static double rho(double a) {\n        \n        return Math.exp(-a / 8500.0);\n    }\n\n    private static double height(double a, double z, double d) {\n        \n        \n        \n        double aa = RE + a;\n        double hh = Math.sqrt(aa * aa + d * d - 2.0 * d * aa * Math.cos(Math.toRadians(180 - z)));\n        return hh - RE;\n    }\n\n    private static double columnDensity(double a, double z) {\n        \n        double sum = 0.0, d = 0.0;\n        while (d < FIN) {\n            \n            double delta = Math.max(DD * d, DD);\n            sum += rho(height(a, z, d + 0.5 * delta)) * delta;\n            d += delta;\n        }\n        return sum;\n    }\n     \n    private static double airmass(double a, double z) {\n        return columnDensity(a, z) / columnDensity(a, 0.0);\n    }\n\n    private static final double RE = 6371000.0; \n    private static final double DD = 0.001; \n    private static final double FIN = 10000000.0; \n}", "llm": "cl-7b", "output": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"Angle     0 m              13700 m\");\n        System.out.println(\"------------------------------------\");\n        for (double z = 0; z <= 90; z += 5) {\n            System.out.printf(\"%2.0f      %11.8f      %11.8f\\n\", z, airmass(0.0, z), airmass(13700.0, z));\n        }\n    }\n\n    private static double rho(double a) {\n        return Math.exp(-a / 8500.0);\n    }\n\n    private static double height(double a, double z, double d) {\n        double aa = RE + a;\n        double hh = Math.sqrt(aa * aa + d * d - 2.0 * d * aa * Math.cos((180 - z) * DEG));\n        return hh - RE;\n    }\n\n    private static double column_density(double a, double z) {\n        double sum = 0.0, d = 0.0;\n        while (d < FIN) {\n            double delta = DD * d;\n            if (delta < DD)\n                delta = DD;\n            sum += rho(height(a, z, d + 0.5 * delta)) * delta;\n            d += delta;\n        }\n        return sum;\n    }\n\n    private static double airmass(double a, double z) {\n        return column_density(a, z) / column_density(a, 0.0);\n    }\n}", "index": 30}
{"lang": "C, Java", "input": "#include <math.h>\n#include <stdio.h>\n\n#define DEG 0.017453292519943295769236907684886127134  \n#define RE 6371000.0 \n#define DD 0.001 \n#define FIN 10000000.0 \n\nstatic double rho(double a) {\n    \n    return exp(-a / 8500.0);\n}\n\nstatic double height(double a, double z, double d) {\n    \n    \n    \n    double aa = RE + a;\n    double hh = sqrt(aa * aa + d * d - 2.0 * d * aa * cos((180 - z) * DEG));\n    return hh - RE;\n}\n\nstatic double column_density(double a, double z) {\n    \n    double sum = 0.0, d = 0.0;\n    while (d < FIN) {\n        \n        double delta = DD * d;\n        if (delta < DD)\n            delta = DD;\n        sum += rho(height(a, z, d + 0.5 * delta)) * delta;\n        d += delta;\n    }\n    return sum;\n}\n\nstatic double airmass(double a, double z) {\n    return column_density(a, z) / column_density(a, 0.0);\n}\n\nint main() {\n    puts(\"Angle     0 m              13700 m\");\n    puts(\"------------------------------------\");\n    for (double z = 0; z <= 90; z+= 5) {\n        printf(\"%2.0f      %11.8f      %11.8f\\n\",\n               z, airmass(0.0, z), airmass(13700.0, z));\n    }\n}", "gold": "public class AirMass {\n    public static void main(String[] args) {\n        System.out.println(\"Angle     0 m              13700 m\");\n        System.out.println(\"------------------------------------\");\n        for (double z = 0; z <= 90; z+= 5) {\n            System.out.printf(\"%2.0f      %11.8f      %11.8f\\n\",\n                            z, airmass(0.0, z), airmass(13700.0, z));\n        }\n    }\n\n    private static double rho(double a) {\n        \n        return Math.exp(-a / 8500.0);\n    }\n\n    private static double height(double a, double z, double d) {\n        \n        \n        \n        double aa = RE + a;\n        double hh = Math.sqrt(aa * aa + d * d - 2.0 * d * aa * Math.cos(Math.toRadians(180 - z)));\n        return hh - RE;\n    }\n\n    private static double columnDensity(double a, double z) {\n        \n        double sum = 0.0, d = 0.0;\n        while (d < FIN) {\n            \n            double delta = Math.max(DD * d, DD);\n            sum += rho(height(a, z, d + 0.5 * delta)) * delta;\n            d += delta;\n        }\n        return sum;\n    }\n     \n    private static double airmass(double a, double z) {\n        return columnDensity(a, z) / columnDensity(a, 0.0);\n    }\n\n    private static final double RE = 6371000.0; \n    private static final double DD = 0.001; \n    private static final double FIN = 10000000.0; \n}", "llm": "q2.5-7b", "output": "public class Main {\n    private static final double DEG = 0.017453292519943295769236907684886127134;\n    private static final double RE = 6371000.0;\n    private static final double DD = 0.001;\n    private static final double FIN = 10000000.0;\n\n    private static double rho(double a) {\n        return Math.exp(-a / 8500.0);\n    }\n\n    private static double height(double a, double z, double d) {\n        double aa = RE + a;\n        double hh = Math.sqrt(aa * aa + d * d - 2.0 * d * aa * Math.cos((180 - z) * DEG));\n        return hh - RE;\n    }\n\n    private static double columnDensity(double a, double z) {\n        double sum = 0.0, d = 0.0;\n        while (d < FIN) {\n            double delta = DD * d;\n            if (delta < DD)\n                delta = DD;\n            sum += rho(height(a, z, d + 0.5 * delta)) * delta;\n            d += delta;\n        }\n        return sum;\n    }\n\n    private static double airmass(double a, double z) {\n        return columnDensity(a, z) / columnDensity(a, 0.0);\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"Angle     0 m              13700 m\");\n        System.out.println(\"------------------------------------\");\n        for (double z = 0; z <= 90; z += 5) {\n            System.out.printf(\"%2.0f      %11.8f      %11.8f\\n\",\n                    z, airmass(0.0, z), airmass(13700.0, z));\n        }\n    }\n}", "index": 31}
{"lang": "C, Java", "input": "#include <math.h>\n#include <stdio.h>\n\n#define DEG 0.017453292519943295769236907684886127134  \n#define RE 6371000.0 \n#define DD 0.001 \n#define FIN 10000000.0 \n\nstatic double rho(double a) {\n    \n    return exp(-a / 8500.0);\n}\n\nstatic double height(double a, double z, double d) {\n    \n    \n    \n    double aa = RE + a;\n    double hh = sqrt(aa * aa + d * d - 2.0 * d * aa * cos((180 - z) * DEG));\n    return hh - RE;\n}\n\nstatic double column_density(double a, double z) {\n    \n    double sum = 0.0, d = 0.0;\n    while (d < FIN) {\n        \n        double delta = DD * d;\n        if (delta < DD)\n            delta = DD;\n        sum += rho(height(a, z, d + 0.5 * delta)) * delta;\n        d += delta;\n    }\n    return sum;\n}\n\nstatic double airmass(double a, double z) {\n    return column_density(a, z) / column_density(a, 0.0);\n}\n\nint main() {\n    puts(\"Angle     0 m              13700 m\");\n    puts(\"------------------------------------\");\n    for (double z = 0; z <= 90; z+= 5) {\n        printf(\"%2.0f      %11.8f      %11.8f\\n\",\n               z, airmass(0.0, z), airmass(13700.0, z));\n    }\n}", "gold": "public class AirMass {\n    public static void main(String[] args) {\n        System.out.println(\"Angle     0 m              13700 m\");\n        System.out.println(\"------------------------------------\");\n        for (double z = 0; z <= 90; z+= 5) {\n            System.out.printf(\"%2.0f      %11.8f      %11.8f\\n\",\n                            z, airmass(0.0, z), airmass(13700.0, z));\n        }\n    }\n\n    private static double rho(double a) {\n        \n        return Math.exp(-a / 8500.0);\n    }\n\n    private static double height(double a, double z, double d) {\n        \n        \n        \n        double aa = RE + a;\n        double hh = Math.sqrt(aa * aa + d * d - 2.0 * d * aa * Math.cos(Math.toRadians(180 - z)));\n        return hh - RE;\n    }\n\n    private static double columnDensity(double a, double z) {\n        \n        double sum = 0.0, d = 0.0;\n        while (d < FIN) {\n            \n            double delta = Math.max(DD * d, DD);\n            sum += rho(height(a, z, d + 0.5 * delta)) * delta;\n            d += delta;\n        }\n        return sum;\n    }\n     \n    private static double airmass(double a, double z) {\n        return columnDensity(a, z) / columnDensity(a, 0.0);\n    }\n\n    private static final double RE = 6371000.0; \n    private static final double DD = 0.001; \n    private static final double FIN = 10000000.0; \n}", "llm": "magic-7b", "output": "import java.lang.Math;\n\npublic class Main {\n    private static final double DEG = 0.017453292519943295769236907684886127134;\n    private static final double RE = 6371000.0;\n    private static final double DD = 0.001;\n    private static final double FIN = 10000000.0;\n\n    private static double rho(double a) {\n        return Math.exp(-a / 8500.0);\n    }\n\n    private static double height(double a, double z, double d) {\n        double aa = RE + a;\n        double hh = Math.sqrt(aa * aa + d * d - 2.0 * d * aa * Math.cos((180 - z) * DEG));\n        return hh - RE;\n    }\n\n    private static double column_density(double a, double z) {\n        double sum = 0.0, d = 0.0;\n        while (d < FIN) {\n            double delta = DD * d;\n            if (delta < DD)\n                delta = DD;\n            sum += rho(height(a, z, d + 0.5 * delta)) * delta;\n            d += delta;\n        }\n        return sum;\n    }\n\n    private static double airmass(double a, double z) {\n        return column_density(a, z) / column_density(a, 0.0);\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"Angle     0 m              13700 m\");\n        System.out.println(\"------------------------------------\");\n        for (double z = 0; z <= 90; z+= 5) {\n            System.out.printf(\"%2.0f      %11.8f      %11.8f\\n\", z, airmass(0.0, z), airmass(13700.0, z));\n        }\n    }\n}", "index": 32}
{"lang": "C, C++", "input": "#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\nbool isPrime(int64_t n) {\n    int64_t i;\n\n    if (n < 2)       return false;\n    if (n % 2 == 0)  return n == 2;\n    if (n % 3 == 0)  return n == 3;\n    if (n % 5 == 0)  return n == 5;\n    if (n % 7 == 0)  return n == 7;\n    if (n % 11 == 0) return n == 11;\n    if (n % 13 == 0) return n == 13;\n    if (n % 17 == 0) return n == 17;\n    if (n % 19 == 0) return n == 19;\n\n    for (i = 23; i * i <= n; i += 2) {\n        if (n % i == 0) return false;\n    }\n\n    return true;\n}\n\nint countTwinPrimes(int limit) {\n    int count = 0;\n\n    \n    int64_t p3 = true, p2 = true, p1 = false;\n    int64_t i;\n\n    for (i = 5; i <= limit; i++) {\n        p3 = p2;\n        p2 = p1;\n        p1 = isPrime(i);\n        if (p3 && p1) {\n            count++;\n        }\n    }\n    return count;\n}\n\nvoid test(int limit) {\n    int count = countTwinPrimes(limit);\n    printf(\"Number of twin prime pairs less than %d is %d\\n\", limit, count);\n}\n\nint main() {\n    test(10);\n    test(100);\n    test(1000);\n    test(10000);\n    test(100000);\n    test(1000000);\n    test(10000000);\n    test(100000000);\n    return 0;\n}", "gold": "#include <cstdint>\n#include <iostream>\n#include <string>\n#include <primesieve.hpp>\n\nvoid print_twin_prime_count(long long limit) {\n    std::cout << \"Number of twin prime pairs less than \" << limit\n        << \" is \" << (limit > 0 ? primesieve::count_twins(0, limit - 1) : 0) << '\\n';\n}\n\nint main(int argc, char** argv) {\n    std::cout.imbue(std::locale(\"\"));\n    if (argc > 1) {\n        \n        \n        for (int i = 1; i < argc; ++i) {\n            try {\n                print_twin_prime_count(std::stoll(argv[i]));\n            } catch (const std::exception& ex) {\n                std::cerr << \"Cannot parse limit from '\" << argv[i] << \"'\\n\";\n            }\n        }\n    } else {\n        \n        \n        uint64_t limit = 10;\n        for (int power = 1; power < 12; ++power, limit *= 10)\n            print_twin_prime_count(limit);\n    }\n    return 0;\n}", "llm": "cl-7b", "output": "#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\nbool isPrime(int64_t n) {\n    int64_t i;\n\n    if (n < 2)       return false;\n    if (n % 2 == 0)  return n == 2;\n    if (n % 3 == 0)  return n == 3;\n    if (n % 5 == 0)  return n == 5;\n    if (n % 7 == 0)  return n == 7;\n    if (n % 11 == 0) return n == 11;\n    if (n % 13 == 0) return n == 13;\n    if (n % 17 == 0) return n == 17;\n    if (n % 19 == 0) return n == 19;\n\n    for (i = 23; i * i <= n; i += 2) {\n        if (n % i == 0) return false;\n    }\n\n    return true;\n}\n\nint countTwinPrimes(int limit) {\n    int count = 0;\n\n    \n    int64_t p3 = true, p2 = true, p1 = false;\n    int64_t i;\n\n    for (i = 5; i <= limit; i++) {\n        p3 = p2;\n        p2 = p1;\n        p1 = isPrime(i);\n        if (p3 && p1) {\n            count++;\n        }\n    }\n    return count;\n}\n\nvoid test(int limit) {\n    int count = countTwinPrimes(limit);\n    printf(\"Number of twin prime pairs less than %d is %d\\n\", limit, count);\n}\n\nint main() {\n    test(10);\n    test(100);\n    test(1000);\n    test(10000);\n    test(100000);\n    test(1000000);\n    test(10000000);\n    test(100000000);\n    return 0;\n}", "index": 33}
{"lang": "C, C++", "input": "#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\nbool isPrime(int64_t n) {\n    int64_t i;\n\n    if (n < 2)       return false;\n    if (n % 2 == 0)  return n == 2;\n    if (n % 3 == 0)  return n == 3;\n    if (n % 5 == 0)  return n == 5;\n    if (n % 7 == 0)  return n == 7;\n    if (n % 11 == 0) return n == 11;\n    if (n % 13 == 0) return n == 13;\n    if (n % 17 == 0) return n == 17;\n    if (n % 19 == 0) return n == 19;\n\n    for (i = 23; i * i <= n; i += 2) {\n        if (n % i == 0) return false;\n    }\n\n    return true;\n}\n\nint countTwinPrimes(int limit) {\n    int count = 0;\n\n    \n    int64_t p3 = true, p2 = true, p1 = false;\n    int64_t i;\n\n    for (i = 5; i <= limit; i++) {\n        p3 = p2;\n        p2 = p1;\n        p1 = isPrime(i);\n        if (p3 && p1) {\n            count++;\n        }\n    }\n    return count;\n}\n\nvoid test(int limit) {\n    int count = countTwinPrimes(limit);\n    printf(\"Number of twin prime pairs less than %d is %d\\n\", limit, count);\n}\n\nint main() {\n    test(10);\n    test(100);\n    test(1000);\n    test(10000);\n    test(100000);\n    test(1000000);\n    test(10000000);\n    test(100000000);\n    return 0;\n}", "gold": "#include <cstdint>\n#include <iostream>\n#include <string>\n#include <primesieve.hpp>\n\nvoid print_twin_prime_count(long long limit) {\n    std::cout << \"Number of twin prime pairs less than \" << limit\n        << \" is \" << (limit > 0 ? primesieve::count_twins(0, limit - 1) : 0) << '\\n';\n}\n\nint main(int argc, char** argv) {\n    std::cout.imbue(std::locale(\"\"));\n    if (argc > 1) {\n        \n        \n        for (int i = 1; i < argc; ++i) {\n            try {\n                print_twin_prime_count(std::stoll(argv[i]));\n            } catch (const std::exception& ex) {\n                std::cerr << \"Cannot parse limit from '\" << argv[i] << \"'\\n\";\n            }\n        }\n    } else {\n        \n        \n        uint64_t limit = 10;\n        for (int power = 1; power < 12; ++power, limit *= 10)\n            print_twin_prime_count(limit);\n    }\n    return 0;\n}", "llm": "cs-22b", "output": "#include <cstdint>\n#include <iostream>\n\nbool isPrime(int64_t n) {\n    if (n < 2) return false;\n    if (n % 2 == 0) return n == 2;\n    if (n % 3 == 0) return n == 3;\n    if (n % 5 == 0) return n == 5;\n    if (n % 7 == 0) return n == 7;\n    if (n % 11 == 0) return n == 11;\n    if (n % 13 == 0) return n == 13;\n    if (n % 17 == 0) return n == 17;\n    if (n % 19 == 0) return n == 19;\n\n    for (int64_t i = 23; i * i <= n; i += 2) {\n        if (n % i == 0) return false;\n    }\n\n    return true;\n}\n\nint countTwinPrimes(int limit) {\n    int count = 0;\n    int64_t p3 = true, p2 = true, p1 = false;\n\n    for (int64_t i = 5; i <= limit; i++) {\n        p3 = p2;\n        p2 = p1;\n        p1 = isPrime(i);\n        if (p3 && p1) {\n            count++;\n        }\n    }\n    return count;\n}\n\nvoid test(int limit) {\n    int count = countTwinPrimes(limit);\n    std::cout << \"Number of twin prime pairs less than \" << limit << \" is \" << count << std::endl;\n}\n\nint main() {\n    test(10);\n    test(100);\n    test(1000);\n    test(10000);\n    test(100000);\n    test(1000000);\n    test(10000000);\n    test(100000000);\n    return 0;\n}", "index": 34}
{"lang": "C, C++", "input": "#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\nbool isPrime(int64_t n) {\n    int64_t i;\n\n    if (n < 2)       return false;\n    if (n % 2 == 0)  return n == 2;\n    if (n % 3 == 0)  return n == 3;\n    if (n % 5 == 0)  return n == 5;\n    if (n % 7 == 0)  return n == 7;\n    if (n % 11 == 0) return n == 11;\n    if (n % 13 == 0) return n == 13;\n    if (n % 17 == 0) return n == 17;\n    if (n % 19 == 0) return n == 19;\n\n    for (i = 23; i * i <= n; i += 2) {\n        if (n % i == 0) return false;\n    }\n\n    return true;\n}\n\nint countTwinPrimes(int limit) {\n    int count = 0;\n\n    \n    int64_t p3 = true, p2 = true, p1 = false;\n    int64_t i;\n\n    for (i = 5; i <= limit; i++) {\n        p3 = p2;\n        p2 = p1;\n        p1 = isPrime(i);\n        if (p3 && p1) {\n            count++;\n        }\n    }\n    return count;\n}\n\nvoid test(int limit) {\n    int count = countTwinPrimes(limit);\n    printf(\"Number of twin prime pairs less than %d is %d\\n\", limit, count);\n}\n\nint main() {\n    test(10);\n    test(100);\n    test(1000);\n    test(10000);\n    test(100000);\n    test(1000000);\n    test(10000000);\n    test(100000000);\n    return 0;\n}", "gold": "#include <cstdint>\n#include <iostream>\n#include <string>\n#include <primesieve.hpp>\n\nvoid print_twin_prime_count(long long limit) {\n    std::cout << \"Number of twin prime pairs less than \" << limit\n        << \" is \" << (limit > 0 ? primesieve::count_twins(0, limit - 1) : 0) << '\\n';\n}\n\nint main(int argc, char** argv) {\n    std::cout.imbue(std::locale(\"\"));\n    if (argc > 1) {\n        \n        \n        for (int i = 1; i < argc; ++i) {\n            try {\n                print_twin_prime_count(std::stoll(argv[i]));\n            } catch (const std::exception& ex) {\n                std::cerr << \"Cannot parse limit from '\" << argv[i] << \"'\\n\";\n            }\n        }\n    } else {\n        \n        \n        uint64_t limit = 10;\n        for (int power = 1; power < 12; ++power, limit *= 10)\n            print_twin_prime_count(limit);\n    }\n    return 0;\n}", "llm": "cg4-9b", "output": "#include <cstdint>\n#include <iostream>\n\nbool isPrime(int64_t n) {\n    int64_t i;\n\n    if (n < 2)       return false;\n    if (n % 2 == 0)  return n == 2;\n    if (n % 3 == 0)  return n == 3;\n    if (n % 5 == 0)  return n == 5;\n    if (n % 7 == 0)  return n == 7;\n    if (n % 11 == 0) return n == 11;\n    if (n % 13 == 0) return n == 13;\n    if (n % 17 == 0) return n == 17;\n    if (n % 19 == 0) return n == 19;\n\n    for (i = 23; i * i <= n; i += 2) {\n        if (n % i == 0) return false;\n    }\n\n    return true;\n}\n\nint countTwinPrimes(int limit) {\n    int count = 0;\n\n    int64_t p3 = true, p2 = true, p1 = false;\n    int64_t i;\n\n    for (i = 5; i <= limit; i++) {\n        p3 = p2;\n        p2 = p1;\n        p1 = isPrime(i);\n        if (p3 && p1) {\n            count++;\n        }\n    }\n    return count;\n}\n\nvoid test(int limit) {\n    int count = countTwinPrimes(limit);\n    std::cout << \"Number of twin prime pairs less than \" << limit << \" is \" << count << std::endl;\n}\n\nint main() {\n    test(10);\n    test(100);\n    test(1000);\n    test(10000);\n    test(100000);\n    test(1000000);\n    test(10000000);\n    test(100000000);\n    return 0;\n}", "index": 35}
{"lang": "C, Python", "input": "#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nstruct fp2 {\n    int64_t x, y;\n};\n\nuint64_t randULong(uint64_t min, uint64_t max) {\n    uint64_t t = (uint64_t)rand();\n    return min + t % (max - min);\n}\n\n\nuint64_t mul_mod(uint64_t a, uint64_t b, uint64_t modulus) {\n    uint64_t x = 0, y = a % modulus;\n\n    while (b > 0) {\n        if ((b & 1) == 1) {\n            x = (x + y) % modulus;\n        }\n        y = (y << 1) % modulus;\n        b = b >> 1;\n    }\n\n    return x;\n}\n\n\nuint64_t pow_mod(uint64_t b, uint64_t power, uint64_t modulus) {\n    uint64_t x = 1;\n\n    while (power > 0) {\n        if ((power & 1) == 1) {\n            x = mul_mod(x, b, modulus);\n        }\n        b = mul_mod(b, b, modulus);\n        power = power >> 1;\n    }\n\n    return x;\n}\n\n\nbool isPrime(uint64_t n, int64_t k) {\n    uint64_t a, x, n_one = n - 1, d = n_one;\n    uint32_t s = 0;\n    uint32_t r;\n\n    if (n < 2) {\n        return false;\n    }\n\n    \n    if (n > 9223372036854775808ull) {\n        printf(\"The number is too big, program will end.\\n\");\n        exit(1);\n    }\n\n    if ((n % 2) == 0) {\n        return n == 2;\n    }\n\n    while ((d & 1) == 0) {\n        d = d >> 1;\n        s = s + 1;\n    }\n\n    while (k > 0) {\n        k = k - 1;\n        a = randULong(2, n);\n        x = pow_mod(a, d, n);\n        if (x == 1 || x == n_one) {\n            continue;\n        }\n        for (r = 1; r < s; r++) {\n            x = pow_mod(x, 2, n);\n            if (x == 1) return false;\n            if (x == n_one) goto continue_while;\n        }\n        if (x != n_one) {\n            return false;\n        }\n\n    continue_while: {}\n    }\n\n    return true;\n}\n\nint64_t legendre_symbol(int64_t a, int64_t p) {\n    int64_t x = pow_mod(a, (p - 1) / 2, p);\n    if ((p - 1) == x) {\n        return x - p;\n    } else {\n        return x;\n    }\n}\n\nstruct fp2 fp2mul(struct fp2 a, struct fp2 b, int64_t p, int64_t w2) {\n    struct fp2 answer;\n    uint64_t tmp1, tmp2;\n\n    tmp1 = mul_mod(a.x, b.x, p);\n    tmp2 = mul_mod(a.y, b.y, p);\n    tmp2 = mul_mod(tmp2, w2, p);\n    answer.x = (tmp1 + tmp2) % p;\n    tmp1 = mul_mod(a.x, b.y, p);\n    tmp2 = mul_mod(a.y, b.x, p);\n    answer.y = (tmp1 + tmp2) % p;\n\n    return answer;\n}\n\nstruct fp2 fp2square(struct fp2 a, int64_t p, int64_t w2) {\n    return fp2mul(a, a, p, w2);\n}\n\nstruct fp2 fp2pow(struct fp2 a, int64_t n, int64_t p, int64_t w2) {\n    struct fp2 ret;\n\n    if (n == 0) {\n        ret.x = 1;\n        ret.y = 0;\n        return ret;\n    }\n    if (n == 1) {\n        return a;\n    }\n    if ((n & 1) == 0) {\n        return fp2square(fp2pow(a, n / 2, p, w2), p, w2);\n    } else {\n        return fp2mul(a, fp2pow(a, n - 1, p, w2), p, w2);\n    }\n}\n\nvoid test(int64_t n, int64_t p) {\n    int64_t a, w2;\n    int64_t x1, x2;\n    struct fp2 answer;\n\n    printf(\"Find solution for n = %lld and p = %lld\\n\", n, p);\n    if (p == 2 || !isPrime(p, 15)) {\n        printf(\"No solution, p is not an odd prime.\\n\\n\");\n        return;\n    }\n\n    \n    if (legendre_symbol(n, p) != 1) {\n        printf(\" %lld is not a square in F%lld\\n\\n\", n, p);\n        return;\n    }\n\n    while (true) {\n        do {\n            a = randULong(2, p);\n            w2 = a * a - n;\n        } while (legendre_symbol(w2, p) != -1);\n\n        answer.x = a;\n        answer.y = 1;\n        answer = fp2pow(answer, (p + 1) / 2, p, w2);\n        if (answer.y != 0) {\n            continue;\n        }\n\n        x1 = answer.x;\n        x2 = p - x1;\n        if (mul_mod(x1, x1, p) == n && mul_mod(x2, x2, p) == n) {\n            printf(\"Solution found: x1 = %lld, x2 = %lld\\n\\n\", x1, x2);\n            return;\n        }\n    }\n}\n\nint main() {\n    srand((size_t)time(0));\n\n    test(10, 13);\n    test(56, 101);\n    test(8218, 10007);\n    test(8219, 10007);\n    test(331575, 1000003);\n    test(665165880, 1000000007);\n    \n\n    return 0;\n}", "gold": "def convertToBase(n, b):\n\tif(n < 2):\n\t\treturn [n];\n\ttemp = n;\n\tans = [];\n\twhile(temp != 0):\n\t\tans = [temp % b]+ ans;\n\t\ttemp /= b;\n\treturn ans;\n\n\n\n\ndef cipolla(n,p):\n\tn %= p\n\tif(n == 0 or n == 1):\n\t\treturn (n,-n%p)\n\tphi = p - 1\n\tif(pow(n, phi/2, p) != 1):\n\t\treturn ()\n\tif(p%4 == 3):\n\t\tans = pow(n,(p+1)/4,p)\n\t\treturn (ans,-ans%p)\n\taa = 0\n\tfor i in xrange(1,p):\n\t\ttemp = pow((i*i-n)%p,phi/2,p)\n\t\tif(temp == phi):\n\t\t\taa = i\n\t\t\tbreak;\n\texponent = convertToBase((p+1)/2,2)\n\tdef cipollaMult((a,b),(c,d),w,p):\n\t\treturn ((a*c+b*d*w)%p,(a*d+b*c)%p)\n\tx1 = (aa,1)\n\tx2 = cipollaMult(x1,x1,aa*aa-n,p)\n\tfor i in xrange(1,len(exponent)):\n\t\tif(exponent[i] == 0):\n\t\t\tx2 = cipollaMult(x2,x1,aa*aa-n,p)\n\t\t\tx1 = cipollaMult(x1,x1,aa*aa-n,p)\n\t\telse:\n\t\t\tx1 = cipollaMult(x1,x2,aa*aa-n,p)\n\t\t\tx2 = cipollaMult(x2,x2,aa*aa-n,p)\n\treturn (x1[0],-x1[0]%p)\n\nprint \"Roots of 2 mod 7: \" +str(cipolla(2,7))\nprint \"Roots of 8218 mod 10007: \" +str(cipolla(8218,10007))\nprint \"Roots of 56 mod 101: \" +str(cipolla(56,101))\nprint \"Roots of 1 mod 11: \" +str(cipolla(1,11))\nprint \"Roots of 8219 mod 10007: \" +str(cipolla(8219,10007))", "llm": "cl-7b", "output": "#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nstruct fp2 {\n    int64_t x, y;\n};\n\nuint64_t randULong(uint64_t min, uint64_t max) {\n    uint64_t t = (uint64_t)rand();\n    return min + t % (max - min);\n}\n\n\nuint64_t mul_mod(uint64_t a, uint64_t b, uint64_t modulus) {\n    uint64_t x = 0, y = a % modulus;\n\n    while (b > 0) {\n        if ((b & 1) == 1) {\n            x = (x + y) % modulus;\n        }\n        y = (y << 1) % modulus;\n        b = b >> 1;\n    }\n\n    return x;\n}\n\n\nuint64_t pow_mod(uint64_t b, uint64_t power, uint64_t modulus) {\n    uint64_t x = 1;\n\n    while (power > 0) {\n        if ((power & 1) == 1) {\n            x = mul_mod(x, b, modulus);\n        }\n        b = mul_mod(b, b, modulus);\n        power = power >> 1;\n    }\n\n    return x;\n}\n\n\nbool isPrime(uint64_t n, int64_t k) {\n    uint64_t a, x, n_one = n - 1, d = n_one;\n    uint32_t s = 0;\n    uint32_t r;\n\n    if (n < 2) {\n        return false;\n    }\n\n    \n    if (n > 9223372036854775808ull) {\n        printf(\"The number is too big, program will end.\\n\");\n        exit(1);\n    }\n\n    if ((n % 2) == 0) {\n        return n == 2;\n    }\n\n    while ((d & 1) == 0) {\n        d = d >> 1;\n        s = s + 1;\n    }\n\n    while (k > 0) {\n        k = k - 1;\n        a = randULong(2, n);\n        x = pow_mod(a, d, n);\n        if (x == 1 || x == n_one) {\n            continue;\n        }\n        for (r = 1; r < s; r++) {\n            x = pow_mod(x, 2, n);\n            if (x == 1) return false;\n            if (x == n_one) goto continue_while;\n        }\n        if (x != n_one) {\n            return false;\n        }\n\n    continue_while: {}\n    }\n\n    return true;\n}\n\nint64_t legendre_symbol(int64_t a, int64_t p) {\n    int64_t x = pow_mod(a, (p - 1) / 2, p);\n    if ((p - 1) == x) {\n        return x - p;\n    } else {\n        return x;\n    }\n}\n\nstruct fp2 fp2mul(struct fp2 a, struct fp2 b, int64_t p, int64_t w2) {\n    struct fp2 answer;\n    uint64_t tmp1, tmp2;\n\n    tmp1 = mul_mod(a.x, b.x, p);\n    tmp2 = mul_mod(a.y, b.y, p);\n    tmp2 = mul_mod(tmp2, w2, p);\n    answer.x = (tmp1 + tmp2) % p;\n    tmp1 = mul_mod(a.x, b.y, p);\n    tmp2 = mul_mod(a.y, b.x, p);\n    answer.y = (tmp1 + tmp2) % p;\n\n    return answer;\n}\n\nstruct fp2 fp2square(struct fp2 a, int64_t p, int64_t w2) {\n    return fp2mul(a, a, p, w2);\n}\n\nstruct fp2 fp2pow(struct fp2 a, int64_t n, int64_t p, int64_t w2) {\n    struct fp2 ret;\n\n    if (n == 0) {\n        ret.x = 1;\n        ret.y = 0;\n        return ret;\n    }\n    if (n == 1) {\n        return a;\n    }\n    if ((n & 1) == 0) {\n        return fp2square(fp2pow(a, n / 2, p, w2), p, w2);\n    } else {\n        return fp2mul(a, fp2pow(a, n - 1, p, w2), p, w2);\n    }\n}\n\nvoid test(int64_t n, int64_t p) {\n    int64_t a, w2;\n    int64_t x1, x2;\n    struct fp2 answer;\n\n    printf(\"Find solution for n = %lld and p = %lld\\n\", n, p);\n    if (p == 2 || !isPrime(p, 15)) {\n        printf(\"No solution, p is not an odd prime.\\n\\n\");\n        return;\n    }\n\n    \n    if (legendre_symbol(n, p) != 1) {\n        printf(\" %lld is not a square in F%lld\\n\\n\", n, p);\n        return;\n    }\n\n    while (true) {\n        do {\n            a = randULong(2, p);\n            w2 = a * a - n;\n        } while (legendre_symbol(w2, p) != -1);\n\n        answer.x = a;\n        answer.y = 1;\n        answer = fp2pow(answer, (p + 1) / 2, p, w2);\n        if (answer.y != 0) {\n            continue;\n        }\n\n        x1 = answer.x;\n        x2 = p - x1;\n        if (mul_mod(x1, x1, p) == n && mul_mod(x2, x2, p) == n) {\n            printf(\"Solution found: x1 = %lld, x2 = %lld\\n\\n\", x1, x2);\n            return;\n        }\n    }\n}\n\nint main() {\n    srand((size_t)time(0));\n\n    test(10, 13);\n    test(56, 101);\n    test(8218, 10007);\n    test(8219, 10007);\n    test(331575, 1000003);\n    test(665165880, 1000000007);\n    \n\n    return 0;\n}", "index": 36}
{"lang": "C, Python", "input": "#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nstruct fp2 {\n    int64_t x, y;\n};\n\nuint64_t randULong(uint64_t min, uint64_t max) {\n    uint64_t t = (uint64_t)rand();\n    return min + t % (max - min);\n}\n\n\nuint64_t mul_mod(uint64_t a, uint64_t b, uint64_t modulus) {\n    uint64_t x = 0, y = a % modulus;\n\n    while (b > 0) {\n        if ((b & 1) == 1) {\n            x = (x + y) % modulus;\n        }\n        y = (y << 1) % modulus;\n        b = b >> 1;\n    }\n\n    return x;\n}\n\n\nuint64_t pow_mod(uint64_t b, uint64_t power, uint64_t modulus) {\n    uint64_t x = 1;\n\n    while (power > 0) {\n        if ((power & 1) == 1) {\n            x = mul_mod(x, b, modulus);\n        }\n        b = mul_mod(b, b, modulus);\n        power = power >> 1;\n    }\n\n    return x;\n}\n\n\nbool isPrime(uint64_t n, int64_t k) {\n    uint64_t a, x, n_one = n - 1, d = n_one;\n    uint32_t s = 0;\n    uint32_t r;\n\n    if (n < 2) {\n        return false;\n    }\n\n    \n    if (n > 9223372036854775808ull) {\n        printf(\"The number is too big, program will end.\\n\");\n        exit(1);\n    }\n\n    if ((n % 2) == 0) {\n        return n == 2;\n    }\n\n    while ((d & 1) == 0) {\n        d = d >> 1;\n        s = s + 1;\n    }\n\n    while (k > 0) {\n        k = k - 1;\n        a = randULong(2, n);\n        x = pow_mod(a, d, n);\n        if (x == 1 || x == n_one) {\n            continue;\n        }\n        for (r = 1; r < s; r++) {\n            x = pow_mod(x, 2, n);\n            if (x == 1) return false;\n            if (x == n_one) goto continue_while;\n        }\n        if (x != n_one) {\n            return false;\n        }\n\n    continue_while: {}\n    }\n\n    return true;\n}\n\nint64_t legendre_symbol(int64_t a, int64_t p) {\n    int64_t x = pow_mod(a, (p - 1) / 2, p);\n    if ((p - 1) == x) {\n        return x - p;\n    } else {\n        return x;\n    }\n}\n\nstruct fp2 fp2mul(struct fp2 a, struct fp2 b, int64_t p, int64_t w2) {\n    struct fp2 answer;\n    uint64_t tmp1, tmp2;\n\n    tmp1 = mul_mod(a.x, b.x, p);\n    tmp2 = mul_mod(a.y, b.y, p);\n    tmp2 = mul_mod(tmp2, w2, p);\n    answer.x = (tmp1 + tmp2) % p;\n    tmp1 = mul_mod(a.x, b.y, p);\n    tmp2 = mul_mod(a.y, b.x, p);\n    answer.y = (tmp1 + tmp2) % p;\n\n    return answer;\n}\n\nstruct fp2 fp2square(struct fp2 a, int64_t p, int64_t w2) {\n    return fp2mul(a, a, p, w2);\n}\n\nstruct fp2 fp2pow(struct fp2 a, int64_t n, int64_t p, int64_t w2) {\n    struct fp2 ret;\n\n    if (n == 0) {\n        ret.x = 1;\n        ret.y = 0;\n        return ret;\n    }\n    if (n == 1) {\n        return a;\n    }\n    if ((n & 1) == 0) {\n        return fp2square(fp2pow(a, n / 2, p, w2), p, w2);\n    } else {\n        return fp2mul(a, fp2pow(a, n - 1, p, w2), p, w2);\n    }\n}\n\nvoid test(int64_t n, int64_t p) {\n    int64_t a, w2;\n    int64_t x1, x2;\n    struct fp2 answer;\n\n    printf(\"Find solution for n = %lld and p = %lld\\n\", n, p);\n    if (p == 2 || !isPrime(p, 15)) {\n        printf(\"No solution, p is not an odd prime.\\n\\n\");\n        return;\n    }\n\n    \n    if (legendre_symbol(n, p) != 1) {\n        printf(\" %lld is not a square in F%lld\\n\\n\", n, p);\n        return;\n    }\n\n    while (true) {\n        do {\n            a = randULong(2, p);\n            w2 = a * a - n;\n        } while (legendre_symbol(w2, p) != -1);\n\n        answer.x = a;\n        answer.y = 1;\n        answer = fp2pow(answer, (p + 1) / 2, p, w2);\n        if (answer.y != 0) {\n            continue;\n        }\n\n        x1 = answer.x;\n        x2 = p - x1;\n        if (mul_mod(x1, x1, p) == n && mul_mod(x2, x2, p) == n) {\n            printf(\"Solution found: x1 = %lld, x2 = %lld\\n\\n\", x1, x2);\n            return;\n        }\n    }\n}\n\nint main() {\n    srand((size_t)time(0));\n\n    test(10, 13);\n    test(56, 101);\n    test(8218, 10007);\n    test(8219, 10007);\n    test(331575, 1000003);\n    test(665165880, 1000000007);\n    \n\n    return 0;\n}", "gold": "def convertToBase(n, b):\n\tif(n < 2):\n\t\treturn [n];\n\ttemp = n;\n\tans = [];\n\twhile(temp != 0):\n\t\tans = [temp % b]+ ans;\n\t\ttemp /= b;\n\treturn ans;\n\n\n\n\ndef cipolla(n,p):\n\tn %= p\n\tif(n == 0 or n == 1):\n\t\treturn (n,-n%p)\n\tphi = p - 1\n\tif(pow(n, phi/2, p) != 1):\n\t\treturn ()\n\tif(p%4 == 3):\n\t\tans = pow(n,(p+1)/4,p)\n\t\treturn (ans,-ans%p)\n\taa = 0\n\tfor i in xrange(1,p):\n\t\ttemp = pow((i*i-n)%p,phi/2,p)\n\t\tif(temp == phi):\n\t\t\taa = i\n\t\t\tbreak;\n\texponent = convertToBase((p+1)/2,2)\n\tdef cipollaMult((a,b),(c,d),w,p):\n\t\treturn ((a*c+b*d*w)%p,(a*d+b*c)%p)\n\tx1 = (aa,1)\n\tx2 = cipollaMult(x1,x1,aa*aa-n,p)\n\tfor i in xrange(1,len(exponent)):\n\t\tif(exponent[i] == 0):\n\t\t\tx2 = cipollaMult(x2,x1,aa*aa-n,p)\n\t\t\tx1 = cipollaMult(x1,x1,aa*aa-n,p)\n\t\telse:\n\t\t\tx1 = cipollaMult(x1,x2,aa*aa-n,p)\n\t\t\tx2 = cipollaMult(x2,x2,aa*aa-n,p)\n\treturn (x1[0],-x1[0]%p)\n\nprint \"Roots of 2 mod 7: \" +str(cipolla(2,7))\nprint \"Roots of 8218 mod 10007: \" +str(cipolla(8218,10007))\nprint \"Roots of 56 mod 101: \" +str(cipolla(56,101))\nprint \"Roots of 1 mod 11: \" +str(cipolla(1,11))\nprint \"Roots of 8219 mod 10007: \" +str(cipolla(8219,10007))", "llm": "cl-34b", "output": "import random\nimport time\n\ndef randULong(min, max):\n    t = random.randint(min, max)\n    return min + t % (max - min)\n\ndef mul_mod(a, b, modulus):\n    x = 0\n    y = a % modulus\n\n    while b > 0:\n        if b & 1 == 1:\n            x = (x + y) % modulus\n        y = (y << 1) % modulus\n        b = b >> 1\n\n    return x\n\ndef pow_mod(b, power, modulus):\n    x = 1\n\n    while power > 0:\n        if power & 1 == 1:\n            x = mul_mod(x, b, modulus)\n        b = mul_mod(b, b, modulus)\n        power = power >> 1\n\n    return x\n\ndef isPrime(n, k):\n    if n < 2:\n        return False\n\n    if n > 9223372036854775808:\n        print(\"The number is too big, program will end.\")\n        exit(1)\n\n    if n % 2 == 0:\n        return n == 2\n\n    d = n - 1\n    s = 0\n    r = 0\n\n    while d & 1 == 0:\n        d = d >> 1\n        s = s + 1\n\n    while k > 0:\n        k = k - 1\n        a = randULong(2, n)\n        x = pow_mod(a, d, n)\n        if x == 1 or x == n - 1:\n            continue\n        for r in range(1, s):\n            x = pow_mod(x, 2, n)\n            if x == 1:\n                return False\n            if x == n - 1:\n                break\n        if x != n - 1:\n            return False\n\n    return True\n\ndef legendre_symbol(a, p):\n    x = pow_mod(a, (p - 1) / 2, p)\n    if (p - 1) == x:\n        return x - p\n    else:\n        return x\n\ndef fp2mul(a, b, p, w2):\n    tmp1 = mul_mod(a.x, b.x, p)\n    tmp2 = mul_mod(a.y, b.y, p)\n    tmp2 = mul_mod(tmp2, w2, p)\n    answer.x = (tmp1 + tmp2) % p\n    tmp1 = mul_mod(a.x, b.y, p)\n    tmp2 = mul_mod(a.y, b.x, p)\n    answer.y = (tmp1 + tmp2) % p\n\n    return answer\n\ndef fp2square(a, p, w2):\n    return fp2mul(a, a, p, w2)\n\ndef fp2pow(a, n, p, w2):\n    if n == 0:\n        return 1\n    if n == 1:\n        return a\n    if n & 1 == 0:\n        return fp2square(fp2pow(a, n / 2, p, w2), p, w2)\n    else:\n        return fp2mul(a, fp2pow(a, n - 1, p, w2), p, w2)\n\ndef test(n, p):\n    a = 0\n    w2 = 0\n    x1 = 0\n    x2 = 0\n    answer = 0\n\n    print(\"Find solution for n =\", n, \"and p =\", p)\n    if p == 2 or not isPrime(p, 15):\n        print(\"No solution, p is not an odd prime.\")\n        return\n\n    if legendre_symbol(n, p) != 1:\n        print(\"\", n, \"is not a square in F\", p)\n        return\n\n    while True:\n        do:\n            a = randULong(2, p)\n            w2 = a * a - n\n        while legendre_symbol(w2, p) != -1\n\n        answer.x = a\n        answer.y = 1\n        answer = fp2pow(answer, (p + 1) / 2, p, w2)\n        if answer.y != 0:\n            continue\n\n        x1 = answer.x\n        x2 = p - x1\n        if mul_mod(x1, x1, p) == n and mul_mod(x2, x2, p) == n:\n            print(\"Solution found: x1 =\", x1, \", x2 =\", x2)\n            return\n\ndef main():\n    srand(time.time())\n\n    test(10, 13)\n    test(56, 101)\n    test(8218, 10007)\n    test(8219, 10007)\n    test(331575, 1000003)\n    test(665165880, 1000000007)\n\n    return 0\n\nmain()", "index": 37}
{"lang": "C, Python", "input": "#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nstruct fp2 {\n    int64_t x, y;\n};\n\nuint64_t randULong(uint64_t min, uint64_t max) {\n    uint64_t t = (uint64_t)rand();\n    return min + t % (max - min);\n}\n\n\nuint64_t mul_mod(uint64_t a, uint64_t b, uint64_t modulus) {\n    uint64_t x = 0, y = a % modulus;\n\n    while (b > 0) {\n        if ((b & 1) == 1) {\n            x = (x + y) % modulus;\n        }\n        y = (y << 1) % modulus;\n        b = b >> 1;\n    }\n\n    return x;\n}\n\n\nuint64_t pow_mod(uint64_t b, uint64_t power, uint64_t modulus) {\n    uint64_t x = 1;\n\n    while (power > 0) {\n        if ((power & 1) == 1) {\n            x = mul_mod(x, b, modulus);\n        }\n        b = mul_mod(b, b, modulus);\n        power = power >> 1;\n    }\n\n    return x;\n}\n\n\nbool isPrime(uint64_t n, int64_t k) {\n    uint64_t a, x, n_one = n - 1, d = n_one;\n    uint32_t s = 0;\n    uint32_t r;\n\n    if (n < 2) {\n        return false;\n    }\n\n    \n    if (n > 9223372036854775808ull) {\n        printf(\"The number is too big, program will end.\\n\");\n        exit(1);\n    }\n\n    if ((n % 2) == 0) {\n        return n == 2;\n    }\n\n    while ((d & 1) == 0) {\n        d = d >> 1;\n        s = s + 1;\n    }\n\n    while (k > 0) {\n        k = k - 1;\n        a = randULong(2, n);\n        x = pow_mod(a, d, n);\n        if (x == 1 || x == n_one) {\n            continue;\n        }\n        for (r = 1; r < s; r++) {\n            x = pow_mod(x, 2, n);\n            if (x == 1) return false;\n            if (x == n_one) goto continue_while;\n        }\n        if (x != n_one) {\n            return false;\n        }\n\n    continue_while: {}\n    }\n\n    return true;\n}\n\nint64_t legendre_symbol(int64_t a, int64_t p) {\n    int64_t x = pow_mod(a, (p - 1) / 2, p);\n    if ((p - 1) == x) {\n        return x - p;\n    } else {\n        return x;\n    }\n}\n\nstruct fp2 fp2mul(struct fp2 a, struct fp2 b, int64_t p, int64_t w2) {\n    struct fp2 answer;\n    uint64_t tmp1, tmp2;\n\n    tmp1 = mul_mod(a.x, b.x, p);\n    tmp2 = mul_mod(a.y, b.y, p);\n    tmp2 = mul_mod(tmp2, w2, p);\n    answer.x = (tmp1 + tmp2) % p;\n    tmp1 = mul_mod(a.x, b.y, p);\n    tmp2 = mul_mod(a.y, b.x, p);\n    answer.y = (tmp1 + tmp2) % p;\n\n    return answer;\n}\n\nstruct fp2 fp2square(struct fp2 a, int64_t p, int64_t w2) {\n    return fp2mul(a, a, p, w2);\n}\n\nstruct fp2 fp2pow(struct fp2 a, int64_t n, int64_t p, int64_t w2) {\n    struct fp2 ret;\n\n    if (n == 0) {\n        ret.x = 1;\n        ret.y = 0;\n        return ret;\n    }\n    if (n == 1) {\n        return a;\n    }\n    if ((n & 1) == 0) {\n        return fp2square(fp2pow(a, n / 2, p, w2), p, w2);\n    } else {\n        return fp2mul(a, fp2pow(a, n - 1, p, w2), p, w2);\n    }\n}\n\nvoid test(int64_t n, int64_t p) {\n    int64_t a, w2;\n    int64_t x1, x2;\n    struct fp2 answer;\n\n    printf(\"Find solution for n = %lld and p = %lld\\n\", n, p);\n    if (p == 2 || !isPrime(p, 15)) {\n        printf(\"No solution, p is not an odd prime.\\n\\n\");\n        return;\n    }\n\n    \n    if (legendre_symbol(n, p) != 1) {\n        printf(\" %lld is not a square in F%lld\\n\\n\", n, p);\n        return;\n    }\n\n    while (true) {\n        do {\n            a = randULong(2, p);\n            w2 = a * a - n;\n        } while (legendre_symbol(w2, p) != -1);\n\n        answer.x = a;\n        answer.y = 1;\n        answer = fp2pow(answer, (p + 1) / 2, p, w2);\n        if (answer.y != 0) {\n            continue;\n        }\n\n        x1 = answer.x;\n        x2 = p - x1;\n        if (mul_mod(x1, x1, p) == n && mul_mod(x2, x2, p) == n) {\n            printf(\"Solution found: x1 = %lld, x2 = %lld\\n\\n\", x1, x2);\n            return;\n        }\n    }\n}\n\nint main() {\n    srand((size_t)time(0));\n\n    test(10, 13);\n    test(56, 101);\n    test(8218, 10007);\n    test(8219, 10007);\n    test(331575, 1000003);\n    test(665165880, 1000000007);\n    \n\n    return 0;\n}", "gold": "def convertToBase(n, b):\n\tif(n < 2):\n\t\treturn [n];\n\ttemp = n;\n\tans = [];\n\twhile(temp != 0):\n\t\tans = [temp % b]+ ans;\n\t\ttemp /= b;\n\treturn ans;\n\n\n\n\ndef cipolla(n,p):\n\tn %= p\n\tif(n == 0 or n == 1):\n\t\treturn (n,-n%p)\n\tphi = p - 1\n\tif(pow(n, phi/2, p) != 1):\n\t\treturn ()\n\tif(p%4 == 3):\n\t\tans = pow(n,(p+1)/4,p)\n\t\treturn (ans,-ans%p)\n\taa = 0\n\tfor i in xrange(1,p):\n\t\ttemp = pow((i*i-n)%p,phi/2,p)\n\t\tif(temp == phi):\n\t\t\taa = i\n\t\t\tbreak;\n\texponent = convertToBase((p+1)/2,2)\n\tdef cipollaMult((a,b),(c,d),w,p):\n\t\treturn ((a*c+b*d*w)%p,(a*d+b*c)%p)\n\tx1 = (aa,1)\n\tx2 = cipollaMult(x1,x1,aa*aa-n,p)\n\tfor i in xrange(1,len(exponent)):\n\t\tif(exponent[i] == 0):\n\t\t\tx2 = cipollaMult(x2,x1,aa*aa-n,p)\n\t\t\tx1 = cipollaMult(x1,x1,aa*aa-n,p)\n\t\telse:\n\t\t\tx1 = cipollaMult(x1,x2,aa*aa-n,p)\n\t\t\tx2 = cipollaMult(x2,x2,aa*aa-n,p)\n\treturn (x1[0],-x1[0]%p)\n\nprint \"Roots of 2 mod 7: \" +str(cipolla(2,7))\nprint \"Roots of 8218 mod 10007: \" +str(cipolla(8218,10007))\nprint \"Roots of 56 mod 101: \" +str(cipolla(56,101))\nprint \"Roots of 1 mod 11: \" +str(cipolla(1,11))\nprint \"Roots of 8219 mod 10007: \" +str(cipolla(8219,10007))", "llm": "magic-7b", "output": "import random\nimport time\n\nclass fp2:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\ndef randULong(min, max):\n    t = random.randint(0, 1000000000)\n    return min + t % (max - min)\n\ndef mul_mod(a, b, modulus):\n    x = 0\n    y = a % modulus\n\n    while b > 0:\n        if b & 1 == 1:\n            x = (x + y) % modulus\n        y = (y << 1) % modulus\n        b = b >> 1\n\n    return x\n\ndef pow_mod(b, power, modulus):\n    x = 1\n\n    while power > 0:\n        if power & 1 == 1:\n            x = mul_mod(x, b, modulus)\n        b = mul_mod(b, b, modulus)\n        power = power >> 1\n\n    return x\n\ndef isPrime(n, k):\n    a, x, n_one, d = 0, 0, n - 1, n - 1\n    s = 0\n    r = 0\n\n    if n < 2:\n        return False\n\n    if n > 9223372036854775808:\n        print(\"The number is too big, program will end.\")\n        exit(1)\n\n    if n % 2 == 0:\n        return n == 2\n\n    while d & 1 == 0:\n        d = d >> 1\n        s = s + 1\n\n    while k > 0:\n        k = k - 1\n        a = randULong(2, n)\n        x = pow_mod(a, d, n)\n        if x == 1 or x == n_one:\n            continue\n        for r in range(1, s):\n            x = pow_mod(x, 2, n)\n            if x == 1: return False\n            if x == n_one: break\n        if x != n_one:\n            return False\n\n    return True\n\ndef legendre_symbol(a, p):\n    x = pow_mod(a, (p - 1) // 2, p)\n    if (p - 1) == x:\n        return x - p\n    else:\n        return x\n\ndef fp2mul(a, b, p, w2):\n    tmp1 = mul_mod(a.x, b.x, p)\n    tmp2 = mul_mod(a.y, b.y, p)\n    tmp2 = mul_mod(tmp2, w2, p)\n    x = (tmp1 + tmp2) % p\n    tmp1 = mul_mod(a.x, b.y, p)\n    tmp2 = mul_mod(a.y, b.x, p)\n    y = (tmp1 + tmp2) % p\n    return fp2(x, y)\n\ndef fp2square(a, p, w2):\n    return fp2mul(a, a, p, w2)\n\ndef fp2pow(a, n, p, w2):\n    if n == 0:\n        return fp2(1, 0)\n    if n == 1:\n        return a\n    if n % 2 == 0:\n        return fp2square(fp2pow(a, n // 2, p, w2), p, w2)\n    else:\n        return fp2mul(a, fp2pow(a, n - 1, p, w2), p, w2)\n\ndef test(n, p):\n    a, w2 = 0, 0\n    x1, x2 = 0, 0\n    answer = fp2(0, 0)\n\n    print(\"Find solution for n = %d and p = %d\" % (n, p))\n    if p == 2 or not isPrime(p, 15):\n        print(\"No solution, p is not an odd prime.\")\n        return\n\n    if legendre_symbol(n, p) != 1:\n        print(\" %d is not a square in F%d\" % (n, p))\n        return\n\n    while True:\n        while True:\n            a = randULong(2, p)\n            w2 = a * a - n\n            if legendre_symbol(w2, p) == -1:\n                break\n        answer.x = a\n        answer.y = 1\n        answer = fp2pow(answer, (p + 1) // 2, p, w2)\n        if answer.y != 0:\n            continue\n\n        x1 = answer.x\n        x2 = p - x1\n        if mul_mod(x1, x1, p) == n and mul_mod(x2, x2, p) == n:\n            print(\"Solution found: x1 = %d, x2 = %d\" % (x1, x2))\n            return\n\nrandom.seed(time.time())\n\ntest(10, 13)\ntest(56, 101)\ntest(8218, 10007)\ntest(8219, 10007)\ntest(331575, 1000003)\ntest(665165880, 1000000007)", "index": 38}
{"lang": "C, Java", "input": "#include <stdio.h>\n\n#define MAX_N 33\t\n#define BRANCH 4\t\n\n\n\ntypedef unsigned long long xint;\n#define FMT \"llu\"\n\nxint rooted[MAX_N] = {1, 1, 0};\nxint unrooted[MAX_N] = {1, 1, 0};\n\n\nxint choose(xint m, xint k)\n{\n\txint i, r;\n\n\tif (k == 1) return m;\n\tfor (r = m, i = 1; i < k; i++)\n\t\tr = r * (m + i) / (i + 1);\n\treturn r;\n}\n\n\nvoid tree(xint br, xint n, xint cnt, xint sum, xint l)\n{\n\txint b, c, m, s;\n\n\tfor (b = br + 1; b <= BRANCH; b++) {\n\t\ts = sum + (b - br) * n;\n\t\tif (s >= MAX_N) return;\n\n\t\t\n\t\tc = choose(rooted[n], b - br) * cnt;\n\n\t\t\n\t\tif (l * 2 < s) unrooted[s] += c;\n\n\t\t\n\t\tif (b == BRANCH) return;\n\t\trooted[s] += c;\n\n\t\t\n\t\tfor (m = n; --m; ) tree(b, m, c, s, l);\n\t}\n}\n\nvoid bicenter(int s)\n{\n\tif (s & 1) return;\n\n\t\n\tunrooted[s] += rooted[s/2] * (rooted[s/2] + 1) / 2;\n}\n\nint main()\n{\n\txint n;\n\tfor (n = 1; n < MAX_N; n++) {\n\t\ttree(0, n, 1, 1, n);\n\t\tbicenter(n);\n\t\tprintf(\"%\"FMT\":\u00a0%\"FMT\"\\n\", n, unrooted[n]);\n\t}\n\n\treturn 0;\n}", "gold": "import java.math.BigInteger;\nimport java.util.Arrays;\n\nclass Test {\n    final static int nMax = 250;\n    final static int nBranches = 4;\n\n    static BigInteger[] rooted = new BigInteger[nMax + 1];\n    static BigInteger[] unrooted = new BigInteger[nMax + 1];\n    static BigInteger[] c = new BigInteger[nBranches];\n\n    static void tree(int br, int n, int l, int inSum, BigInteger cnt) {\n        int sum = inSum;\n        for (int b = br + 1; b <= nBranches; b++) {\n            sum += n;\n\n            if (sum > nMax || (l * 2 >= sum && b >= nBranches))\n                return;\n\n            BigInteger tmp = rooted[n];\n            if (b == br + 1) {\n                c[br] = tmp.multiply(cnt);\n            } else {\n                c[br] = c[br].multiply(tmp.add(BigInteger.valueOf(b - br - 1)));\n                c[br] = c[br].divide(BigInteger.valueOf(b - br));\n            }\n\n            if (l * 2 < sum)\n                unrooted[sum] = unrooted[sum].add(c[br]);\n\n            if (b < nBranches)\n                rooted[sum] = rooted[sum].add(c[br]);\n\n            for (int m = n - 1; m > 0; m--)\n                tree(b, m, l, sum, c[br]);\n        }\n    }\n\n    static void bicenter(int s) {\n        if ((s & 1) == 0) {\n            BigInteger tmp = rooted[s / 2];\n            tmp = tmp.add(BigInteger.ONE).multiply(rooted[s / 2]);\n            unrooted[s] = unrooted[s].add(tmp.shiftRight(1));\n        }\n    }\n\n    public static void main(String[] args) {\n        Arrays.fill(rooted, BigInteger.ZERO);\n        Arrays.fill(unrooted, BigInteger.ZERO);\n        rooted[0] = rooted[1] = BigInteger.ONE;\n        unrooted[0] = unrooted[1] = BigInteger.ONE;\n\n        for (int n = 1; n <= nMax; n++) {\n            tree(0, n, n, 1, BigInteger.ONE);\n            bicenter(n);\n            System.out.printf(\"%d: %s%n\", n, unrooted[n]);\n        }\n    }\n}", "llm": "dsc-33b", "output": "import java.util.Arrays;\n\npublic class Main {\n    private static final int MAX_N = 33;\n    private static final int BRANCH = 4;\n\n    private static long[] rooted = new long[MAX_N];\n    private static long[] unrooted = new long[MAX_N];\n\n    static {\n        Arrays.fill(rooted, 0);\n        Arrays.fill(unrooted, 0);\n        rooted[0] = 1;\n        rooted[1] = 1;\n        unrooted[0] = 1;\n        unrooted[1] = 1;\n    }\n\n    private static long choose(long m, long k) {\n        long r;\n        if (k == 1) return m;\n        for (r = m, long i = 1; i < k; i++)\n            r = r * (m + i) / (i + 1);\n        return r;\n    }\n\n    private static void tree(long br, long n, long cnt, long sum, long l) {\n        long b, c, m, s;\n        for (b = br + 1; b <= BRANCH; b++) {\n            s = sum + (b - br) * n;\n            if (s >= MAX_N) return;\n            c = choose(rooted[(int) n], b - br) * cnt;\n            if (l * 2 < s) unrooted[(int) s] += c;\n            if (b == BRANCH) return;\n            rooted[(int) s] += c;\n            for (m = n; --m > 0; ) tree(b, m, c, s, l);\n        }\n    }\n\n    private static void bicenter(int s) {\n        if ((s & 1) != 0) return;\n        unrooted[s] += rooted[s/2] * (rooted[s/2] + 1) / 2;\n    }\n\n    public static void main(String[] args) {\n        for (long n = 1; n < MAX_N; n++) {\n            tree(0, n, 1, 1, n);\n            bicenter((int) n);\n            System.out.printf(\"%d: %d\\n\", n, unrooted[(int) n]);\n        }\n    }\n}", "index": 39}
{"lang": "C, Java", "input": "#include <stdio.h>\n\n#define MAX_N 33\t\n#define BRANCH 4\t\n\n\n\ntypedef unsigned long long xint;\n#define FMT \"llu\"\n\nxint rooted[MAX_N] = {1, 1, 0};\nxint unrooted[MAX_N] = {1, 1, 0};\n\n\nxint choose(xint m, xint k)\n{\n\txint i, r;\n\n\tif (k == 1) return m;\n\tfor (r = m, i = 1; i < k; i++)\n\t\tr = r * (m + i) / (i + 1);\n\treturn r;\n}\n\n\nvoid tree(xint br, xint n, xint cnt, xint sum, xint l)\n{\n\txint b, c, m, s;\n\n\tfor (b = br + 1; b <= BRANCH; b++) {\n\t\ts = sum + (b - br) * n;\n\t\tif (s >= MAX_N) return;\n\n\t\t\n\t\tc = choose(rooted[n], b - br) * cnt;\n\n\t\t\n\t\tif (l * 2 < s) unrooted[s] += c;\n\n\t\t\n\t\tif (b == BRANCH) return;\n\t\trooted[s] += c;\n\n\t\t\n\t\tfor (m = n; --m; ) tree(b, m, c, s, l);\n\t}\n}\n\nvoid bicenter(int s)\n{\n\tif (s & 1) return;\n\n\t\n\tunrooted[s] += rooted[s/2] * (rooted[s/2] + 1) / 2;\n}\n\nint main()\n{\n\txint n;\n\tfor (n = 1; n < MAX_N; n++) {\n\t\ttree(0, n, 1, 1, n);\n\t\tbicenter(n);\n\t\tprintf(\"%\"FMT\":\u00a0%\"FMT\"\\n\", n, unrooted[n]);\n\t}\n\n\treturn 0;\n}", "gold": "import java.math.BigInteger;\nimport java.util.Arrays;\n\nclass Test {\n    final static int nMax = 250;\n    final static int nBranches = 4;\n\n    static BigInteger[] rooted = new BigInteger[nMax + 1];\n    static BigInteger[] unrooted = new BigInteger[nMax + 1];\n    static BigInteger[] c = new BigInteger[nBranches];\n\n    static void tree(int br, int n, int l, int inSum, BigInteger cnt) {\n        int sum = inSum;\n        for (int b = br + 1; b <= nBranches; b++) {\n            sum += n;\n\n            if (sum > nMax || (l * 2 >= sum && b >= nBranches))\n                return;\n\n            BigInteger tmp = rooted[n];\n            if (b == br + 1) {\n                c[br] = tmp.multiply(cnt);\n            } else {\n                c[br] = c[br].multiply(tmp.add(BigInteger.valueOf(b - br - 1)));\n                c[br] = c[br].divide(BigInteger.valueOf(b - br));\n            }\n\n            if (l * 2 < sum)\n                unrooted[sum] = unrooted[sum].add(c[br]);\n\n            if (b < nBranches)\n                rooted[sum] = rooted[sum].add(c[br]);\n\n            for (int m = n - 1; m > 0; m--)\n                tree(b, m, l, sum, c[br]);\n        }\n    }\n\n    static void bicenter(int s) {\n        if ((s & 1) == 0) {\n            BigInteger tmp = rooted[s / 2];\n            tmp = tmp.add(BigInteger.ONE).multiply(rooted[s / 2]);\n            unrooted[s] = unrooted[s].add(tmp.shiftRight(1));\n        }\n    }\n\n    public static void main(String[] args) {\n        Arrays.fill(rooted, BigInteger.ZERO);\n        Arrays.fill(unrooted, BigInteger.ZERO);\n        rooted[0] = rooted[1] = BigInteger.ONE;\n        unrooted[0] = unrooted[1] = BigInteger.ONE;\n\n        for (int n = 1; n <= nMax; n++) {\n            tree(0, n, n, 1, BigInteger.ONE);\n            bicenter(n);\n            System.out.printf(\"%d: %s%n\", n, unrooted[n]);\n        }\n    }\n}", "llm": "q2.5-1.5b", "output": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        int MAX_N = 33;\n        int BRANCH = 4;\n        long[] rooted = new long[MAX_N];\n        long[] unrooted = new long[MAX_N];\n        rooted[0] = 1;\n        rooted[1] = 1;\n        rooted[2] = 0;\n        unrooted[0] = 1;\n        unrooted[1] = 1;\n        unrooted[2] = 0;\n\n        for (int n = 1; n < MAX_N; n++) {\n            tree(0, n, 1, 1, n);\n            bicenter(n);\n            System.out.println(n + \": \" + unrooted[n]);\n        }\n    }\n\n    public static long choose(long m, long k) {\n        long i, r;\n        if (k == 1) return m;\n        for (r = m, i = 1; i < k; i++)\n            r = r * (m + i) / (i + 1);\n        return r;\n    }\n\n    public static void tree(int br, int n, long cnt, long sum, int l) {\n        for (int b = br + 1; b <= BRANCH; b++) {\n            sum += (b - br) * n;\n            if (sum >= MAX_N) return;\n            long c = choose(rooted[n], b - br) * cnt;\n            if (l * 2 < sum) unrooted[sum] += c;\n            if (b == BRANCH) return;\n            rooted[sum] += c;\n            for (int m = n; --m; ) tree(b, m, c, sum, l);\n        }\n    }\n\n    public static void bicenter(int s) {\n        if (s & 1) return;\n        unrooted[s] += rooted[s / 2] * (rooted[s / 2] + 1) / 2;\n    }\n}", "index": 40}
{"lang": "C, Java", "input": "#include <stdio.h>\n\n#define MAX_N 33\t\n#define BRANCH 4\t\n\n\n\ntypedef unsigned long long xint;\n#define FMT \"llu\"\n\nxint rooted[MAX_N] = {1, 1, 0};\nxint unrooted[MAX_N] = {1, 1, 0};\n\n\nxint choose(xint m, xint k)\n{\n\txint i, r;\n\n\tif (k == 1) return m;\n\tfor (r = m, i = 1; i < k; i++)\n\t\tr = r * (m + i) / (i + 1);\n\treturn r;\n}\n\n\nvoid tree(xint br, xint n, xint cnt, xint sum, xint l)\n{\n\txint b, c, m, s;\n\n\tfor (b = br + 1; b <= BRANCH; b++) {\n\t\ts = sum + (b - br) * n;\n\t\tif (s >= MAX_N) return;\n\n\t\t\n\t\tc = choose(rooted[n], b - br) * cnt;\n\n\t\t\n\t\tif (l * 2 < s) unrooted[s] += c;\n\n\t\t\n\t\tif (b == BRANCH) return;\n\t\trooted[s] += c;\n\n\t\t\n\t\tfor (m = n; --m; ) tree(b, m, c, s, l);\n\t}\n}\n\nvoid bicenter(int s)\n{\n\tif (s & 1) return;\n\n\t\n\tunrooted[s] += rooted[s/2] * (rooted[s/2] + 1) / 2;\n}\n\nint main()\n{\n\txint n;\n\tfor (n = 1; n < MAX_N; n++) {\n\t\ttree(0, n, 1, 1, n);\n\t\tbicenter(n);\n\t\tprintf(\"%\"FMT\":\u00a0%\"FMT\"\\n\", n, unrooted[n]);\n\t}\n\n\treturn 0;\n}", "gold": "import java.math.BigInteger;\nimport java.util.Arrays;\n\nclass Test {\n    final static int nMax = 250;\n    final static int nBranches = 4;\n\n    static BigInteger[] rooted = new BigInteger[nMax + 1];\n    static BigInteger[] unrooted = new BigInteger[nMax + 1];\n    static BigInteger[] c = new BigInteger[nBranches];\n\n    static void tree(int br, int n, int l, int inSum, BigInteger cnt) {\n        int sum = inSum;\n        for (int b = br + 1; b <= nBranches; b++) {\n            sum += n;\n\n            if (sum > nMax || (l * 2 >= sum && b >= nBranches))\n                return;\n\n            BigInteger tmp = rooted[n];\n            if (b == br + 1) {\n                c[br] = tmp.multiply(cnt);\n            } else {\n                c[br] = c[br].multiply(tmp.add(BigInteger.valueOf(b - br - 1)));\n                c[br] = c[br].divide(BigInteger.valueOf(b - br));\n            }\n\n            if (l * 2 < sum)\n                unrooted[sum] = unrooted[sum].add(c[br]);\n\n            if (b < nBranches)\n                rooted[sum] = rooted[sum].add(c[br]);\n\n            for (int m = n - 1; m > 0; m--)\n                tree(b, m, l, sum, c[br]);\n        }\n    }\n\n    static void bicenter(int s) {\n        if ((s & 1) == 0) {\n            BigInteger tmp = rooted[s / 2];\n            tmp = tmp.add(BigInteger.ONE).multiply(rooted[s / 2]);\n            unrooted[s] = unrooted[s].add(tmp.shiftRight(1));\n        }\n    }\n\n    public static void main(String[] args) {\n        Arrays.fill(rooted, BigInteger.ZERO);\n        Arrays.fill(unrooted, BigInteger.ZERO);\n        rooted[0] = rooted[1] = BigInteger.ONE;\n        unrooted[0] = unrooted[1] = BigInteger.ONE;\n\n        for (int n = 1; n <= nMax; n++) {\n            tree(0, n, n, 1, BigInteger.ONE);\n            bicenter(n);\n            System.out.printf(\"%d: %s%n\", n, unrooted[n]);\n        }\n    }\n}", "llm": "cs-22b", "output": "import java.math.BigInteger;\n\npublic class Main {\n    static final int MAX_N = 33;\n    static final int BRANCH = 4;\n\n    static BigInteger[] rooted = new BigInteger[MAX_N];\n    static BigInteger[] unrooted = new BigInteger[MAX_N];\n\n    static BigInteger choose(BigInteger m, int k) {\n        BigInteger r = m;\n        for (int i = 1; i < k; i++) {\n            r = r.multiply(m.add(BigInteger.valueOf(i))).divide(BigInteger.valueOf(i + 1));\n        }\n        return r;\n    }\n\n    static void tree(int br, int n, BigInteger cnt, int sum, int l) {\n        for (int b = br + 1; b <= BRANCH; b++) {\n            int s = sum + (b - br) * n;\n            if (s >= MAX_N) return;\n\n            BigInteger c = choose(rooted[n], b - br).multiply(cnt);\n\n            if (l * 2 < s) unrooted[s] = unrooted[s].add(c);\n\n            if (b == BRANCH) return;\n            rooted[s] = rooted[s].add(c);\n\n            for (int m = n; --m > 0; ) tree(b, m, c, s, l);\n        }\n    }\n\n    static void bicenter(int s) {\n        if (s % 2 != 0) return;\n\n        unrooted[s] = unrooted[s].add(rooted[s / 2].multiply(rooted[s / 2].add(BigInteger.ONE)).divide(BigInteger.valueOf(2)));\n    }\n\n    public static void main(String[] args) {\n        for (int i = 0; i < MAX_N; i++) {\n            rooted[i] = BigInteger.ZERO;\n            unrooted[i] = BigInteger.ZERO;\n        }\n        rooted[0] = BigInteger.ONE;\n        rooted[1] = BigInteger.ONE;\n        unrooted[0] = BigInteger.ONE;\n        unrooted[1] = BigInteger.ONE;\n\n        for (int n = 1; n < MAX_N; n++) {\n            tree(0, n, BigInteger.ONE, 1, n);\n            bicenter(n);\n            System.out.println(n + \": \" + unrooted[n]);\n        }\n    }\n}", "index": 41}
{"lang": "C, Python", "input": "#include <stdio.h>\n\ntypedef char pin_t;\n#define IN const pin_t *\n#define OUT pin_t *\n#define PIN(X) pin_t _##X; pin_t *X = & _##X;\n#define V(X) (*(X))\n\n\n#define NOT(X) (~(X)&1)\n\n\n#define XOR(X,Y) ((NOT(X)&(Y)) | ((X)&NOT(Y)))\n\nvoid halfadder(IN a, IN b, OUT s, OUT c)\n{\n  V(s) = XOR(V(a), V(b));\n  V(c) = V(a) & V(b);\n}\n\nvoid fulladder(IN a, IN b, IN ic, OUT s, OUT oc)\n{\n  PIN(ps); PIN(pc); PIN(tc);\n\n  halfadder(a, b, ps, pc);\n  halfadder(ps, ic, s, tc);\n  V(oc) = V(tc) | V(pc);\n}\n\nvoid fourbitsadder(IN a0, IN a1, IN a2, IN a3,\n\t\t   IN b0, IN b1, IN b2, IN b3,\n\t\t   OUT o0, OUT o1, OUT o2, OUT o3,\n\t\t   OUT overflow)\n{\n  PIN(zero); V(zero) = 0;\n  PIN(tc0); PIN(tc1); PIN(tc2);\n\n  fulladder(a0, b0, zero, o0, tc0);\n  fulladder(a1, b1, tc0,  o1, tc1);\n  fulladder(a2, b2, tc1,  o2, tc2);\n  fulladder(a3, b3, tc2,  o3, overflow);\n}\n\n\nint main()\n{\n  PIN(a0); PIN(a1); PIN(a2); PIN(a3);\n  PIN(b0); PIN(b1); PIN(b2); PIN(b3);\n  PIN(s0); PIN(s1); PIN(s2); PIN(s3);\n  PIN(overflow);\n\n  V(a3) = 0; V(b3) = 1;\n  V(a2) = 0; V(b2) = 1;\n  V(a1) = 1; V(b1) = 1;\n  V(a0) = 0; V(b0) = 0;\n\n  fourbitsadder(a0, a1, a2, a3, \n\t\tb0, b1, b2, b3,\n\t\ts0, s1, s2, s3, \n\t\toverflow);\n\n  printf(\"%d%d%d%d + %d%d%d%d = %d%d%d%d, overflow = %d\\n\",\n\t V(a3), V(a2), V(a1), V(a0),\n\t V(b3), V(b2), V(b1), V(b0),\n\t V(s3), V(s2), V(s1), V(s0),\n\t V(overflow));\n  \n  return 0;\n}", "gold": "from myhdl import *\n\n\n\n@block\ndef NOTgate( a,  q ):   \n   \n   @always_comb   \n   def NOTgateLogic():\n      q.next = not a\n\n   return NOTgateLogic   \n\n\n@block\ndef ANDgate( a, b,  q ):\n   \n   @always_comb \n   def ANDgateLogic():\n      q.next = a and b\n\n   return ANDgateLogic\n\n\n@block\ndef ORgate( a, b,  q ):\n      \n   @always_comb  \n   def ORgateLogic():\n      q.next = a or b\n\n   return ORgateLogic\n\n\n\n\n@block\ndef XORgate( a, b,  q ):\n      \n   \n   nota, notb, annotb, bnnota = [Signal(bool(0)) for i in range(4)]\n   \n   inv0 = NOTgate( a,  nota )\n   inv1 = NOTgate( b,  notb )\n   and2a = ANDgate( a, notb,  annotb )\n   and2b = ANDgate( b, nota,  bnnota )\n   or2a = ORgate( annotb, bnnota,  q )\n\n   return inv0, inv1, and2a, and2b, or2a\n\n\n@block\ndef HalfAdder( in_a, in_b,  summ, carry ):\n    \n   and2a =  ANDgate(in_a, in_b,  carry)\n   xor2a =  XORgate(in_a, in_b,  summ)\n\n   return and2a, xor2a\n\n\n@block\ndef FullAdder( fa_c0, fa_a, fa_b,  fa_s, fa_c1 ):\n   \n\n   ha1_s, ha1_c1, ha2_c1 = [Signal(bool(0)) for i in range(3)]\n\n   HalfAdder01 = HalfAdder( fa_c0, fa_a,  ha1_s, ha1_c1 )\n   HalfAdder02 = HalfAdder( ha1_s, fa_b,  fa_s,  ha2_c1 )\n   or2a = ORgate(ha1_c1, ha2_c1,  fa_c1)\n\n   return HalfAdder01, HalfAdder02, or2a\n\n\n@block\ndef Adder4b( ina, inb,  cOut, sum4):\n    \n\n   cl = [Signal(bool()) for i in range(0,4)]  \n   sl = [Signal(bool()) for i in range(4)]  \n\n   HalfAdder0 = HalfAdder(        ina(0), inb(0),  sl[0], cl[1] )\n   FullAdder1 = FullAdder( cl[1], ina(1), inb(1),  sl[1], cl[2] ) \n   FullAdder2 = FullAdder( cl[2], ina(2), inb(2),  sl[2], cl[3] ) \n   FullAdder3 = FullAdder( cl[3], ina(3), inb(3),  sl[3], cOut ) \n\n   sc = ConcatSignal(*reversed(sl))  \n\n   @always_comb\n   def list2intbv():\n      sum4.next = sc  \n\n   return HalfAdder0, FullAdder1, FullAdder2, FullAdder3, list2intbv\n\n\n\nt_co, t_s, t_a, t_b, dbug =  [Signal(bool(0)) for i in range(5)]\nina4, inb4, sum4 =  [Signal(intbv(0)[4:])  for i in range(3)]\n\nfrom random import randrange \n\n@block\ndef Test_Adder4b():\n   \n   dut = Adder4b( ina4, inb4,  t_co, sum4 )\n\n   @instance\n   def check():\n      print( \"\\n      b   a   |  c1    s   \\n     -------------------\" )\n      for i in range(15):\n         ina4.next, inb4.next = randrange(2**4), randrange(2**4)\n         yield delay(5)\n         print( \"     %2d  %2d   |  %2d   %2d     \" \\\n                % (ina4,inb4, t_co,sum4) )\n         assert t_co * 16 + sum4 == ina4 + inb4  \n      print()\n\n   return dut, check\n\n\n\n\ndef main():\n   simInst = Test_Adder4b()\n   simInst.name = \"mySimInst\"\n   simInst.config_sim(trace=True)  \n   simInst.run_sim(duration=None)\n\n   inst = Adder4b( ina4, inb4,  t_co, sum4 )  \n   inst.convert(hdl='VHDL')  \n   inst.convert(hdl='Verilog')  \n\n    \nif __name__ == '__main__':\n   main()", "llm": "cl-13b", "output": "def halfadder(a, b, s, c):\n    s = a ^ b\n    c = a & b\n\ndef fulladder(a, b, ic, s, oc):\n    ps = 0\n    pc = 0\n    halfadder(a, b, ps, pc)\n    halfadder(ps, ic, s, oc)\n    oc = oc | pc\n\ndef fourbitsadder(a0, a1, a2, a3, b0, b1, b2, b3, o0, o1, o2, o3, overflow):\n    zero = 0\n    tc0 = 0\n    tc1 = 0\n    tc2 = 0\n    fulladder(a0, b0, zero, o0, tc0)\n    fulladder(a1, b1, tc0, o1, tc1)\n    fulladder(a2, b2, tc1, o2, tc2)\n    fulladder(a3, b3, tc2, o3, overflow)\n\na3 = 0\nb3 = 1\na2 = 0\nb2 = 1\na1 = 1\nb1 = 1\na0 = 0\nb0 = 0\n\ns0 = 0\ns1 = 0\ns2 = 0\ns3 = 0\noverflow = 0\n\nfourbitsadder(a0, a1, a2, a3, b0, b1, b2, b3, s0, s1, s2, s3, overflow)\n\nprint(f\"{a3}{a2}{a1}{a0} + {b3}{b2}{b1}{b0} = {s3}{s2}{s1}{s0}, overflow = {overflow}\")", "index": 42}
{"lang": "C, Python", "input": "#include <stdio.h>\n\ntypedef char pin_t;\n#define IN const pin_t *\n#define OUT pin_t *\n#define PIN(X) pin_t _##X; pin_t *X = & _##X;\n#define V(X) (*(X))\n\n\n#define NOT(X) (~(X)&1)\n\n\n#define XOR(X,Y) ((NOT(X)&(Y)) | ((X)&NOT(Y)))\n\nvoid halfadder(IN a, IN b, OUT s, OUT c)\n{\n  V(s) = XOR(V(a), V(b));\n  V(c) = V(a) & V(b);\n}\n\nvoid fulladder(IN a, IN b, IN ic, OUT s, OUT oc)\n{\n  PIN(ps); PIN(pc); PIN(tc);\n\n  halfadder(a, b, ps, pc);\n  halfadder(ps, ic, s, tc);\n  V(oc) = V(tc) | V(pc);\n}\n\nvoid fourbitsadder(IN a0, IN a1, IN a2, IN a3,\n\t\t   IN b0, IN b1, IN b2, IN b3,\n\t\t   OUT o0, OUT o1, OUT o2, OUT o3,\n\t\t   OUT overflow)\n{\n  PIN(zero); V(zero) = 0;\n  PIN(tc0); PIN(tc1); PIN(tc2);\n\n  fulladder(a0, b0, zero, o0, tc0);\n  fulladder(a1, b1, tc0,  o1, tc1);\n  fulladder(a2, b2, tc1,  o2, tc2);\n  fulladder(a3, b3, tc2,  o3, overflow);\n}\n\n\nint main()\n{\n  PIN(a0); PIN(a1); PIN(a2); PIN(a3);\n  PIN(b0); PIN(b1); PIN(b2); PIN(b3);\n  PIN(s0); PIN(s1); PIN(s2); PIN(s3);\n  PIN(overflow);\n\n  V(a3) = 0; V(b3) = 1;\n  V(a2) = 0; V(b2) = 1;\n  V(a1) = 1; V(b1) = 1;\n  V(a0) = 0; V(b0) = 0;\n\n  fourbitsadder(a0, a1, a2, a3, \n\t\tb0, b1, b2, b3,\n\t\ts0, s1, s2, s3, \n\t\toverflow);\n\n  printf(\"%d%d%d%d + %d%d%d%d = %d%d%d%d, overflow = %d\\n\",\n\t V(a3), V(a2), V(a1), V(a0),\n\t V(b3), V(b2), V(b1), V(b0),\n\t V(s3), V(s2), V(s1), V(s0),\n\t V(overflow));\n  \n  return 0;\n}", "gold": "from myhdl import *\n\n\n\n@block\ndef NOTgate( a,  q ):   \n   \n   @always_comb   \n   def NOTgateLogic():\n      q.next = not a\n\n   return NOTgateLogic   \n\n\n@block\ndef ANDgate( a, b,  q ):\n   \n   @always_comb \n   def ANDgateLogic():\n      q.next = a and b\n\n   return ANDgateLogic\n\n\n@block\ndef ORgate( a, b,  q ):\n      \n   @always_comb  \n   def ORgateLogic():\n      q.next = a or b\n\n   return ORgateLogic\n\n\n\n\n@block\ndef XORgate( a, b,  q ):\n      \n   \n   nota, notb, annotb, bnnota = [Signal(bool(0)) for i in range(4)]\n   \n   inv0 = NOTgate( a,  nota )\n   inv1 = NOTgate( b,  notb )\n   and2a = ANDgate( a, notb,  annotb )\n   and2b = ANDgate( b, nota,  bnnota )\n   or2a = ORgate( annotb, bnnota,  q )\n\n   return inv0, inv1, and2a, and2b, or2a\n\n\n@block\ndef HalfAdder( in_a, in_b,  summ, carry ):\n    \n   and2a =  ANDgate(in_a, in_b,  carry)\n   xor2a =  XORgate(in_a, in_b,  summ)\n\n   return and2a, xor2a\n\n\n@block\ndef FullAdder( fa_c0, fa_a, fa_b,  fa_s, fa_c1 ):\n   \n\n   ha1_s, ha1_c1, ha2_c1 = [Signal(bool(0)) for i in range(3)]\n\n   HalfAdder01 = HalfAdder( fa_c0, fa_a,  ha1_s, ha1_c1 )\n   HalfAdder02 = HalfAdder( ha1_s, fa_b,  fa_s,  ha2_c1 )\n   or2a = ORgate(ha1_c1, ha2_c1,  fa_c1)\n\n   return HalfAdder01, HalfAdder02, or2a\n\n\n@block\ndef Adder4b( ina, inb,  cOut, sum4):\n    \n\n   cl = [Signal(bool()) for i in range(0,4)]  \n   sl = [Signal(bool()) for i in range(4)]  \n\n   HalfAdder0 = HalfAdder(        ina(0), inb(0),  sl[0], cl[1] )\n   FullAdder1 = FullAdder( cl[1], ina(1), inb(1),  sl[1], cl[2] ) \n   FullAdder2 = FullAdder( cl[2], ina(2), inb(2),  sl[2], cl[3] ) \n   FullAdder3 = FullAdder( cl[3], ina(3), inb(3),  sl[3], cOut ) \n\n   sc = ConcatSignal(*reversed(sl))  \n\n   @always_comb\n   def list2intbv():\n      sum4.next = sc  \n\n   return HalfAdder0, FullAdder1, FullAdder2, FullAdder3, list2intbv\n\n\n\nt_co, t_s, t_a, t_b, dbug =  [Signal(bool(0)) for i in range(5)]\nina4, inb4, sum4 =  [Signal(intbv(0)[4:])  for i in range(3)]\n\nfrom random import randrange \n\n@block\ndef Test_Adder4b():\n   \n   dut = Adder4b( ina4, inb4,  t_co, sum4 )\n\n   @instance\n   def check():\n      print( \"\\n      b   a   |  c1    s   \\n     -------------------\" )\n      for i in range(15):\n         ina4.next, inb4.next = randrange(2**4), randrange(2**4)\n         yield delay(5)\n         print( \"     %2d  %2d   |  %2d   %2d     \" \\\n                % (ina4,inb4, t_co,sum4) )\n         assert t_co * 16 + sum4 == ina4 + inb4  \n      print()\n\n   return dut, check\n\n\n\n\ndef main():\n   simInst = Test_Adder4b()\n   simInst.name = \"mySimInst\"\n   simInst.config_sim(trace=True)  \n   simInst.run_sim(duration=None)\n\n   inst = Adder4b( ina4, inb4,  t_co, sum4 )  \n   inst.convert(hdl='VHDL')  \n   inst.convert(hdl='Verilog')  \n\n    \nif __name__ == '__main__':\n   main()", "llm": "dsc-33b", "output": "def NOT(X):\n    return ~X & 1\n\ndef XOR(X, Y):\n    return NOT(X) & Y | X & NOT(Y)\n\ndef halfadder(a, b, s, c):\n    s[:] = [XOR(a[0], b[0])]\n    c[:] = [a[0] & b[0]]\n\ndef fulladder(a, b, ic, s, oc):\n    ps = [0]\n    pc = [0]\n    tc = [0]\n\n    halfadder(a, b, ps, pc)\n    halfadder(ps, ic, s, tc)\n    oc[:] = [tc[0] | pc[0]]\n\ndef fourbitsadder(a0, a1, a2, a3, b0, b1, b2, b3, o0, o1, o2, o3, overflow):\n    zero = [0]\n    tc0 = [0]\n    tc1 = [0]\n    tc2 = [0]\n\n    fulladder([a0], [a1], zero, o0, tc0)\n    fulladder([a1], [b1], tc0, o1, tc1)\n    fulladder([a2], [b2], tc1, o2, tc2)\n    fulladder([a3], [b3], tc2, o3, overflow)\n\na3 = [0]\na2 = [0]\na1 = [1]\na0 = [0]\nb3 = [1]\nb2 = [1]\nb1 = [1]\nb0 = [0]\ns0 = [0]\ns1 = [0]\ns2 = [0]\ns3 = [0]\noverflow = [0]\n\nfourbitsadder(a0, a1, a2, a3, b0, b1, b2, b3, s0, s1, s2, s3, overflow)\n\nprint(f\"{a3[0]}{a2[0]}{a1[0]}{a0[0]} + {b3[0]}{b2[0]}{b1[0]}{b0[0]} = {s3[0]}{s2[0]}{s1[0]}{s0[0]}, overflow = {overflow[0]}\")", "index": 43}
{"lang": "C, Python", "input": "#include <stdio.h>\n\ntypedef char pin_t;\n#define IN const pin_t *\n#define OUT pin_t *\n#define PIN(X) pin_t _##X; pin_t *X = & _##X;\n#define V(X) (*(X))\n\n\n#define NOT(X) (~(X)&1)\n\n\n#define XOR(X,Y) ((NOT(X)&(Y)) | ((X)&NOT(Y)))\n\nvoid halfadder(IN a, IN b, OUT s, OUT c)\n{\n  V(s) = XOR(V(a), V(b));\n  V(c) = V(a) & V(b);\n}\n\nvoid fulladder(IN a, IN b, IN ic, OUT s, OUT oc)\n{\n  PIN(ps); PIN(pc); PIN(tc);\n\n  halfadder(a, b, ps, pc);\n  halfadder(ps, ic, s, tc);\n  V(oc) = V(tc) | V(pc);\n}\n\nvoid fourbitsadder(IN a0, IN a1, IN a2, IN a3,\n\t\t   IN b0, IN b1, IN b2, IN b3,\n\t\t   OUT o0, OUT o1, OUT o2, OUT o3,\n\t\t   OUT overflow)\n{\n  PIN(zero); V(zero) = 0;\n  PIN(tc0); PIN(tc1); PIN(tc2);\n\n  fulladder(a0, b0, zero, o0, tc0);\n  fulladder(a1, b1, tc0,  o1, tc1);\n  fulladder(a2, b2, tc1,  o2, tc2);\n  fulladder(a3, b3, tc2,  o3, overflow);\n}\n\n\nint main()\n{\n  PIN(a0); PIN(a1); PIN(a2); PIN(a3);\n  PIN(b0); PIN(b1); PIN(b2); PIN(b3);\n  PIN(s0); PIN(s1); PIN(s2); PIN(s3);\n  PIN(overflow);\n\n  V(a3) = 0; V(b3) = 1;\n  V(a2) = 0; V(b2) = 1;\n  V(a1) = 1; V(b1) = 1;\n  V(a0) = 0; V(b0) = 0;\n\n  fourbitsadder(a0, a1, a2, a3, \n\t\tb0, b1, b2, b3,\n\t\ts0, s1, s2, s3, \n\t\toverflow);\n\n  printf(\"%d%d%d%d + %d%d%d%d = %d%d%d%d, overflow = %d\\n\",\n\t V(a3), V(a2), V(a1), V(a0),\n\t V(b3), V(b2), V(b1), V(b0),\n\t V(s3), V(s2), V(s1), V(s0),\n\t V(overflow));\n  \n  return 0;\n}", "gold": "from myhdl import *\n\n\n\n@block\ndef NOTgate( a,  q ):   \n   \n   @always_comb   \n   def NOTgateLogic():\n      q.next = not a\n\n   return NOTgateLogic   \n\n\n@block\ndef ANDgate( a, b,  q ):\n   \n   @always_comb \n   def ANDgateLogic():\n      q.next = a and b\n\n   return ANDgateLogic\n\n\n@block\ndef ORgate( a, b,  q ):\n      \n   @always_comb  \n   def ORgateLogic():\n      q.next = a or b\n\n   return ORgateLogic\n\n\n\n\n@block\ndef XORgate( a, b,  q ):\n      \n   \n   nota, notb, annotb, bnnota = [Signal(bool(0)) for i in range(4)]\n   \n   inv0 = NOTgate( a,  nota )\n   inv1 = NOTgate( b,  notb )\n   and2a = ANDgate( a, notb,  annotb )\n   and2b = ANDgate( b, nota,  bnnota )\n   or2a = ORgate( annotb, bnnota,  q )\n\n   return inv0, inv1, and2a, and2b, or2a\n\n\n@block\ndef HalfAdder( in_a, in_b,  summ, carry ):\n    \n   and2a =  ANDgate(in_a, in_b,  carry)\n   xor2a =  XORgate(in_a, in_b,  summ)\n\n   return and2a, xor2a\n\n\n@block\ndef FullAdder( fa_c0, fa_a, fa_b,  fa_s, fa_c1 ):\n   \n\n   ha1_s, ha1_c1, ha2_c1 = [Signal(bool(0)) for i in range(3)]\n\n   HalfAdder01 = HalfAdder( fa_c0, fa_a,  ha1_s, ha1_c1 )\n   HalfAdder02 = HalfAdder( ha1_s, fa_b,  fa_s,  ha2_c1 )\n   or2a = ORgate(ha1_c1, ha2_c1,  fa_c1)\n\n   return HalfAdder01, HalfAdder02, or2a\n\n\n@block\ndef Adder4b( ina, inb,  cOut, sum4):\n    \n\n   cl = [Signal(bool()) for i in range(0,4)]  \n   sl = [Signal(bool()) for i in range(4)]  \n\n   HalfAdder0 = HalfAdder(        ina(0), inb(0),  sl[0], cl[1] )\n   FullAdder1 = FullAdder( cl[1], ina(1), inb(1),  sl[1], cl[2] ) \n   FullAdder2 = FullAdder( cl[2], ina(2), inb(2),  sl[2], cl[3] ) \n   FullAdder3 = FullAdder( cl[3], ina(3), inb(3),  sl[3], cOut ) \n\n   sc = ConcatSignal(*reversed(sl))  \n\n   @always_comb\n   def list2intbv():\n      sum4.next = sc  \n\n   return HalfAdder0, FullAdder1, FullAdder2, FullAdder3, list2intbv\n\n\n\nt_co, t_s, t_a, t_b, dbug =  [Signal(bool(0)) for i in range(5)]\nina4, inb4, sum4 =  [Signal(intbv(0)[4:])  for i in range(3)]\n\nfrom random import randrange \n\n@block\ndef Test_Adder4b():\n   \n   dut = Adder4b( ina4, inb4,  t_co, sum4 )\n\n   @instance\n   def check():\n      print( \"\\n      b   a   |  c1    s   \\n     -------------------\" )\n      for i in range(15):\n         ina4.next, inb4.next = randrange(2**4), randrange(2**4)\n         yield delay(5)\n         print( \"     %2d  %2d   |  %2d   %2d     \" \\\n                % (ina4,inb4, t_co,sum4) )\n         assert t_co * 16 + sum4 == ina4 + inb4  \n      print()\n\n   return dut, check\n\n\n\n\ndef main():\n   simInst = Test_Adder4b()\n   simInst.name = \"mySimInst\"\n   simInst.config_sim(trace=True)  \n   simInst.run_sim(duration=None)\n\n   inst = Adder4b( ina4, inb4,  t_co, sum4 )  \n   inst.convert(hdl='VHDL')  \n   inst.convert(hdl='Verilog')  \n\n    \nif __name__ == '__main__':\n   main()", "llm": "cs-22b", "output": "def NOT(x):\n    return ~x & 1\n\ndef XOR(x, y):\n    return (NOT(x) & y) | (x & NOT(y))\n\ndef halfadder(a, b):\n    s = XOR(a, b)\n    c = a & b\n    return s, c\n\ndef fulladder(a, b, ic):\n    ps, pc = halfadder(a, b)\n    s, tc = halfadder(ps, ic)\n    oc = tc | pc\n    return s, oc\n\ndef fourbitsadder(a0, a1, a2, a3, b0, b1, b2, b3):\n    zero = 0\n    tc0 = 0\n    tc1 = 0\n    tc2 = 0\n\n    o0, tc0 = fulladder(a0, b0, zero)\n    o1, tc1 = fulladder(a1, b1, tc0)\n    o2, tc2 = fulladder(a2, b2, tc1)\n    o3, overflow = fulladder(a3, b3, tc2)\n\n    return o0, o1, o2, o3, overflow\n\na3 = 0\nb3 = 1\na2 = 0\nb2 = 1\na1 = 1\nb1 = 1\na0 = 0\nb0 = 0\n\ns0, s1, s2, s3, overflow = fourbitsadder(a0, a1, a2, a3, b0, b1, b2, b3)\n\nprint(f\"{a3}{a2}{a1}{a0} + {b3}{b2}{b1}{b0} = {s3}{s2}{s1}{s0}, overflow = {overflow}\")", "index": 44}
{"lang": "C, C++", "input": "#include <stdio.h>\n#include <ctype.h>\n\nstatic int \nowp(int odd)\n{\n        int ch, ret;\n        ch = getc(stdin);\n        if (!odd) {\n                putc(ch, stdout);\n                if (ch == EOF || ch == '.')\n                        return EOF;\n                if (ispunct(ch))\n                        return 0;\n                owp(odd);\n                return 0;\n        } else {\n                if (ispunct(ch))\n                        return ch; \n                ret = owp(odd);\n                putc(ch, stdout);\n                return ret;\n        }\n}\n\nint\nmain(int argc, char **argv)\n{\n        int ch = 1;\n        while ((ch = owp(!ch)) != EOF) {\n                if (ch)\n                        putc(ch, stdout);\n                if (ch == '.')\n                        break;\n        }\n        return 0;\n}", "gold": "#include <iostream>\n#include <cctype>\n#include <functional>\n\nusing namespace std;\n\nbool odd()\n{\n  function<void ()> prev = []{};\n  while(true) {\n    int c = cin.get();\n    if (!isalpha(c)) {\n      prev();\n      cout.put(c);\n      return c != '.';\n    }\n    prev = [=] { cout.put(c); prev();  };\n  }\n}\n\nbool even() \n{\n  while(true) {\n    int c;\n    cout.put(c = cin.get());\n    if (!isalpha(c)) return c != '.';\n  }\n}\n\n\nint main()\n{\n  bool e = false;\n  while( e ? odd() : even() ) e = !e;\n  return 0;\n}", "llm": "cl-34b", "output": "#include <iostream>\n#include <cctype>\n\nstatic int owp(int odd) {\n    int ch, ret;\n    ch = std::cin.get();\n    if (!odd) {\n        std::cout << ch;\n        if (ch == EOF || ch == '.')\n            return EOF;\n        if (std::ispunct(ch))\n            return 0;\n        owp(odd);\n        return 0;\n    } else {\n        if (std::ispunct(ch))\n            return ch;\n        ret = owp(odd);\n        std::cout << ch;\n        return ret;\n    }\n}\n\nint main(int argc, char **argv) {\n    int ch = 1;\n    while ((ch = owp(!ch)) != EOF) {\n        if (ch)\n            std::cout << ch;\n        if (ch == '.')\n            break;\n    }\n    return 0;\n}", "index": 45}
{"lang": "C, C++", "input": "#include <stdio.h>\n#include <ctype.h>\n\nstatic int \nowp(int odd)\n{\n        int ch, ret;\n        ch = getc(stdin);\n        if (!odd) {\n                putc(ch, stdout);\n                if (ch == EOF || ch == '.')\n                        return EOF;\n                if (ispunct(ch))\n                        return 0;\n                owp(odd);\n                return 0;\n        } else {\n                if (ispunct(ch))\n                        return ch; \n                ret = owp(odd);\n                putc(ch, stdout);\n                return ret;\n        }\n}\n\nint\nmain(int argc, char **argv)\n{\n        int ch = 1;\n        while ((ch = owp(!ch)) != EOF) {\n                if (ch)\n                        putc(ch, stdout);\n                if (ch == '.')\n                        break;\n        }\n        return 0;\n}", "gold": "#include <iostream>\n#include <cctype>\n#include <functional>\n\nusing namespace std;\n\nbool odd()\n{\n  function<void ()> prev = []{};\n  while(true) {\n    int c = cin.get();\n    if (!isalpha(c)) {\n      prev();\n      cout.put(c);\n      return c != '.';\n    }\n    prev = [=] { cout.put(c); prev();  };\n  }\n}\n\nbool even() \n{\n  while(true) {\n    int c;\n    cout.put(c = cin.get());\n    if (!isalpha(c)) return c != '.';\n  }\n}\n\n\nint main()\n{\n  bool e = false;\n  while( e ? odd() : even() ) e = !e;\n  return 0;\n}", "llm": "q2.5-1.5b", "output": "#include <iostream>\n#include <cctype>\n\nstatic int \nowp(int odd)\n{\n        int ch, ret;\n        ch = std::cin.get();\n        if (!odd) {\n                std::cout.put(ch);\n                if (ch == EOF || ch == '.')\n                        return EOF;\n                if (std::ispunct(ch))\n                        return 0;\n                owp(odd);\n                return 0;\n        } else {\n                if (std::ispunct(ch))\n                        return ch; \n                ret = owp(odd);\n                std::cout.put(ch);\n                return ret;\n        }\n}\n\nint\nmain(int argc, char **argv)\n{\n        int ch = 1;\n        while ((ch = owp(!ch)) != EOF) {\n                if (ch)\n                        std::cout.put(ch);\n                if (ch == '.')\n                        break;\n        }\n        return 0;\n}", "index": 46}
{"lang": "C, C++", "input": "#include <stdio.h>\n#include <ctype.h>\n\nstatic int \nowp(int odd)\n{\n        int ch, ret;\n        ch = getc(stdin);\n        if (!odd) {\n                putc(ch, stdout);\n                if (ch == EOF || ch == '.')\n                        return EOF;\n                if (ispunct(ch))\n                        return 0;\n                owp(odd);\n                return 0;\n        } else {\n                if (ispunct(ch))\n                        return ch; \n                ret = owp(odd);\n                putc(ch, stdout);\n                return ret;\n        }\n}\n\nint\nmain(int argc, char **argv)\n{\n        int ch = 1;\n        while ((ch = owp(!ch)) != EOF) {\n                if (ch)\n                        putc(ch, stdout);\n                if (ch == '.')\n                        break;\n        }\n        return 0;\n}", "gold": "#include <iostream>\n#include <cctype>\n#include <functional>\n\nusing namespace std;\n\nbool odd()\n{\n  function<void ()> prev = []{};\n  while(true) {\n    int c = cin.get();\n    if (!isalpha(c)) {\n      prev();\n      cout.put(c);\n      return c != '.';\n    }\n    prev = [=] { cout.put(c); prev();  };\n  }\n}\n\nbool even() \n{\n  while(true) {\n    int c;\n    cout.put(c = cin.get());\n    if (!isalpha(c)) return c != '.';\n  }\n}\n\n\nint main()\n{\n  bool e = false;\n  while( e ? odd() : even() ) e = !e;\n  return 0;\n}", "llm": "magic-7b", "output": "#include <iostream>\n#include <cctype>\n\nstatic int \nowp(int odd)\n{\n        int ch, ret;\n        ch = std::cin.get();\n        if (!odd) {\n                std::cout.put(ch);\n                if (ch == EOF || ch == '.')\n                        return EOF;\n                if (ispunct(ch))\n                        return 0;\n                owp(odd);\n                return 0;\n        } else {\n                if (ispunct(ch))\n                        return ch; \n                ret = owp(odd);\n                std::cout.put(ch);\n                return ret;\n        }\n}\n\nint\nmain(int argc, char **argv)\n{\n        int ch = 1;\n        while ((ch = owp(!ch)) != EOF) {\n                if (ch)\n                        std::cout.put(ch);\n                if (ch == '.')\n                        break;\n        }\n        return 0;\n}", "index": 47}
{"lang": "C, C++", "input": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <math.h>\n\nconst char *shades = \".:!*oe&#%@\";\n\ndouble light[3] = { 30, 30, -50 };\nvoid normalize(double * v)\n{\n        double len = sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);\n        v[0] /= len; v[1] /= len; v[2] /= len;\n}\n\ndouble dot(double *x, double *y)\n{\n        double d = x[0]*y[0] + x[1]*y[1] + x[2]*y[2];\n        return d < 0 ? -d : 0;\n}\n\nvoid draw_sphere(double R, double k, double ambient)\n{\n        int i, j, intensity;\n        double b;\n        double vec[3], x, y;\n        for (i = floor(-R); i <= ceil(R); i++) {\n                x = i + .5;\n                for (j = floor(-2 * R); j <= ceil(2 * R); j++) {\n                        y = j / 2. + .5;\n                        if (x * x + y * y <= R * R) {\n                                vec[0] = x;\n                                vec[1] = y;\n                                vec[2] = sqrt(R * R - x * x - y * y);\n                                normalize(vec);\n                                b = pow(dot(light, vec), k) + ambient;\n                                intensity = (1 - b) * (sizeof(shades) - 1);\n                                if (intensity < 0) intensity = 0;\n                                if (intensity >= sizeof(shades) - 1)\n                                        intensity = sizeof(shades) - 2;\n                                putchar(shades[intensity]);\n                        } else\n                                putchar(' ');\n                }\n                putchar('\\n');\n        }\n}\n\n\nint main()\n{\n        normalize(light);\n        draw_sphere(20, 4, .1);\n        draw_sphere(10, 2, .4);\n\n        return 0;\n}", "gold": "#include <QImage>\n#include <QPainter>\n\nint main() {\n    const QColor black(0, 0, 0);\n    const QColor white(255, 255, 255);\n\n    const int size = 300;\n    const double diameter = 0.6 * size;\n\n    QImage image(size, size, QImage::Format_RGB32);\n    QPainter painter(&image);\n    painter.setRenderHint(QPainter::Antialiasing);\n\n    QLinearGradient linearGradient(0, 0, 0, size);\n    linearGradient.setColorAt(0, white);\n    linearGradient.setColorAt(1, black);\n\n    QBrush brush(linearGradient);\n    painter.fillRect(QRect(0, 0, size, size), brush);\n\n    QPointF point1(0.4 * size, 0.4 * size);\n    QPointF point2(0.45 * size, 0.4 * size);\n    QRadialGradient radialGradient(point1, size * 0.5, point2, size * 0.1);\n    radialGradient.setColorAt(0, white);\n    radialGradient.setColorAt(1, black);\n\n    QBrush brush2(radialGradient);\n    painter.setPen(Qt::NoPen);\n    painter.setBrush(brush2);\n    painter.drawEllipse(QRectF((size - diameter)/2, (size - diameter)/2, diameter, diameter));\n\n    image.save(\"sphere.png\");\n    return 0;\n}", "llm": "cl-7b", "output": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <math.h>\n\nconst char *shades = \".:!*oe&#%@\";\n\ndouble light[3] = { 30, 30, -50 };\nvoid normalize(double * v)\n{\n        double len = sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);\n        v[0] /= len; v[1] /= len; v[2] /= len;\n}\n\ndouble dot(double *x, double *y)\n{\n        double d = x[0]*y[0] + x[1]*y[1] + x[2]*y[2];\n        return d < 0 ? -d : 0;\n}\n\nvoid draw_sphere(double R, double k, double ambient)\n{\n        int i, j, intensity;\n        double b;\n        double vec[3], x, y;\n        for (i = floor(-R); i <= ceil(R); i++) {\n                x = i + .5;\n                for (j = floor(-2 * R); j <= ceil(2 * R); j++) {\n                        y = j / 2. + .5;\n                        if (x * x + y * y <= R * R) {\n                                vec[0] = x;\n                                vec[1] = y;\n                                vec[2] = sqrt(R * R - x * x - y * y);\n                                normalize(vec);\n                                b = pow(dot(light, vec), k) + ambient;\n                                intensity = (1 - b) * (sizeof(shades) - 1);\n                                if (intensity < 0) intensity = 0;\n                                if (intensity >= sizeof(shades) - 1)\n                                        intensity = sizeof(shades) - 2;\n                                putchar(shades[intensity]);\n                        } else\n                                putchar(' ');\n                }\n                putchar('\\n');\n        }\n}\n\n\nint main()\n{\n        normalize(light);\n        draw_sphere(20, 4, .1);\n        draw_sphere(10, 2, .4);\n\n        return 0;\n}", "index": 48}
{"lang": "C, C++", "input": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <math.h>\n\nconst char *shades = \".:!*oe&#%@\";\n\ndouble light[3] = { 30, 30, -50 };\nvoid normalize(double * v)\n{\n        double len = sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);\n        v[0] /= len; v[1] /= len; v[2] /= len;\n}\n\ndouble dot(double *x, double *y)\n{\n        double d = x[0]*y[0] + x[1]*y[1] + x[2]*y[2];\n        return d < 0 ? -d : 0;\n}\n\nvoid draw_sphere(double R, double k, double ambient)\n{\n        int i, j, intensity;\n        double b;\n        double vec[3], x, y;\n        for (i = floor(-R); i <= ceil(R); i++) {\n                x = i + .5;\n                for (j = floor(-2 * R); j <= ceil(2 * R); j++) {\n                        y = j / 2. + .5;\n                        if (x * x + y * y <= R * R) {\n                                vec[0] = x;\n                                vec[1] = y;\n                                vec[2] = sqrt(R * R - x * x - y * y);\n                                normalize(vec);\n                                b = pow(dot(light, vec), k) + ambient;\n                                intensity = (1 - b) * (sizeof(shades) - 1);\n                                if (intensity < 0) intensity = 0;\n                                if (intensity >= sizeof(shades) - 1)\n                                        intensity = sizeof(shades) - 2;\n                                putchar(shades[intensity]);\n                        } else\n                                putchar(' ');\n                }\n                putchar('\\n');\n        }\n}\n\n\nint main()\n{\n        normalize(light);\n        draw_sphere(20, 4, .1);\n        draw_sphere(10, 2, .4);\n\n        return 0;\n}", "gold": "#include <QImage>\n#include <QPainter>\n\nint main() {\n    const QColor black(0, 0, 0);\n    const QColor white(255, 255, 255);\n\n    const int size = 300;\n    const double diameter = 0.6 * size;\n\n    QImage image(size, size, QImage::Format_RGB32);\n    QPainter painter(&image);\n    painter.setRenderHint(QPainter::Antialiasing);\n\n    QLinearGradient linearGradient(0, 0, 0, size);\n    linearGradient.setColorAt(0, white);\n    linearGradient.setColorAt(1, black);\n\n    QBrush brush(linearGradient);\n    painter.fillRect(QRect(0, 0, size, size), brush);\n\n    QPointF point1(0.4 * size, 0.4 * size);\n    QPointF point2(0.45 * size, 0.4 * size);\n    QRadialGradient radialGradient(point1, size * 0.5, point2, size * 0.1);\n    radialGradient.setColorAt(0, white);\n    radialGradient.setColorAt(1, black);\n\n    QBrush brush2(radialGradient);\n    painter.setPen(Qt::NoPen);\n    painter.setBrush(brush2);\n    painter.drawEllipse(QRectF((size - diameter)/2, (size - diameter)/2, diameter, diameter));\n\n    image.save(\"sphere.png\");\n    return 0;\n}", "llm": "cl-13b", "output": "#include <iostream>\n#include <cmath>\n\nconst char *shades = \".:!*oe&#%@\";\n\ndouble light[3] = { 30, 30, -50 };\nvoid normalize(double * v)\n{\n        double len = sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);\n        v[0] /= len; v[1] /= len; v[2] /= len;\n}\n\ndouble dot(double *x, double *y)\n{\n        double d = x[0]*y[0] + x[1]*y[1] + x[2]*y[2];\n        return d < 0 ? -d : 0;\n}\n\nvoid draw_sphere(double R, double k, double ambient)\n{\n        int i, j, intensity;\n        double b;\n        double vec[3], x, y;\n        for (i = floor(-R); i <= ceil(R); i++) {\n                x = i + .5;\n                for (j = floor(-2 * R); j <= ceil(2 * R); j++) {\n                        y = j / 2. + .5;\n                        if (x * x + y * y <= R * R) {\n                                vec[0] = x;\n                                vec[1] = y;\n                                vec[2] = sqrt(R * R - x * x - y * y);\n                                normalize(vec);\n                                b = pow(dot(light, vec), k) + ambient;\n                                intensity = (1 - b) * (sizeof(shades) - 1);\n                                if (intensity < 0) intensity = 0;\n                                if (intensity >= sizeof(shades) - 1)\n                                        intensity = sizeof(shades) - 2;\n                                std::cout << shades[intensity];\n                        } else\n                                std::cout << ' ';\n                }\n                std::cout << '\\n';\n        }\n}\n\n\nint main()\n{\n        normalize(light);\n        draw_sphere(20, 4, .1);\n        draw_sphere(10, 2, .4);\n\n        return 0;\n}", "index": 49}
{"lang": "C, C++", "input": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <math.h>\n\nconst char *shades = \".:!*oe&#%@\";\n\ndouble light[3] = { 30, 30, -50 };\nvoid normalize(double * v)\n{\n        double len = sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);\n        v[0] /= len; v[1] /= len; v[2] /= len;\n}\n\ndouble dot(double *x, double *y)\n{\n        double d = x[0]*y[0] + x[1]*y[1] + x[2]*y[2];\n        return d < 0 ? -d : 0;\n}\n\nvoid draw_sphere(double R, double k, double ambient)\n{\n        int i, j, intensity;\n        double b;\n        double vec[3], x, y;\n        for (i = floor(-R); i <= ceil(R); i++) {\n                x = i + .5;\n                for (j = floor(-2 * R); j <= ceil(2 * R); j++) {\n                        y = j / 2. + .5;\n                        if (x * x + y * y <= R * R) {\n                                vec[0] = x;\n                                vec[1] = y;\n                                vec[2] = sqrt(R * R - x * x - y * y);\n                                normalize(vec);\n                                b = pow(dot(light, vec), k) + ambient;\n                                intensity = (1 - b) * (sizeof(shades) - 1);\n                                if (intensity < 0) intensity = 0;\n                                if (intensity >= sizeof(shades) - 1)\n                                        intensity = sizeof(shades) - 2;\n                                putchar(shades[intensity]);\n                        } else\n                                putchar(' ');\n                }\n                putchar('\\n');\n        }\n}\n\n\nint main()\n{\n        normalize(light);\n        draw_sphere(20, 4, .1);\n        draw_sphere(10, 2, .4);\n\n        return 0;\n}", "gold": "#include <QImage>\n#include <QPainter>\n\nint main() {\n    const QColor black(0, 0, 0);\n    const QColor white(255, 255, 255);\n\n    const int size = 300;\n    const double diameter = 0.6 * size;\n\n    QImage image(size, size, QImage::Format_RGB32);\n    QPainter painter(&image);\n    painter.setRenderHint(QPainter::Antialiasing);\n\n    QLinearGradient linearGradient(0, 0, 0, size);\n    linearGradient.setColorAt(0, white);\n    linearGradient.setColorAt(1, black);\n\n    QBrush brush(linearGradient);\n    painter.fillRect(QRect(0, 0, size, size), brush);\n\n    QPointF point1(0.4 * size, 0.4 * size);\n    QPointF point2(0.45 * size, 0.4 * size);\n    QRadialGradient radialGradient(point1, size * 0.5, point2, size * 0.1);\n    radialGradient.setColorAt(0, white);\n    radialGradient.setColorAt(1, black);\n\n    QBrush brush2(radialGradient);\n    painter.setPen(Qt::NoPen);\n    painter.setBrush(brush2);\n    painter.drawEllipse(QRectF((size - diameter)/2, (size - diameter)/2, diameter, diameter));\n\n    image.save(\"sphere.png\");\n    return 0;\n}", "llm": "dsc-33b", "output": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n\nconst char *shades = \".:-=+*#%@\";\n\ndouble light[3] = { 30, 30, -50 };\nvoid normalize(double * v)\n{\n        double len = sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);\n        v[0] /= len; v[1] /= len; v[2] /= len;\n}\n\ndouble dot(double *x, double *y)\n{\n        double d = x[0]*y[0] + x[1]*y[1] + x[2]*y[2];\n        return d < 0 ? -d : 0;\n}\n\nvoid draw_sphere(double R, double k, double ambient)\n{\n        int i, j, intensity;\n        double b;\n        double vec[3], x, y;\n        for (i = floor(-R); i <= ceil(R); i++) {\n                x = i + .5;\n                for (j = floor(-2 * R); j <= ceil(2 * R); j++) {\n                        y = j / 2. + .5;\n                        if (x * x + y * y <= R * R) {\n                                vec[0] = x;\n                                vec[1] = y;\n                                vec[2] = sqrt(R * R - x * x - y * y);\n                                normalize(vec);\n                                b = pow(dot(light, vec), k) + ambient;\n                                intensity = (1 - b) * (strlen(shades) - 1);\n                                if (intensity < 0) intensity = 0;\n                                if (intensity >= strlen(shades) - 1)\n                                        intensity = strlen(shades) - 2;\n                                putchar(shades[intensity]);\n                        } else\n                                putchar(' ');\n                }\n                putchar('\\n');\n        }\n}\n\n\nint main()\n{\n        normalize(light);\n        draw_sphere(20, 4, .1);\n        draw_sphere(10, 2, .4);\n\n        return 0;\n}", "index": 50}
{"lang": "C, Java", "input": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n \nlong long x, y, dx, dy, scale, clen, cscale;\ntypedef struct { double r, g, b; } rgb;\nrgb ** pix;\n \nvoid sc_up()\n{\n\tscale *= 2; x *= 2; y *= 2;\n\tcscale *= 3;\n}\n \nvoid h_rgb(long long x, long long y)\n{\n\trgb *p = &pix[y][x];\n \n#\tdefine SAT 1\n\tdouble h = 6.0 * clen / cscale;\n\tdouble VAL = 1;\n\tdouble c = SAT * VAL;\n\tdouble X = c * (1 - fabs(fmod(h, 2) - 1));\n \n\tswitch((int)h) {\n\tcase 0: p->r += c; p->g += X; return;\n\tcase 1:\tp->r += X; p->g += c; return;\n\tcase 2: p->g += c; p->b += X; return;\n\tcase 3: p->g += X; p->b += c; return;\n\tcase 4: p->r += X; p->b += c; return;\n\tdefault:\n\t\tp->r += c; p->b += X;\n\t}\n}\n \nvoid iter_string(const char * str, int d)\n{\n\tlong long len;\n\twhile (*str != '\\0') {\n\t\tswitch(*(str++)) {\n\t\tcase 'X':\n\t\t\tif (d)\titer_string(\"XHXVX\", d - 1);\n\t\t\telse{\n\t\t\t\tclen ++;\n\t\t\t\th_rgb(x/scale, y/scale);\n\t\t\t\tx += dx;\n\t\t\t\ty -= dy;\n\t\t\t}\n\t\t\tcontinue;\n\t\tcase 'V':\n\t\t\tlen = 1LLU << d;\n\t\t\twhile (len--) {\n\t\t\t\tclen ++;\n\t\t\t\th_rgb(x/scale, y/scale);\n\t\t\t\ty += dy;\n\t\t\t}\n\t\t\tcontinue;\n\t\tcase 'H':\n\t\t\tlen = 1LLU << d;\n\t\t\twhile(len --) {\n\t\t\t\tclen ++;\n\t\t\t\th_rgb(x/scale, y/scale);\n\t\t\t\tx -= dx;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t}\n}\n \nvoid sierp(long leng, int depth)\n{\n\tlong i;\n\tlong h = leng + 20, w = leng + 20;\n \n\t\n\trgb *buf = malloc(sizeof(rgb) * w * h);\n\tpix = malloc(sizeof(rgb *) * h);\n\tfor (i = 0; i < h; i++)\n\t\tpix[i] = buf + w * i;\n\tmemset(buf, 0, sizeof(rgb) * w * h);\n \n        \n\tx = y = 10; dx = leng; dy = leng; scale = 1; clen = 0; cscale = 3;\n\tfor (i = 0; i < depth; i++) sc_up();\n\titer_string(\"VXH\", depth);\n \n\t\n\tunsigned char *fpix = malloc(w * h * 3);\n\tdouble maxv = 0, *dbuf = (double*)buf;\n \n\tfor (i = 3 * w * h - 1; i >= 0; i--)\n\t\tif (dbuf[i] > maxv) maxv = dbuf[i];\n\tfor (i = 3 * h * w - 1; i >= 0; i--)\n\t\tfpix[i] = 255 * dbuf[i] / maxv;\n \n\tprintf(\"P6\\n%ld %ld\\n255\\n\", w, h);\n\tfflush(stdout); \n\tfwrite(fpix, h * w * 3, 1, stdout);\n}\n \nint main(int c, char ** v)\n{\n\tint size, depth;\n \n\tdepth  = (c > 1) ? atoi(v[1]) : 10;\n\tsize = 1 << depth;\n \n\tfprintf(stderr, \"size: %d depth: %d\\n\", size, depth);\n\tsierp(size, depth + 2);\n \n\treturn 0;\n}", "gold": "import javax.swing.*;\nimport java.awt.*;\n\n \n\nclass SierpinskyTriangle {\n\n\tpublic static void main(String[] args) {\n\t\tint i = 3;\t\t\n\t\tif(args.length >= 1) {\n\t\t\ttry {\n\t\t\t\ti = Integer.parseInt(args[0]);\n\t\t\t}\n\t\t\tcatch(NumberFormatException e) {\n\t\t\t\tSystem.out.println(\"Usage: 'java SierpinskyTriangle [level]'\\nNow setting level to \"+i);\n\t\t\t}\n\t\t}\n\t\tfinal int level = i;\n\n\t\tJFrame frame = new JFrame(\"Sierpinsky Triangle - Java\");\n\t\tframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\n\t\tJPanel panel = new JPanel() {\n\t\t\t@Override\n\t\t\tpublic void paintComponent(Graphics g) {\n\t\t\t\tg.setColor(Color.BLACK);\n\t\t\t\tdrawSierpinskyTriangle(level, 20, 20, 360, (Graphics2D)g);\n\t\t\t}\n\t\t};\n\n\t\tpanel.setPreferredSize(new Dimension(400, 400));\n\n\t\tframe.add(panel);\n\t\tframe.pack();\n\t\tframe.setResizable(false);\n\t\tframe.setLocationRelativeTo(null);\n\t\tframe.setVisible(true);\n\t}\n\n\tprivate static void drawSierpinskyTriangle(int level, int x, int y, int size, Graphics2D g) {\n\t\tif(level <= 0) return;\n\n\t\tg.drawLine(x, y, x+size, y);\n\t\tg.drawLine(x, y, x, y+size);\n\t\tg.drawLine(x+size, y, x, y+size);\n\n\t\tdrawSierpinskyTriangle(level-1, x, y, size/2, g);\n\t\tdrawSierpinskyTriangle(level-1, x+size/2, y, size/2, g);\n\t\tdrawSierpinskyTriangle(level-1, x, y+size/2, size/2, g);\n\t}\n}", "llm": "cl-13b", "output": "import java.util.Scanner;\n\npublic class SierpinskiTriangle {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int size = sc.nextInt();\n        int depth = sc.nextInt();\n        sierpinski(size, depth);\n    }\n\n    public static void sierpinski(int size, int depth) {\n        int[][] pix = new int[size][size];\n        int x = 0, y = 0, dx = size, dy = size, scale = 1, clen = 0, cscale = 3;\n\n        for (int i = 0; i < depth; i++) {\n            sc_up();\n        }\n\n        iter_string(\"VXH\", depth);\n\n        int[] fpix = new int[size * size * 3];\n        double maxv = 0, dbuf = (double[])pix;\n\n        for (int i = 3 * size * size - 1; i >= 0; i--) {\n            if (dbuf[i] > maxv) {\n                maxv = dbuf[i];\n            }\n        }\n\n        for (int i = 3 * size * size - 1; i >= 0; i--) {\n            fpix[i] = (int)(255 * dbuf[i] / maxv);\n        }\n\n        System.out.println(\"P6\");\n        System.out.println(size + \" \" + size);\n        System.out.println(\"255\");\n        System.out.println(fpix);\n    }\n\n    public static void sc_up() {\n        scale *= 2;\n        x *= 2;\n        y *= 2;\n        cscale *= 3;\n    }\n\n    public static void iter_string(String str, int d) {\n        int len;\n        while (str.charAt(0) != '\\0') {\n            switch (str.charAt(0)) {\n                case 'X':\n                    if (d > 1) {\n                        iter_string(\"XHXVX\", d - 1);\n                    } else {\n                        clen++;\n                        h_rgb(x / scale, y / scale);\n                        x += dx;\n                        y -= dy;\n                    }\n                    break;\n                case 'V':\n                    len = 1 << d;\n                    while (len--) {\n                        clen++;\n                        h_rgb(x / scale, y / scale);\n                        y += dy;\n                    }\n                    break;\n                case 'H':\n                    len = 1 << d;\n                    while (len--) {\n                        clen++;\n                        h_rgb(x / scale, y / scale);\n                        x -= dx;\n                    }\n                    break;\n            }\n            str = str.substring(1);\n        }\n    }\n\n    public static void h_rgb(int x, int y) {\n        int[] p = pix[y][x];\n\n        double h = 6.0 * clen / cscale;\n        double VAL = 1;\n        double c = SAT * VAL;\n        double X = c * (1 - Math.abs(Math.fmod(h, 2) - 1));\n\n        switch ((int) h) {\n            case 0:\n                p[0] += c;\n                p[1] += X;\n                return;\n            case 1:\n                p[0] += X;\n                p[1] += c;\n                return;\n            case 2:\n                p[1] += c;\n                p[2] += X;\n                return;\n            case 3:\n                p[1] += X;\n                p[2] += c;\n                return;\n            case 4:\n                p[0] += X;\n                p[2] += c;\n                return;\n            default:\n                p[0] += c;\n                p[2] += X;\n        }\n    }\n}", "index": 51}
{"lang": "C, Java", "input": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n \nlong long x, y, dx, dy, scale, clen, cscale;\ntypedef struct { double r, g, b; } rgb;\nrgb ** pix;\n \nvoid sc_up()\n{\n\tscale *= 2; x *= 2; y *= 2;\n\tcscale *= 3;\n}\n \nvoid h_rgb(long long x, long long y)\n{\n\trgb *p = &pix[y][x];\n \n#\tdefine SAT 1\n\tdouble h = 6.0 * clen / cscale;\n\tdouble VAL = 1;\n\tdouble c = SAT * VAL;\n\tdouble X = c * (1 - fabs(fmod(h, 2) - 1));\n \n\tswitch((int)h) {\n\tcase 0: p->r += c; p->g += X; return;\n\tcase 1:\tp->r += X; p->g += c; return;\n\tcase 2: p->g += c; p->b += X; return;\n\tcase 3: p->g += X; p->b += c; return;\n\tcase 4: p->r += X; p->b += c; return;\n\tdefault:\n\t\tp->r += c; p->b += X;\n\t}\n}\n \nvoid iter_string(const char * str, int d)\n{\n\tlong long len;\n\twhile (*str != '\\0') {\n\t\tswitch(*(str++)) {\n\t\tcase 'X':\n\t\t\tif (d)\titer_string(\"XHXVX\", d - 1);\n\t\t\telse{\n\t\t\t\tclen ++;\n\t\t\t\th_rgb(x/scale, y/scale);\n\t\t\t\tx += dx;\n\t\t\t\ty -= dy;\n\t\t\t}\n\t\t\tcontinue;\n\t\tcase 'V':\n\t\t\tlen = 1LLU << d;\n\t\t\twhile (len--) {\n\t\t\t\tclen ++;\n\t\t\t\th_rgb(x/scale, y/scale);\n\t\t\t\ty += dy;\n\t\t\t}\n\t\t\tcontinue;\n\t\tcase 'H':\n\t\t\tlen = 1LLU << d;\n\t\t\twhile(len --) {\n\t\t\t\tclen ++;\n\t\t\t\th_rgb(x/scale, y/scale);\n\t\t\t\tx -= dx;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t}\n}\n \nvoid sierp(long leng, int depth)\n{\n\tlong i;\n\tlong h = leng + 20, w = leng + 20;\n \n\t\n\trgb *buf = malloc(sizeof(rgb) * w * h);\n\tpix = malloc(sizeof(rgb *) * h);\n\tfor (i = 0; i < h; i++)\n\t\tpix[i] = buf + w * i;\n\tmemset(buf, 0, sizeof(rgb) * w * h);\n \n        \n\tx = y = 10; dx = leng; dy = leng; scale = 1; clen = 0; cscale = 3;\n\tfor (i = 0; i < depth; i++) sc_up();\n\titer_string(\"VXH\", depth);\n \n\t\n\tunsigned char *fpix = malloc(w * h * 3);\n\tdouble maxv = 0, *dbuf = (double*)buf;\n \n\tfor (i = 3 * w * h - 1; i >= 0; i--)\n\t\tif (dbuf[i] > maxv) maxv = dbuf[i];\n\tfor (i = 3 * h * w - 1; i >= 0; i--)\n\t\tfpix[i] = 255 * dbuf[i] / maxv;\n \n\tprintf(\"P6\\n%ld %ld\\n255\\n\", w, h);\n\tfflush(stdout); \n\tfwrite(fpix, h * w * 3, 1, stdout);\n}\n \nint main(int c, char ** v)\n{\n\tint size, depth;\n \n\tdepth  = (c > 1) ? atoi(v[1]) : 10;\n\tsize = 1 << depth;\n \n\tfprintf(stderr, \"size: %d depth: %d\\n\", size, depth);\n\tsierp(size, depth + 2);\n \n\treturn 0;\n}", "gold": "import javax.swing.*;\nimport java.awt.*;\n\n \n\nclass SierpinskyTriangle {\n\n\tpublic static void main(String[] args) {\n\t\tint i = 3;\t\t\n\t\tif(args.length >= 1) {\n\t\t\ttry {\n\t\t\t\ti = Integer.parseInt(args[0]);\n\t\t\t}\n\t\t\tcatch(NumberFormatException e) {\n\t\t\t\tSystem.out.println(\"Usage: 'java SierpinskyTriangle [level]'\\nNow setting level to \"+i);\n\t\t\t}\n\t\t}\n\t\tfinal int level = i;\n\n\t\tJFrame frame = new JFrame(\"Sierpinsky Triangle - Java\");\n\t\tframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\n\t\tJPanel panel = new JPanel() {\n\t\t\t@Override\n\t\t\tpublic void paintComponent(Graphics g) {\n\t\t\t\tg.setColor(Color.BLACK);\n\t\t\t\tdrawSierpinskyTriangle(level, 20, 20, 360, (Graphics2D)g);\n\t\t\t}\n\t\t};\n\n\t\tpanel.setPreferredSize(new Dimension(400, 400));\n\n\t\tframe.add(panel);\n\t\tframe.pack();\n\t\tframe.setResizable(false);\n\t\tframe.setLocationRelativeTo(null);\n\t\tframe.setVisible(true);\n\t}\n\n\tprivate static void drawSierpinskyTriangle(int level, int x, int y, int size, Graphics2D g) {\n\t\tif(level <= 0) return;\n\n\t\tg.drawLine(x, y, x+size, y);\n\t\tg.drawLine(x, y, x, y+size);\n\t\tg.drawLine(x+size, y, x, y+size);\n\n\t\tdrawSierpinskyTriangle(level-1, x, y, size/2, g);\n\t\tdrawSierpinskyTriangle(level-1, x+size/2, y, size/2, g);\n\t\tdrawSierpinskyTriangle(level-1, x, y+size/2, size/2, g);\n\t}\n}", "llm": "cl-34b", "output": "import java.util.Arrays;\n\npublic class Sierpinski {\n    public static void main(String[] args) {\n        int size = 1 << (args.length > 1 ? Integer.parseInt(args[1]) : 10);\n        int depth = size + 2;\n        System.out.println(\"size: \" + size + \" depth: \" + depth);\n        sierp(size, depth);\n    }\n\n    public static void sierp(int size, int depth) {\n        int w = size + 20;\n        int h = size + 20;\n        int[][] buf = new int[w][h];\n        int[][] pix = new int[h][w];\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                pix[i][j] = buf[i][j];\n            }\n        }\n        Arrays.fill(buf, 0);\n\n        int x = 10;\n        int y = 10;\n        int dx = size;\n        int dy = size;\n        int scale = 1;\n        int clen = 0;\n        int cscale = 3;\n        for (int i = 0; i < depth; i++) {\n            scale *= 2;\n            x *= 2;\n            y *= 2;\n            cscale *= 3;\n        }\n        iterString(\"VXH\", depth);\n\n        int[] fpix = new int[w * h * 3];\n        double maxv = 0;\n        for (int i = 0; i < w * h * 3; i++) {\n            if (buf[i] > maxv) {\n                maxv = buf[i];\n            }\n        }\n        for (int i = 0; i < w * h * 3; i++) {\n            fpix[i] = (int) (255 * buf[i] / maxv);\n        }\n\n        System.out.println(\"P6\");\n        System.out.println(w + \" \" + h);\n        System.out.println(\"255\");\n        System.out.flush();\n        System.out.write(fpix, 0, w * h * 3);\n    }\n\n    public static void iterString(String str, int d) {\n        int len;\n        while (str.length() > 0) {\n            switch (str.charAt(0)) {\n                case 'X':\n                    if (d > 0) {\n                        iterString(\"XHXVX\", d - 1);\n                    } else {\n                        clen++;\n                        hRgb(x / scale, y / scale);\n                        x += dx;\n                        y -= dy;\n                    }\n                    break;\n                case 'V':\n                    len = 1 << d;\n                    while (len-- > 0) {\n                        clen++;\n                        hRgb(x / scale, y / scale);\n                        y += dy;\n                    }\n                    break;\n                case 'H':\n                    len = 1 << d;\n                    while (len-- > 0) {\n                        clen++;\n                        hRgb(x / scale, y / scale);\n                        x -= dx;\n                    }\n                    break;\n            }\n            str = str.substring(1);\n        }\n    }\n\n    public static void hRgb(int x, int y) {\n        int r = 0, g = 0, b = 0;\n        double h = 6.0 * clen / cscale;\n        double val = 1;\n        double c = 1;\n        double x = c * (1 - Math.abs(h % 2 - 1));\n        switch ((int) h) {\n            case 0:\n                r += c;\n                g += x;\n                break;\n            case 1:\n                r += x;\n                g += c;\n                break;\n            case 2:\n                g += c;\n                b += x;\n                break;\n            case 3:\n                g += x;\n                b += c;\n                break;\n            case 4:\n                r += x;\n                b += c;\n                break;\n            default:\n                r += c;\n                b += x;\n        }\n    }\n}", "index": 52}
{"lang": "C, Java", "input": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n \nlong long x, y, dx, dy, scale, clen, cscale;\ntypedef struct { double r, g, b; } rgb;\nrgb ** pix;\n \nvoid sc_up()\n{\n\tscale *= 2; x *= 2; y *= 2;\n\tcscale *= 3;\n}\n \nvoid h_rgb(long long x, long long y)\n{\n\trgb *p = &pix[y][x];\n \n#\tdefine SAT 1\n\tdouble h = 6.0 * clen / cscale;\n\tdouble VAL = 1;\n\tdouble c = SAT * VAL;\n\tdouble X = c * (1 - fabs(fmod(h, 2) - 1));\n \n\tswitch((int)h) {\n\tcase 0: p->r += c; p->g += X; return;\n\tcase 1:\tp->r += X; p->g += c; return;\n\tcase 2: p->g += c; p->b += X; return;\n\tcase 3: p->g += X; p->b += c; return;\n\tcase 4: p->r += X; p->b += c; return;\n\tdefault:\n\t\tp->r += c; p->b += X;\n\t}\n}\n \nvoid iter_string(const char * str, int d)\n{\n\tlong long len;\n\twhile (*str != '\\0') {\n\t\tswitch(*(str++)) {\n\t\tcase 'X':\n\t\t\tif (d)\titer_string(\"XHXVX\", d - 1);\n\t\t\telse{\n\t\t\t\tclen ++;\n\t\t\t\th_rgb(x/scale, y/scale);\n\t\t\t\tx += dx;\n\t\t\t\ty -= dy;\n\t\t\t}\n\t\t\tcontinue;\n\t\tcase 'V':\n\t\t\tlen = 1LLU << d;\n\t\t\twhile (len--) {\n\t\t\t\tclen ++;\n\t\t\t\th_rgb(x/scale, y/scale);\n\t\t\t\ty += dy;\n\t\t\t}\n\t\t\tcontinue;\n\t\tcase 'H':\n\t\t\tlen = 1LLU << d;\n\t\t\twhile(len --) {\n\t\t\t\tclen ++;\n\t\t\t\th_rgb(x/scale, y/scale);\n\t\t\t\tx -= dx;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t}\n}\n \nvoid sierp(long leng, int depth)\n{\n\tlong i;\n\tlong h = leng + 20, w = leng + 20;\n \n\t\n\trgb *buf = malloc(sizeof(rgb) * w * h);\n\tpix = malloc(sizeof(rgb *) * h);\n\tfor (i = 0; i < h; i++)\n\t\tpix[i] = buf + w * i;\n\tmemset(buf, 0, sizeof(rgb) * w * h);\n \n        \n\tx = y = 10; dx = leng; dy = leng; scale = 1; clen = 0; cscale = 3;\n\tfor (i = 0; i < depth; i++) sc_up();\n\titer_string(\"VXH\", depth);\n \n\t\n\tunsigned char *fpix = malloc(w * h * 3);\n\tdouble maxv = 0, *dbuf = (double*)buf;\n \n\tfor (i = 3 * w * h - 1; i >= 0; i--)\n\t\tif (dbuf[i] > maxv) maxv = dbuf[i];\n\tfor (i = 3 * h * w - 1; i >= 0; i--)\n\t\tfpix[i] = 255 * dbuf[i] / maxv;\n \n\tprintf(\"P6\\n%ld %ld\\n255\\n\", w, h);\n\tfflush(stdout); \n\tfwrite(fpix, h * w * 3, 1, stdout);\n}\n \nint main(int c, char ** v)\n{\n\tint size, depth;\n \n\tdepth  = (c > 1) ? atoi(v[1]) : 10;\n\tsize = 1 << depth;\n \n\tfprintf(stderr, \"size: %d depth: %d\\n\", size, depth);\n\tsierp(size, depth + 2);\n \n\treturn 0;\n}", "gold": "import javax.swing.*;\nimport java.awt.*;\n\n \n\nclass SierpinskyTriangle {\n\n\tpublic static void main(String[] args) {\n\t\tint i = 3;\t\t\n\t\tif(args.length >= 1) {\n\t\t\ttry {\n\t\t\t\ti = Integer.parseInt(args[0]);\n\t\t\t}\n\t\t\tcatch(NumberFormatException e) {\n\t\t\t\tSystem.out.println(\"Usage: 'java SierpinskyTriangle [level]'\\nNow setting level to \"+i);\n\t\t\t}\n\t\t}\n\t\tfinal int level = i;\n\n\t\tJFrame frame = new JFrame(\"Sierpinsky Triangle - Java\");\n\t\tframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\n\t\tJPanel panel = new JPanel() {\n\t\t\t@Override\n\t\t\tpublic void paintComponent(Graphics g) {\n\t\t\t\tg.setColor(Color.BLACK);\n\t\t\t\tdrawSierpinskyTriangle(level, 20, 20, 360, (Graphics2D)g);\n\t\t\t}\n\t\t};\n\n\t\tpanel.setPreferredSize(new Dimension(400, 400));\n\n\t\tframe.add(panel);\n\t\tframe.pack();\n\t\tframe.setResizable(false);\n\t\tframe.setLocationRelativeTo(null);\n\t\tframe.setVisible(true);\n\t}\n\n\tprivate static void drawSierpinskyTriangle(int level, int x, int y, int size, Graphics2D g) {\n\t\tif(level <= 0) return;\n\n\t\tg.drawLine(x, y, x+size, y);\n\t\tg.drawLine(x, y, x, y+size);\n\t\tg.drawLine(x+size, y, x, y+size);\n\n\t\tdrawSierpinskyTriangle(level-1, x, y, size/2, g);\n\t\tdrawSierpinskyTriangle(level-1, x+size/2, y, size/2, g);\n\t\tdrawSierpinskyTriangle(level-1, x, y+size/2, size/2, g);\n\t}\n}", "llm": "dsc-7b", "output": "import java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\n\npublic class Main {\n    static class RGB {\n        double r, g, b;\n    }\n\n    static long x, y, dx, dy, scale, clen, cscale;\n    static RGB[][] pix;\n\n    static void sc_up() {\n        scale *= 2; x *= 2; y *= 2;\n        cscale *= 3;\n    }\n\n    static void h_rgb(long x, long y) {\n        RGB p = pix[(int)y][(int)x];\n\n        double SAT = 1;\n        double VAL = 1;\n        double h = 6.0 * clen / cscale;\n        double c = SAT * VAL;\n        double X = c * (1 - Math.abs(Math.floorMod((int)h, 2) - 1));\n\n        switch ((int)h) {\n            case 0:\n                p.r += c; p.g += X;\n                break;\n            case 1:\n                p.r += X; p.g += c;\n                break;\n            case 2:\n                p.g += c; p.b += X;\n                break;\n            case 3:\n                p.g += X; p.b += c;\n                break;\n            case 4:\n                p.r += X; p.b += c;\n                break;\n            default:\n                p.r += c; p.b += X;\n        }\n    }\n\n    static void iter_string(String str, int d) {\n        long len;\n        while (str.length() > 0) {\n            switch (str.charAt(0)) {\n                case 'X':\n                    if (d > 0) iter_string(\"XHXVX\", d - 1);\n                    else {\n                        clen++;\n                        h_rgb(x / scale, y / scale);\n                        x += dx;\n                        y -= dy;\n                    }\n                    str = str.substring(1);\n                    continue;\n                case 'V':\n                    len = 1L << d;\n                    while (len-- > 0) {\n                        clen++;\n                        h_rgb(x / scale, y / scale);\n                        y += dy;\n                    }\n                    str = str.substring(1);\n                    continue;\n                case 'H':\n                    len = 1L << d;\n                    while (len-- > 0) {\n                        clen++;\n                        h_rgb(x / scale, y / scale);\n                        x -= dx;\n                    }\n                    str = str.substring(1);\n                    continue;\n            }\n        }\n    }\n\n    static void sierp(long leng, int depth) {\n        long h = leng + 20, w = leng + 20;\n\n        RGB[] buf = new RGB[(int)(w * h)];\n        pix = new RGB[(int)h][(int)w];\n        for (int i = 0; i < h; i++)\n            pix[i] = buf;\n\n        x = y = 10; dx = leng; dy = leng; scale = 1; clen = 0; cscale = 3;\n        for (int i = 0; i < depth; i++) sc_up();\n        iter_string(\"VXH\", depth);\n\n        double maxv = 0;\n        for (int i = 0; i < w * h; i++)\n            if (buf[i].r > maxv) maxv = buf[i].r;\n\n        try (OutputStream os = new FileOutputStream(\"image.ppm\")) {\n            os.write((\"P6\\n\" + w + \" \" + h + \"\\n255\\n\").getBytes());\n            for (int i = 0; i < w * h; i++) {\n                os.write((int)(255 * buf[i].r / maxv));\n                os.write((int)(255 * buf[i].g / maxv));\n                os.write((int)(255 * buf[i].b / maxv));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] v) {\n        int depth = (v.length > 1) ? Integer.parseInt(v[1]) : 10;\n        int size = 1 << depth;\n\n        System.err.println(\"size: \" + size + \" depth: \" + depth);\n        sierp(size, depth + 2);\n    }\n}", "index": 53}
{"lang": "C, C++", "input": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <omp.h>\n\nint main()\n{\n        int jobs = 41, tid;\n        omp_set_num_threads(5);\n\n        #pragma omp parallel shared(jobs) private(tid)\n        {\n                tid = omp_get_thread_num();\n                while (jobs > 0) {\n                        \n                        #pragma omp barrier\n                        if (!jobs) break;\n\n                        printf(\"%d: taking job %d\\n\", tid, jobs--);\n                        usleep(100000 + rand() / (double) RAND_MAX * 3000000);\n                        printf(\"%d: done job\\n\", tid);\n                }\n\n                printf(\"[%d] leaving\\n\", tid);\n\n                \n                #pragma omp barrier\n        }\n\n        return 0;\n}", "gold": "#include <iostream>\n#include <chrono>\n#include <atomic>\n#include <mutex>\n#include <random>\n#include <thread>\n\nstd::mutex cout_lock;\n\nclass Latch\n{\n    std::atomic<int> semafor;\n  public:\n    Latch(int limit) : semafor(limit) {}\n\n    void wait()\n    {\n        semafor.fetch_sub(1);\n        while(semafor.load() > 0)\n            std::this_thread::yield();\n    }\n};\n\nstruct Worker\n{\n    static void do_work(int how_long, Latch& barrier, std::string name)\n    {\n        std::this_thread::sleep_for(std::chrono::milliseconds(how_long));\n        {   std::lock_guard<std::mutex> lock(cout_lock);\n            std::cout << \"Worker \" << name << \" finished work\\n\";   }\n        barrier.wait();\n        {   std::lock_guard<std::mutex> lock(cout_lock);\n            std::cout << \"Worker \" << name << \" finished assembly\\n\";   }\n    }\n};\n\nint main()\n{\n    Latch latch(5);\n    std::mt19937 rng(std::random_device{}());\n    std::uniform_int_distribution<> dist(300, 3000);\n    std::thread threads[] {\n        std::thread(&Worker::do_work, dist(rng), std::ref(latch), \"John\"),\n        std::thread{&Worker::do_work, dist(rng), std::ref(latch), \"Henry\"},\n        std::thread{&Worker::do_work, dist(rng), std::ref(latch), \"Smith\"},\n        std::thread{&Worker::do_work, dist(rng), std::ref(latch), \"Jane\"},\n        std::thread{&Worker::do_work, dist(rng), std::ref(latch), \"Mary\"},\n    };\n    for(auto& t: threads) t.join();\n    std::cout << \"Assembly is finished\";\n}", "llm": "cl-13b", "output": "#include <iostream>\n#include <thread>\n#include <mutex>\n\nint main() {\n    int jobs = 41;\n    int num_threads = 5;\n    std::mutex mtx;\n\n    std::thread threads[num_threads];\n    for (int i = 0; i < num_threads; ++i) {\n        threads[i] = std::thread([&]() {\n            int tid = i;\n            while (jobs > 0) {\n                std::lock_guard<std::mutex> lock(mtx);\n                if (!jobs) break;\n\n                std::cout << tid << \": taking job \" << jobs-- << std::endl;\n                usleep(100000 + rand() / (double) RAND_MAX * 3000000);\n                std::cout << tid << \": done job\" << std::endl;\n            }\n\n            std::cout << \"[ \" << tid << \" ] leaving\" << std::endl;\n        });\n    }\n\n    for (int i = 0; i < num_threads; ++i) {\n        threads[i].join();\n    }\n\n    return 0;\n}", "index": 54}
{"lang": "C, C++", "input": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <omp.h>\n\nint main()\n{\n        int jobs = 41, tid;\n        omp_set_num_threads(5);\n\n        #pragma omp parallel shared(jobs) private(tid)\n        {\n                tid = omp_get_thread_num();\n                while (jobs > 0) {\n                        \n                        #pragma omp barrier\n                        if (!jobs) break;\n\n                        printf(\"%d: taking job %d\\n\", tid, jobs--);\n                        usleep(100000 + rand() / (double) RAND_MAX * 3000000);\n                        printf(\"%d: done job\\n\", tid);\n                }\n\n                printf(\"[%d] leaving\\n\", tid);\n\n                \n                #pragma omp barrier\n        }\n\n        return 0;\n}", "gold": "#include <iostream>\n#include <chrono>\n#include <atomic>\n#include <mutex>\n#include <random>\n#include <thread>\n\nstd::mutex cout_lock;\n\nclass Latch\n{\n    std::atomic<int> semafor;\n  public:\n    Latch(int limit) : semafor(limit) {}\n\n    void wait()\n    {\n        semafor.fetch_sub(1);\n        while(semafor.load() > 0)\n            std::this_thread::yield();\n    }\n};\n\nstruct Worker\n{\n    static void do_work(int how_long, Latch& barrier, std::string name)\n    {\n        std::this_thread::sleep_for(std::chrono::milliseconds(how_long));\n        {   std::lock_guard<std::mutex> lock(cout_lock);\n            std::cout << \"Worker \" << name << \" finished work\\n\";   }\n        barrier.wait();\n        {   std::lock_guard<std::mutex> lock(cout_lock);\n            std::cout << \"Worker \" << name << \" finished assembly\\n\";   }\n    }\n};\n\nint main()\n{\n    Latch latch(5);\n    std::mt19937 rng(std::random_device{}());\n    std::uniform_int_distribution<> dist(300, 3000);\n    std::thread threads[] {\n        std::thread(&Worker::do_work, dist(rng), std::ref(latch), \"John\"),\n        std::thread{&Worker::do_work, dist(rng), std::ref(latch), \"Henry\"},\n        std::thread{&Worker::do_work, dist(rng), std::ref(latch), \"Smith\"},\n        std::thread{&Worker::do_work, dist(rng), std::ref(latch), \"Jane\"},\n        std::thread{&Worker::do_work, dist(rng), std::ref(latch), \"Mary\"},\n    };\n    for(auto& t: threads) t.join();\n    std::cout << \"Assembly is finished\";\n}", "llm": "dsc-7b", "output": "#include <iostream>\n#include <omp.h>\n#include <unistd.h>\n#include <cstdlib>\n#include <ctime>\n\nint main()\n{\n    int jobs = 41;\n    omp_set_num_threads(5);\n\n    #pragma omp parallel shared(jobs)\n    {\n        int tid = omp_get_thread_num();\n        srand(time(0) + tid);\n        while (jobs > 0) {\n\n            #pragma omp barrier\n            if (!jobs) break;\n\n            std::cout << tid << \": taking job \" << jobs << std::endl;\n            usleep(100000 + rand() / (double) RAND_MAX * 3000000);\n            jobs--;\n            std::cout << tid << \": done job\" << std::endl;\n        }\n\n        std::cout << \"[\" << tid << \"] leaving\" << std::endl;\n\n\n        #pragma omp barrier\n    }\n\n    return 0;\n}", "index": 55}
{"lang": "C, C++", "input": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <omp.h>\n\nint main()\n{\n        int jobs = 41, tid;\n        omp_set_num_threads(5);\n\n        #pragma omp parallel shared(jobs) private(tid)\n        {\n                tid = omp_get_thread_num();\n                while (jobs > 0) {\n                        \n                        #pragma omp barrier\n                        if (!jobs) break;\n\n                        printf(\"%d: taking job %d\\n\", tid, jobs--);\n                        usleep(100000 + rand() / (double) RAND_MAX * 3000000);\n                        printf(\"%d: done job\\n\", tid);\n                }\n\n                printf(\"[%d] leaving\\n\", tid);\n\n                \n                #pragma omp barrier\n        }\n\n        return 0;\n}", "gold": "#include <iostream>\n#include <chrono>\n#include <atomic>\n#include <mutex>\n#include <random>\n#include <thread>\n\nstd::mutex cout_lock;\n\nclass Latch\n{\n    std::atomic<int> semafor;\n  public:\n    Latch(int limit) : semafor(limit) {}\n\n    void wait()\n    {\n        semafor.fetch_sub(1);\n        while(semafor.load() > 0)\n            std::this_thread::yield();\n    }\n};\n\nstruct Worker\n{\n    static void do_work(int how_long, Latch& barrier, std::string name)\n    {\n        std::this_thread::sleep_for(std::chrono::milliseconds(how_long));\n        {   std::lock_guard<std::mutex> lock(cout_lock);\n            std::cout << \"Worker \" << name << \" finished work\\n\";   }\n        barrier.wait();\n        {   std::lock_guard<std::mutex> lock(cout_lock);\n            std::cout << \"Worker \" << name << \" finished assembly\\n\";   }\n    }\n};\n\nint main()\n{\n    Latch latch(5);\n    std::mt19937 rng(std::random_device{}());\n    std::uniform_int_distribution<> dist(300, 3000);\n    std::thread threads[] {\n        std::thread(&Worker::do_work, dist(rng), std::ref(latch), \"John\"),\n        std::thread{&Worker::do_work, dist(rng), std::ref(latch), \"Henry\"},\n        std::thread{&Worker::do_work, dist(rng), std::ref(latch), \"Smith\"},\n        std::thread{&Worker::do_work, dist(rng), std::ref(latch), \"Jane\"},\n        std::thread{&Worker::do_work, dist(rng), std::ref(latch), \"Mary\"},\n    };\n    for(auto& t: threads) t.join();\n    std::cout << \"Assembly is finished\";\n}", "llm": "magic-7b", "output": "#include <iostream>\n#include <omp.h>\n#include <unistd.h>\n#include <cstdlib>\n\nint main()\n{\n    int jobs = 41, tid;\n    omp_set_num_threads(5);\n\n    #pragma omp parallel shared(jobs) private(tid)\n    {\n        tid = omp_get_thread_num();\n        while (jobs > 0) {\n            \n            #pragma omp barrier\n            if (!jobs) break;\n\n            std::cout << tid << \": taking job \" << jobs-- << std::endl;\n            usleep(100000 + rand() / (double) RAND_MAX * 3000000);\n            std::cout << tid << \": done job\" << std::endl;\n        }\n\n        std::cout << \"[\" << tid << \"] leaving\" << std::endl;\n\n        \n        #pragma omp barrier\n    }\n\n    return 0;\n}", "index": 56}
{"lang": "C++, Python", "input": "#include <string>\n#include <fstream>\n#include <boost/serialization/string.hpp>\n#include <boost/archive/text_oarchive.hpp>\n#include <boost/archive/text_iarchive.hpp>\n#include <boost/serialization/base_object.hpp>\n#include <iostream>\n\nclass Employee {\npublic :   \n   Employee( ) { }\n\n   Employee ( const std::string &dep , const std::string &namen ) \n      : department( dep ) , name( namen ) {\n\t my_id = count++ ;\n      }\n\n   std::string getName( ) const {\n      return name ;\n   }\n\n   std::string getDepartment( ) const {\n      return department ;\n   }\n\n   int getId( ) const {\n      return my_id ;\n   }\n\n   void setDepartment( const std::string &dep ) {\n      department.assign( dep ) ;\n   }\n\n   virtual void print( ) {\n      std::cout << \"Name: \" << name << '\\n' ;\n      std::cout << \"Id: \" << my_id << '\\n' ;\n      std::cout << \"Department: \" << department << '\\n' ;\n   }\n\n   virtual ~Employee( ) { } \n   static int count ;\nprivate :\n   std::string name ;\n   std::string department ;\n   int my_id ;\n   friend class boost::serialization::access ;\n\n   template <class Archive>\n      void serialize( Archive &ar, const unsigned int version ) {\n\t ar & my_id ;\n\t ar & name ;\n\t ar & department ;\n      }\n\n} ;\n\nclass Worker : public Employee {\npublic :\n   Worker( const std::string & dep, const std::string &namen ,\n\t double hourlyPay ) : Employee( dep , namen ) , salary( hourlyPay) { }\n\n   Worker( ) { }\n\n   double getSalary( ) {\n      return salary ;\n   }\n\n   void setSalary( double pay ) {\n      if ( pay > 0 ) \n\t salary = pay ;\n   }\n   \n   virtual void print( ) {\n      Employee::print( ) ;\n      std::cout << \"wage per hour: \" << salary << '\\n' ;\n   }\nprivate :\n   double salary ;\n   friend class boost::serialization::access ;\n   template <class Archive>\n      void serialize ( Archive & ar, const unsigned int version ) {\n\t ar & boost::serialization::base_object<Employee>( *this ) ;\n\t ar & salary ;\n      }\n} ;\n  \nint Employee::count = 0 ;\n\nint main( ) {\n   std::ofstream storefile( \"/home/ulrich/objects.dat\"  ) ; \n   const Employee emp1( \"maintenance\" , \"Fritz Schmalstieg\"  ) ;\n   const Employee emp2( \"maintenance\" , \"John Berry\" ) ;\n   const Employee emp3( \"repair\" , \"Pawel Lichatschow\" ) ;\n   const Employee emp4( \"IT\" , \"Marian Niculescu\" ) ;\n   const Worker worker1( \"maintenance\" , \"Laurent Le Chef\" , 20 ) ;\n   const Worker worker2 ( \"IT\" , \"Srinivan Taraman\" , 55.35 ) ;\n   boost::archive::text_oarchive oar ( storefile ) ;\n   oar << emp1 ; \n   oar << emp2 ;\n   oar << emp3 ;\n   oar << emp4 ;\n   oar << worker1 ;\n   oar << worker2 ;\n   storefile.close( ) ;\n   std::cout << \"Reading out the data again\\n\" ;\n   Employee e1 , e2 , e3 , e4 ; \n   Worker w1, w2 ; \n   std::ifstream sourcefile( \"/home/ulrich/objects.dat\"  ) ;\n   boost::archive::text_iarchive iar( sourcefile ) ;\n   iar >> e1 >> e2 >> e3 >> e4 ; \n   iar >> w1 >> w2 ;\n   sourcefile.close( ) ;\n   std::cout << \"And here are the data after deserialization!( abridged):\\n\" ;\n   e1.print( ) ;\n   e3.print( ) ;\n   w2.print( ) ;\n   return 0 ;\n}", "gold": "import pickle\n\nclass Entity:\n\tdef __init__(self):\n\t\tself.name = \"Entity\"\n\tdef printName(self):\n\t\tprint self.name\n\nclass Person(Entity): \n\tdef __init__(self): \n\t\tself.name = \"Cletus\" \n\ninstance1 = Person()\ninstance1.printName()\n\ninstance2 = Entity()\ninstance2.printName()\n\ntarget = file(\"objects.dat\", \"w\") \n\n\npickle.dump((instance1, instance2), target) \ntarget.close() \nprint \"Serialized...\"\n\n\ntarget = file(\"objects.dat\") \ni1, i2 = pickle.load(target)\nprint \"Unserialized...\"\n\ni1.printName()\ni2.printName()", "llm": "q2.5-1.5b", "output": "import pickle\n\nclass Employee:\n    def __init__(self, dep, name):\n        self.department = dep\n        self.name = name\n        self.my_id = Employee.count\n        Employee.count += 1\n\n    def get_name(self):\n        return self.name\n\n    def get_department(self):\n        return self.department\n\n    def get_id(self):\n        return self.my_id\n\n    def set_department(self, dep):\n        self.department = dep\n\n    def print(self):\n        print(f\"Name: {self.name}\")\n        print(f\"Id: {self.my_id}\")\n        print(f\"Department: {self.department}\")\n\n    def __del__(self):\n        pass\n\nclass Worker(Employee):\n    def __init__(self, dep, name, hourly_pay):\n        super().__init__(dep, name)\n        self.salary = hourly_pay\n\n    def get_salary(self):\n        return self.salary\n\n    def set_salary(self, pay):\n        if pay > 0:\n            self.salary = pay\n\n    def print(self):\n        super().print()\n        print(f\"wage per hour: {self.salary}\")\n\nEmployee.count = 0\n\nif __name__ == \"__main__\":\n    with open(\"/home/ulrich/objects.dat\", \"wb\") as storefile:\n        emp1 = Employee(\"maintenance\", \"Fritz Schmalstieg\")\n        emp2 = Employee(\"maintenance\", \"John Berry\")\n        emp3 = Employee(\"repair\", \"Pawel Lichatschow\")\n        emp4 = Employee(\"IT\", \"Marian Niculescu\")\n        worker1 = Worker(\"maintenance\", \"Laurent Le Chef\", 20)\n        worker2 = Worker(\"IT\", \"Srinivan Taraman\", 55.35)\n        pickle.dump(emp1, storefile)\n        pickle.dump(emp2, storefile)\n        pickle.dump(emp3, storefile)\n        pickle.dump(emp4, storefile)\n        pickle.dump(worker1, storefile)\n        pickle.dump(worker2, storefile)\n        storefile.close()\n\n    with open(\"/home/ulrich/objects.dat\", \"rb\") as sourcefile:\n        e1 = pickle.load(sourcefile)\n        e2 = pickle.load(sourcefile)\n        e3 = pickle.load(sourcefile)\n        e4 = pickle.load(sourcefile)\n        w1 = pickle.load(sourcefile)\n        w2 = pickle.load(sourcefile)\n        sourcefile.close()\n\n    print(\"And here are the data after deserialization!( abridged):\\n\")\n    e1.print()\n    e3.print()\n    w2.print()", "index": 57}
{"lang": "C++, Python", "input": "#include <string>\n#include <fstream>\n#include <boost/serialization/string.hpp>\n#include <boost/archive/text_oarchive.hpp>\n#include <boost/archive/text_iarchive.hpp>\n#include <boost/serialization/base_object.hpp>\n#include <iostream>\n\nclass Employee {\npublic :   \n   Employee( ) { }\n\n   Employee ( const std::string &dep , const std::string &namen ) \n      : department( dep ) , name( namen ) {\n\t my_id = count++ ;\n      }\n\n   std::string getName( ) const {\n      return name ;\n   }\n\n   std::string getDepartment( ) const {\n      return department ;\n   }\n\n   int getId( ) const {\n      return my_id ;\n   }\n\n   void setDepartment( const std::string &dep ) {\n      department.assign( dep ) ;\n   }\n\n   virtual void print( ) {\n      std::cout << \"Name: \" << name << '\\n' ;\n      std::cout << \"Id: \" << my_id << '\\n' ;\n      std::cout << \"Department: \" << department << '\\n' ;\n   }\n\n   virtual ~Employee( ) { } \n   static int count ;\nprivate :\n   std::string name ;\n   std::string department ;\n   int my_id ;\n   friend class boost::serialization::access ;\n\n   template <class Archive>\n      void serialize( Archive &ar, const unsigned int version ) {\n\t ar & my_id ;\n\t ar & name ;\n\t ar & department ;\n      }\n\n} ;\n\nclass Worker : public Employee {\npublic :\n   Worker( const std::string & dep, const std::string &namen ,\n\t double hourlyPay ) : Employee( dep , namen ) , salary( hourlyPay) { }\n\n   Worker( ) { }\n\n   double getSalary( ) {\n      return salary ;\n   }\n\n   void setSalary( double pay ) {\n      if ( pay > 0 ) \n\t salary = pay ;\n   }\n   \n   virtual void print( ) {\n      Employee::print( ) ;\n      std::cout << \"wage per hour: \" << salary << '\\n' ;\n   }\nprivate :\n   double salary ;\n   friend class boost::serialization::access ;\n   template <class Archive>\n      void serialize ( Archive & ar, const unsigned int version ) {\n\t ar & boost::serialization::base_object<Employee>( *this ) ;\n\t ar & salary ;\n      }\n} ;\n  \nint Employee::count = 0 ;\n\nint main( ) {\n   std::ofstream storefile( \"/home/ulrich/objects.dat\"  ) ; \n   const Employee emp1( \"maintenance\" , \"Fritz Schmalstieg\"  ) ;\n   const Employee emp2( \"maintenance\" , \"John Berry\" ) ;\n   const Employee emp3( \"repair\" , \"Pawel Lichatschow\" ) ;\n   const Employee emp4( \"IT\" , \"Marian Niculescu\" ) ;\n   const Worker worker1( \"maintenance\" , \"Laurent Le Chef\" , 20 ) ;\n   const Worker worker2 ( \"IT\" , \"Srinivan Taraman\" , 55.35 ) ;\n   boost::archive::text_oarchive oar ( storefile ) ;\n   oar << emp1 ; \n   oar << emp2 ;\n   oar << emp3 ;\n   oar << emp4 ;\n   oar << worker1 ;\n   oar << worker2 ;\n   storefile.close( ) ;\n   std::cout << \"Reading out the data again\\n\" ;\n   Employee e1 , e2 , e3 , e4 ; \n   Worker w1, w2 ; \n   std::ifstream sourcefile( \"/home/ulrich/objects.dat\"  ) ;\n   boost::archive::text_iarchive iar( sourcefile ) ;\n   iar >> e1 >> e2 >> e3 >> e4 ; \n   iar >> w1 >> w2 ;\n   sourcefile.close( ) ;\n   std::cout << \"And here are the data after deserialization!( abridged):\\n\" ;\n   e1.print( ) ;\n   e3.print( ) ;\n   w2.print( ) ;\n   return 0 ;\n}", "gold": "import pickle\n\nclass Entity:\n\tdef __init__(self):\n\t\tself.name = \"Entity\"\n\tdef printName(self):\n\t\tprint self.name\n\nclass Person(Entity): \n\tdef __init__(self): \n\t\tself.name = \"Cletus\" \n\ninstance1 = Person()\ninstance1.printName()\n\ninstance2 = Entity()\ninstance2.printName()\n\ntarget = file(\"objects.dat\", \"w\") \n\n\npickle.dump((instance1, instance2), target) \ntarget.close() \nprint \"Serialized...\"\n\n\ntarget = file(\"objects.dat\") \ni1, i2 = pickle.load(target)\nprint \"Unserialized...\"\n\ni1.printName()\ni2.printName()", "llm": "magic-7b", "output": "import pickle\n\nclass Employee:\n    count = 0\n\n    def __init__(self, dep, namen):\n        self.department = dep\n        self.name = namen\n        self.my_id = Employee.count\n        Employee.count += 1\n\n    def getName(self):\n        return self.name\n\n    def getDepartment(self):\n        return self.department\n\n    def getId(self):\n        return self.my_id\n\n    def setDepartment(self, dep):\n        self.department = dep\n\n    def print(self):\n        print(\"Name:\", self.name)\n        print(\"Id:\", self.my_id)\n        print(\"Department:\", self.department)\n\nclass Worker(Employee):\n    def __init__(self, dep, namen, hourlyPay):\n        super().__init__(dep, namen)\n        self.salary = hourlyPay\n\n    def getSalary(self):\n        return self.salary\n\n    def setSalary(self, pay):\n        if pay > 0:\n            self.salary = pay\n\n    def print(self):\n        super().print()\n        print(\"wage per hour:\", self.salary)\n\ndef main():\n    emp1 = Employee(\"maintenance\", \"Fritz Schmalstieg\")\n    emp2 = Employee(\"maintenance\", \"John Berry\")\n    emp3 = Employee(\"repair\", \"Pawel Lichatschow\")\n    emp4 = Employee(\"IT\", \"Marian Niculescu\")\n    worker1 = Worker(\"maintenance\", \"Laurent Le Chef\", 20)\n    worker2 = Worker(\"IT\", \"Srinivan Taraman\", 55.35)\n\n    with open(\"/home/ulrich/objects.dat\", \"wb\") as storefile:\n        pickle.dump(emp1, storefile)\n        pickle.dump(emp2, storefile)\n        pickle.dump(emp3, storefile)\n        pickle.dump(emp4, storefile)\n        pickle.dump(worker1, storefile)\n        pickle.dump(worker2, storefile)\n\n    print(\"Reading out the data again\")\n\n    with open(\"/home/ulrich/objects.dat\", \"rb\") as sourcefile:\n        e1 = pickle.load(sourcefile)\n        e2 = pickle.load(sourcefile)\n        e3 = pickle.load(sourcefile)\n        e4 = pickle.load(sourcefile)\n        w1 = pickle.load(sourcefile)\n        w2 = pickle.load(sourcefile)\n\n    print(\"And here are the data after deserialization!( abridged):\")\n    e1.print()\n    e3.print()\n    w2.print()\n\nif __name__ == \"__main__\":\n    main()", "index": 58}
{"lang": "C++, Python", "input": "#include <string>\n#include <fstream>\n#include <boost/serialization/string.hpp>\n#include <boost/archive/text_oarchive.hpp>\n#include <boost/archive/text_iarchive.hpp>\n#include <boost/serialization/base_object.hpp>\n#include <iostream>\n\nclass Employee {\npublic :   \n   Employee( ) { }\n\n   Employee ( const std::string &dep , const std::string &namen ) \n      : department( dep ) , name( namen ) {\n\t my_id = count++ ;\n      }\n\n   std::string getName( ) const {\n      return name ;\n   }\n\n   std::string getDepartment( ) const {\n      return department ;\n   }\n\n   int getId( ) const {\n      return my_id ;\n   }\n\n   void setDepartment( const std::string &dep ) {\n      department.assign( dep ) ;\n   }\n\n   virtual void print( ) {\n      std::cout << \"Name: \" << name << '\\n' ;\n      std::cout << \"Id: \" << my_id << '\\n' ;\n      std::cout << \"Department: \" << department << '\\n' ;\n   }\n\n   virtual ~Employee( ) { } \n   static int count ;\nprivate :\n   std::string name ;\n   std::string department ;\n   int my_id ;\n   friend class boost::serialization::access ;\n\n   template <class Archive>\n      void serialize( Archive &ar, const unsigned int version ) {\n\t ar & my_id ;\n\t ar & name ;\n\t ar & department ;\n      }\n\n} ;\n\nclass Worker : public Employee {\npublic :\n   Worker( const std::string & dep, const std::string &namen ,\n\t double hourlyPay ) : Employee( dep , namen ) , salary( hourlyPay) { }\n\n   Worker( ) { }\n\n   double getSalary( ) {\n      return salary ;\n   }\n\n   void setSalary( double pay ) {\n      if ( pay > 0 ) \n\t salary = pay ;\n   }\n   \n   virtual void print( ) {\n      Employee::print( ) ;\n      std::cout << \"wage per hour: \" << salary << '\\n' ;\n   }\nprivate :\n   double salary ;\n   friend class boost::serialization::access ;\n   template <class Archive>\n      void serialize ( Archive & ar, const unsigned int version ) {\n\t ar & boost::serialization::base_object<Employee>( *this ) ;\n\t ar & salary ;\n      }\n} ;\n  \nint Employee::count = 0 ;\n\nint main( ) {\n   std::ofstream storefile( \"/home/ulrich/objects.dat\"  ) ; \n   const Employee emp1( \"maintenance\" , \"Fritz Schmalstieg\"  ) ;\n   const Employee emp2( \"maintenance\" , \"John Berry\" ) ;\n   const Employee emp3( \"repair\" , \"Pawel Lichatschow\" ) ;\n   const Employee emp4( \"IT\" , \"Marian Niculescu\" ) ;\n   const Worker worker1( \"maintenance\" , \"Laurent Le Chef\" , 20 ) ;\n   const Worker worker2 ( \"IT\" , \"Srinivan Taraman\" , 55.35 ) ;\n   boost::archive::text_oarchive oar ( storefile ) ;\n   oar << emp1 ; \n   oar << emp2 ;\n   oar << emp3 ;\n   oar << emp4 ;\n   oar << worker1 ;\n   oar << worker2 ;\n   storefile.close( ) ;\n   std::cout << \"Reading out the data again\\n\" ;\n   Employee e1 , e2 , e3 , e4 ; \n   Worker w1, w2 ; \n   std::ifstream sourcefile( \"/home/ulrich/objects.dat\"  ) ;\n   boost::archive::text_iarchive iar( sourcefile ) ;\n   iar >> e1 >> e2 >> e3 >> e4 ; \n   iar >> w1 >> w2 ;\n   sourcefile.close( ) ;\n   std::cout << \"And here are the data after deserialization!( abridged):\\n\" ;\n   e1.print( ) ;\n   e3.print( ) ;\n   w2.print( ) ;\n   return 0 ;\n}", "gold": "import pickle\n\nclass Entity:\n\tdef __init__(self):\n\t\tself.name = \"Entity\"\n\tdef printName(self):\n\t\tprint self.name\n\nclass Person(Entity): \n\tdef __init__(self): \n\t\tself.name = \"Cletus\" \n\ninstance1 = Person()\ninstance1.printName()\n\ninstance2 = Entity()\ninstance2.printName()\n\ntarget = file(\"objects.dat\", \"w\") \n\n\npickle.dump((instance1, instance2), target) \ntarget.close() \nprint \"Serialized...\"\n\n\ntarget = file(\"objects.dat\") \ni1, i2 = pickle.load(target)\nprint \"Unserialized...\"\n\ni1.printName()\ni2.printName()", "llm": "cs-22b", "output": "import pickle\n\nclass Employee:\n    count = 0\n\n    def __init__(self, department=None, name=None):\n        if department and name:\n            self.department = department\n            self.name = name\n            self.my_id = Employee.count\n            Employee.count += 1\n\n    def getName(self):\n        return self.name\n\n    def getDepartment(self):\n        return self.department\n\n    def getId(self):\n        return self.my_id\n\n    def setDepartment(self, department):\n        self.department = department\n\n    def print(self):\n        print(f\"Name: {self.name}\")\n        print(f\"Id: {self.my_id}\")\n        print(f\"Department: {self.department}\")\n\nclass Worker(Employee):\n    def __init__(self, department=None, name=None, hourlyPay=None):\n        super().__init__(department, name)\n        if hourlyPay:\n            self.salary = hourlyPay\n\n    def getSalary(self):\n        return self.salary\n\n    def setSalary(self, pay):\n        if pay > 0:\n            self.salary = pay\n\n    def print(self):\n        super().print()\n        print(f\"Wage per hour: {self.salary}\")\n\n# Serialization and deserialization\ndef serialize_objects(objects, filename):\n    with open(filename, 'wb') as f:\n        pickle.dump(objects, f)\n\ndef deserialize_objects(filename):\n    with open(filename, 'rb') as f:\n        return pickle.load(f)\n\n# Main function\ndef main():\n    emp1 = Employee(\"maintenance\", \"Fritz Schmalstieg\")\n    emp2 = Employee(\"maintenance\", \"John Berry\")\n    emp3 = Employee(\"repair\", \"Pawel Lichatschow\")\n    emp4 = Employee(\"IT\", \"Marian Niculescu\")\n    worker1 = Worker(\"maintenance\", \"Laurent Le Chef\", 20)\n    worker2 = Worker(\"IT\", \"Srinivan Taraman\", 55.35)\n\n    objects = [emp1, emp2, emp3, emp4, worker1, worker2]\n    serialize_objects(objects, \"objects.dat\")\n\n    print(\"Reading out the data again\")\n    e1, e2, e3, e4, w1, w2 = deserialize_objects(\"objects.dat\")\n\n    print(\"And here are the data after deserialization!(abridged):\")\n    e1.print()\n    e3.print()\n    w2.print()\n\nif __name__ == \"__main__\":\n    main()", "index": 59}
{"lang": "C++, Java", "input": "#include <string>\n#include <map>\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\n\ndouble log2( double number ) {\n   return ( log( number ) / log( 2 ) ) ;\n}\n\ndouble find_entropy( std::string & fiboword ) {\n   std::map<char , int> frequencies ;\n   std::for_each( fiboword.begin( ) , fiboword.end( ) ,\n\t [ & frequencies ]( char c ) { frequencies[ c ]++ ; } ) ; \n   int numlen = fiboword.length( ) ;\n   double infocontent = 0 ;\n   for ( std::pair<char , int> p : frequencies ) {\n      double freq = static_cast<double>( p.second ) / numlen ;\n      infocontent += freq * log2( freq ) ;\n   }\n   infocontent *= -1 ;\n   return infocontent ;\n}\n\nvoid printLine( std::string &fiboword , int n ) {\n   std::cout << std::setw( 5 ) << std::left << n ;\n   std::cout << std::setw( 12 ) << std::right << fiboword.size( ) ;\n   std::cout << \"  \" << std::setw( 16 ) << std::setprecision( 13 ) \n      << std::left << find_entropy( fiboword ) ;\n   std::cout << \"\\n\" ;\n}\n\nint main( ) {\n   std::cout << std::setw( 5 ) << std::left << \"N\" ;\n   std::cout << std::setw( 12 ) << std::right << \"length\" ;\n   std::cout << \"  \" << std::setw( 16 ) << std::left << \"entropy\" ; \n   std::cout << \"\\n\" ;\n   std::string firststring ( \"1\" ) ;\n   int n = 1 ;\n   printLine( firststring , n ) ;\n   std::string secondstring( \"0\" ) ;\n   n++ ;\n   printLine( secondstring , n ) ;\n   while ( n < 37 ) {\n      std::string resultstring = firststring + secondstring ;\n      firststring.assign( secondstring ) ;\n      secondstring.assign( resultstring ) ;\n      n++ ;\n      printLine( resultstring , n ) ;\n   }\n   return 0 ;\n}", "gold": "import java.util.*;\n\npublic class FWord {\n    private  String fWord0 = \"\";\n    private  String fWord1 = \"\";\n\n    private String nextFWord () {\n        final String result;\n        \n        if ( \"\".equals ( fWord1 ) )      result = \"1\";\n        else if ( \"\".equals ( fWord0 ) ) result = \"0\";\n        else                             result = fWord1 + fWord0;\n\n        fWord0 = fWord1;\n        fWord1 = result;\n\n        return result;\n    }\n\n    public static double entropy ( final String source ) {\n        final int                        length = source.length ();\n        final Map < Character, Integer > counts = new HashMap < Character, Integer > ();\n         double                     result = 0.0;\n \n        for ( int i = 0; i < length; i++ ) {\n            final char c = source.charAt ( i );\n\n            if ( counts.containsKey ( c ) ) counts.put ( c, counts.get ( c ) + 1 );\n            else                            counts.put ( c, 1 );\n        }\n\n        for ( final int count : counts.values () ) {\n            final double proportion = ( double ) count / length;\n\n            result -= proportion * ( Math.log ( proportion ) / Math.log ( 2 ) );\n        }\n\n        return result;\n    }\n\n    public static void main ( final String [] args ) {\n        final FWord fWord = new FWord ();\n\n        for ( int i = 0; i < 37;  ) {\n            final String word = fWord.nextFWord ();\n\n            System.out.printf ( \"%3d %10d %s %n\", ++i, word.length (), entropy ( word ) );\n        }\n    }\n}", "llm": "dsc-7b", "output": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.stream.IntStream;\nimport java.lang.Math;\nimport java.io.PrintStream;\nimport java.util.Formatter;\n\npublic class Main {\n    static double log2(double number) {\n        return (Math.log(number) / Math.log(2));\n    }\n\n    static double find_entropy(String fiboword) {\n        Map<Character, Integer> frequencies = new HashMap<>();\n        fiboword.chars().forEach(c -> frequencies.merge((char) c, 1, Integer::sum));\n        int numlen = fiboword.length();\n        double infocontent = 0;\n        for (Map.Entry<Character, Integer> entry : frequencies.entrySet()) {\n            double freq = (double) entry.getValue() / numlen;\n            infocontent += freq * log2(freq);\n        }\n        infocontent *= -1;\n        return infocontent;\n    }\n\n    static void printLine(String fiboword, int n, PrintStream out) {\n        new Formatter(out).format(\"%-5s%-12d%16.13f\\n\", n, fiboword.length(), find_entropy(fiboword));\n    }\n\n    public static void main(String[] args) {\n        PrintStream out = System.out;\n        out.printf(\"%-5s%-12s%16s\\n\", \"N\", \"length\", \"entropy\");\n        String firstString = \"1\";\n        int n = 1;\n        printLine(firstString, n, out);\n        String secondString = \"0\";\n        n++;\n        printLine(secondString, n, out);\n        while (n < 37) {\n            String resultString = firstString + secondString;\n            firstString = secondString;\n            secondString = resultString;\n            n++;\n            printLine(resultString, n, out);\n        }\n    }\n}", "index": 60}
{"lang": "C++, Java", "input": "#include <string>\n#include <map>\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\n\ndouble log2( double number ) {\n   return ( log( number ) / log( 2 ) ) ;\n}\n\ndouble find_entropy( std::string & fiboword ) {\n   std::map<char , int> frequencies ;\n   std::for_each( fiboword.begin( ) , fiboword.end( ) ,\n\t [ & frequencies ]( char c ) { frequencies[ c ]++ ; } ) ; \n   int numlen = fiboword.length( ) ;\n   double infocontent = 0 ;\n   for ( std::pair<char , int> p : frequencies ) {\n      double freq = static_cast<double>( p.second ) / numlen ;\n      infocontent += freq * log2( freq ) ;\n   }\n   infocontent *= -1 ;\n   return infocontent ;\n}\n\nvoid printLine( std::string &fiboword , int n ) {\n   std::cout << std::setw( 5 ) << std::left << n ;\n   std::cout << std::setw( 12 ) << std::right << fiboword.size( ) ;\n   std::cout << \"  \" << std::setw( 16 ) << std::setprecision( 13 ) \n      << std::left << find_entropy( fiboword ) ;\n   std::cout << \"\\n\" ;\n}\n\nint main( ) {\n   std::cout << std::setw( 5 ) << std::left << \"N\" ;\n   std::cout << std::setw( 12 ) << std::right << \"length\" ;\n   std::cout << \"  \" << std::setw( 16 ) << std::left << \"entropy\" ; \n   std::cout << \"\\n\" ;\n   std::string firststring ( \"1\" ) ;\n   int n = 1 ;\n   printLine( firststring , n ) ;\n   std::string secondstring( \"0\" ) ;\n   n++ ;\n   printLine( secondstring , n ) ;\n   while ( n < 37 ) {\n      std::string resultstring = firststring + secondstring ;\n      firststring.assign( secondstring ) ;\n      secondstring.assign( resultstring ) ;\n      n++ ;\n      printLine( resultstring , n ) ;\n   }\n   return 0 ;\n}", "gold": "import java.util.*;\n\npublic class FWord {\n    private  String fWord0 = \"\";\n    private  String fWord1 = \"\";\n\n    private String nextFWord () {\n        final String result;\n        \n        if ( \"\".equals ( fWord1 ) )      result = \"1\";\n        else if ( \"\".equals ( fWord0 ) ) result = \"0\";\n        else                             result = fWord1 + fWord0;\n\n        fWord0 = fWord1;\n        fWord1 = result;\n\n        return result;\n    }\n\n    public static double entropy ( final String source ) {\n        final int                        length = source.length ();\n        final Map < Character, Integer > counts = new HashMap < Character, Integer > ();\n         double                     result = 0.0;\n \n        for ( int i = 0; i < length; i++ ) {\n            final char c = source.charAt ( i );\n\n            if ( counts.containsKey ( c ) ) counts.put ( c, counts.get ( c ) + 1 );\n            else                            counts.put ( c, 1 );\n        }\n\n        for ( final int count : counts.values () ) {\n            final double proportion = ( double ) count / length;\n\n            result -= proportion * ( Math.log ( proportion ) / Math.log ( 2 ) );\n        }\n\n        return result;\n    }\n\n    public static void main ( final String [] args ) {\n        final FWord fWord = new FWord ();\n\n        for ( int i = 0; i < 37;  ) {\n            final String word = fWord.nextFWord ();\n\n            System.out.printf ( \"%3d %10d %s %n\", ++i, word.length (), entropy ( word ) );\n        }\n    }\n}", "llm": "dsc2-16b", "output": "import java.util.*;\nimport java.util.function.Consumer;\nimport java.lang.Math;\nimport java.text.DecimalFormat;\n\nclass Main {\n    static double log2(double number) {\n        return Math.log(number) / Math.log(2);\n    }\n\n    static double findEntropy(String fiboword) {\n        Map<Character, Integer> frequencies = new HashMap<>();\n        Consumer<Character> addToFrequencies = c -> frequencies.put(c, frequencies.getOrDefault(c, 0) + 1);\n        fiboword.chars().forEach(c -> addToFrequencies.accept((char) c));\n        int numlen = fiboword.length();\n        double infocontent = 0;\n        for (Map.Entry<Character, Integer> p : frequencies.entrySet()) {\n            double freq = (double) p.getValue() / numlen;\n            infocontent += freq * log2(freq);\n        }\n        return -infocontent;\n    }\n\n    static void printLine(String fiboword, int n) {\n        DecimalFormat df = new DecimalFormat(\"0.0000000000000\");\n        System.out.printf(\"%5s %12d  %16s\\n\", n, fiboword.length(), df.format(findEntropy(fiboword)));\n    }\n\n    public static void main(String[] args) {\n        System.out.printf(\"%5s %12s  %16s\\n\", \"N\", \"length\", \"entropy\");\n        String firststring = \"1\";\n        int n = 1;\n        printLine(firststring, n);\n        String secondstring = \"0\";\n        n++;\n        printLine(secondstring, n);\n        while (n < 37) {\n            String resultstring = firststring + secondstring;\n            firststring = secondstring;\n            secondstring = resultstring;\n            n++;\n            printLine(resultstring, n);\n        }\n    }\n}", "index": 61}
{"lang": "C++, Java", "input": "#include <string>\n#include <map>\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\n\ndouble log2( double number ) {\n   return ( log( number ) / log( 2 ) ) ;\n}\n\ndouble find_entropy( std::string & fiboword ) {\n   std::map<char , int> frequencies ;\n   std::for_each( fiboword.begin( ) , fiboword.end( ) ,\n\t [ & frequencies ]( char c ) { frequencies[ c ]++ ; } ) ; \n   int numlen = fiboword.length( ) ;\n   double infocontent = 0 ;\n   for ( std::pair<char , int> p : frequencies ) {\n      double freq = static_cast<double>( p.second ) / numlen ;\n      infocontent += freq * log2( freq ) ;\n   }\n   infocontent *= -1 ;\n   return infocontent ;\n}\n\nvoid printLine( std::string &fiboword , int n ) {\n   std::cout << std::setw( 5 ) << std::left << n ;\n   std::cout << std::setw( 12 ) << std::right << fiboword.size( ) ;\n   std::cout << \"  \" << std::setw( 16 ) << std::setprecision( 13 ) \n      << std::left << find_entropy( fiboword ) ;\n   std::cout << \"\\n\" ;\n}\n\nint main( ) {\n   std::cout << std::setw( 5 ) << std::left << \"N\" ;\n   std::cout << std::setw( 12 ) << std::right << \"length\" ;\n   std::cout << \"  \" << std::setw( 16 ) << std::left << \"entropy\" ; \n   std::cout << \"\\n\" ;\n   std::string firststring ( \"1\" ) ;\n   int n = 1 ;\n   printLine( firststring , n ) ;\n   std::string secondstring( \"0\" ) ;\n   n++ ;\n   printLine( secondstring , n ) ;\n   while ( n < 37 ) {\n      std::string resultstring = firststring + secondstring ;\n      firststring.assign( secondstring ) ;\n      secondstring.assign( resultstring ) ;\n      n++ ;\n      printLine( resultstring , n ) ;\n   }\n   return 0 ;\n}", "gold": "import java.util.*;\n\npublic class FWord {\n    private  String fWord0 = \"\";\n    private  String fWord1 = \"\";\n\n    private String nextFWord () {\n        final String result;\n        \n        if ( \"\".equals ( fWord1 ) )      result = \"1\";\n        else if ( \"\".equals ( fWord0 ) ) result = \"0\";\n        else                             result = fWord1 + fWord0;\n\n        fWord0 = fWord1;\n        fWord1 = result;\n\n        return result;\n    }\n\n    public static double entropy ( final String source ) {\n        final int                        length = source.length ();\n        final Map < Character, Integer > counts = new HashMap < Character, Integer > ();\n         double                     result = 0.0;\n \n        for ( int i = 0; i < length; i++ ) {\n            final char c = source.charAt ( i );\n\n            if ( counts.containsKey ( c ) ) counts.put ( c, counts.get ( c ) + 1 );\n            else                            counts.put ( c, 1 );\n        }\n\n        for ( final int count : counts.values () ) {\n            final double proportion = ( double ) count / length;\n\n            result -= proportion * ( Math.log ( proportion ) / Math.log ( 2 ) );\n        }\n\n        return result;\n    }\n\n    public static void main ( final String [] args ) {\n        final FWord fWord = new FWord ();\n\n        for ( int i = 0; i < 37;  ) {\n            final String word = fWord.nextFWord ();\n\n            System.out.printf ( \"%3d %10d %s %n\", ++i, word.length (), entropy ( word ) );\n        }\n    }\n}", "llm": "magic-7b", "output": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.stream.IntStream;\nimport java.lang.Math;\nimport java.text.DecimalFormat;\n\npublic class Main {\n    public static double log2(double number) {\n        return (Math.log(number) / Math.log(2));\n    }\n\n    public static double find_entropy(String fiboword) {\n        Map<Character, Integer> frequencies = new HashMap<>();\n        fiboword.chars().forEach(c -> frequencies.merge((char) c, 1, Integer::sum));\n        int numlen = fiboword.length();\n        double infocontent = 0;\n        for (Map.Entry<Character, Integer> p : frequencies.entrySet()) {\n            double freq = (double) p.getValue() / numlen;\n            infocontent += freq * log2(freq);\n        }\n        infocontent *= -1;\n        return infocontent;\n    }\n\n    public static void printLine(String fiboword, int n) {\n        DecimalFormat df = new DecimalFormat(\"#.#############\");\n        System.out.printf(\"%-5s%12s%16s\\n\", n, fiboword.length(), df.format(find_entropy(fiboword)));\n    }\n\n    public static void main(String[] args) {\n        System.out.printf(\"%-5s%12s%16s\\n\", \"N\", \"length\", \"entropy\");\n        String firststring = \"1\";\n        int n = 1;\n        printLine(firststring, n);\n        String secondstring = \"0\";\n        n++;\n        printLine(secondstring, n);\n        while (n < 37) {\n            String resultstring = firststring + secondstring;\n            firststring = secondstring;\n            secondstring = resultstring;\n            n++;\n            printLine(resultstring, n);\n        }\n    }\n}", "index": 62}
{"lang": "C, Java", "input": "#include <unistd.h>\n#include <sys/types.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <err.h>\n\n\nint read_file_line(const char *path, int line_no)\n{\n\tstruct stat s;\n\tchar *buf;\n\toff_t start = -1, end = -1;\n\tsize_t i;\n\tint ln, fd, ret = 1;\n\n\tif (line_no == 1) start = 0;\n\telse if (line_no < 1){\n\t\twarn(\"line_no too small\");\n\t\treturn 0; \n\t}\n\n\tline_no--; \n\n\tfd = open(path, O_RDONLY);\n\tfstat(fd, &s);\n\n\t\n\tbuf = mmap(0, s.st_size, PROT_READ, MAP_PRIVATE, fd, 0);\n\n\t\n\tmadvise(buf, s.st_size, MADV_SEQUENTIAL);\n\n\tfor (i = ln = 0; i < s.st_size && ln <= line_no; i++) {\n\t\tif (buf[i] != '\\n') continue;\n\n\t\tif (++ln == line_no) start = i + 1;\n\t\telse if (ln == line_no + 1) end = i + 1;\n\t}\n\n\tif (start >= s.st_size || start < 0) {\n\t\twarn(\"file does not have line %d\", line_no + 1);\n\t\tret = 0;\n\t} else {\n\t\t\n\t}\n\n\tmunmap(buf, s.st_size);\n\tclose(fd);\n\n\treturn ret;\n}", "gold": "package linenbr7;\n\nimport java.io.*;\n\npublic class LineNbr7 {\n\n    public static void main(String[] args) throws Exception {\n        File f = new File(args[0]);\n        if (!f.isFile() || !f.canRead())\n            throw new IOException(\"can't read \" + args[0]);\n\n        BufferedReader br = new BufferedReader(new FileReader(f));\n        try (LineNumberReader lnr = new LineNumberReader(br)) {\n            String line = null;\n            int lnum = 0;\n            while ((line = lnr.readLine()) != null\n                    && (lnum = lnr.getLineNumber()) < 7) {\n            }\n\n            switch (lnum) {\n                case 0:\n                    System.out.println(\"the file has zero length\");\n                    break;\n                case 7:\n                    boolean empty = \"\".equals(line);\n                    System.out.println(\"line 7: \" + (empty ? \"empty\" : line));\n                    break;\n                default:\n                    System.out.println(\"the file has only \" + lnum + \" line(s)\");\n            }\n        }\n    }\n}", "llm": "dsc-33b", "output": "import java.io.RandomAccessFile;\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.charset.StandardCharsets;\n\npublic class Main {\n    public static int readFileLine(String path, int lineNo) {\n        File file = new File(path);\n        int start = -1, end = -1;\n        int ln, ret = 1;\n\n        if (lineNo == 1) start = 0;\n        else if (lineNo < 1){\n            System.err.println(\"line_no too small\");\n            return 0; \n        }\n\n        lineNo--; \n\n        try (RandomAccessFile raf = new RandomAccessFile(file, \"r\")) {\n            FileChannel channel = raf.getChannel();\n            MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_ONLY, 0, channel.size());\n\n            for (int i = 0, n = (int) channel.size(); i < n; i++) {\n                if (buffer.get() != '\\n') continue;\n\n                if (++ln == lineNo) start = i + 1;\n                else if (ln == lineNo + 1) end = i + 1;\n            }\n\n            if (start >= channel.size() || start < 0) {\n                System.err.printf(\"file does not have line %d\\n\", lineNo + 1);\n                ret = 0;\n            }\n\n            channel.close();\n            raf.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        return ret;\n    }\n}", "index": 63}
{"lang": "C, Java", "input": "#include <unistd.h>\n#include <sys/types.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <err.h>\n\n\nint read_file_line(const char *path, int line_no)\n{\n\tstruct stat s;\n\tchar *buf;\n\toff_t start = -1, end = -1;\n\tsize_t i;\n\tint ln, fd, ret = 1;\n\n\tif (line_no == 1) start = 0;\n\telse if (line_no < 1){\n\t\twarn(\"line_no too small\");\n\t\treturn 0; \n\t}\n\n\tline_no--; \n\n\tfd = open(path, O_RDONLY);\n\tfstat(fd, &s);\n\n\t\n\tbuf = mmap(0, s.st_size, PROT_READ, MAP_PRIVATE, fd, 0);\n\n\t\n\tmadvise(buf, s.st_size, MADV_SEQUENTIAL);\n\n\tfor (i = ln = 0; i < s.st_size && ln <= line_no; i++) {\n\t\tif (buf[i] != '\\n') continue;\n\n\t\tif (++ln == line_no) start = i + 1;\n\t\telse if (ln == line_no + 1) end = i + 1;\n\t}\n\n\tif (start >= s.st_size || start < 0) {\n\t\twarn(\"file does not have line %d\", line_no + 1);\n\t\tret = 0;\n\t} else {\n\t\t\n\t}\n\n\tmunmap(buf, s.st_size);\n\tclose(fd);\n\n\treturn ret;\n}", "gold": "package linenbr7;\n\nimport java.io.*;\n\npublic class LineNbr7 {\n\n    public static void main(String[] args) throws Exception {\n        File f = new File(args[0]);\n        if (!f.isFile() || !f.canRead())\n            throw new IOException(\"can't read \" + args[0]);\n\n        BufferedReader br = new BufferedReader(new FileReader(f));\n        try (LineNumberReader lnr = new LineNumberReader(br)) {\n            String line = null;\n            int lnum = 0;\n            while ((line = lnr.readLine()) != null\n                    && (lnum = lnr.getLineNumber()) < 7) {\n            }\n\n            switch (lnum) {\n                case 0:\n                    System.out.println(\"the file has zero length\");\n                    break;\n                case 7:\n                    boolean empty = \"\".equals(line);\n                    System.out.println(\"line 7: \" + (empty ? \"empty\" : line));\n                    break;\n                default:\n                    System.out.println(\"the file has only \" + lnum + \" line(s)\");\n            }\n        }\n    }\n}", "llm": "q2.5-1.5b", "output": "public int read_file_line(String path, int line_no) {\n    try {\n        File file = new File(path);\n        RandomAccessFile raf = new RandomAccessFile(file, \"r\");\n        long start = -1, end = -1;\n        int ln = 0;\n        int ret = 1;\n\n        if (line_no == 1) start = 0;\n        else if (line_no < 1) {\n            System.err.println(\"line_no too small\");\n            return 0; \n        }\n\n        line_no--;\n\n        long fileSize = file.length();\n        byte[] buffer = new byte[(int) fileSize];\n        raf.read(buffer);\n\n        for (int i = 0; i < fileSize && ln <= line_no; i++) {\n            if (buffer[i] != '\\n') continue;\n\n            if (++ln == line_no) start = i + 1;\n            else if (ln == line_no + 1) end = i + 1;\n        }\n\n        if (start >= fileSize || start < 0) {\n            System.err.println(\"file does not have line \" + (line_no + 1));\n            ret = 0;\n        } else {\n            \n        }\n\n        raf.close();\n\n        return ret;\n    } catch (IOException e) {\n        e.printStackTrace();\n        return 0;\n    }\n}", "index": 64}
{"lang": "C, Java", "input": "#include <unistd.h>\n#include <sys/types.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <err.h>\n\n\nint read_file_line(const char *path, int line_no)\n{\n\tstruct stat s;\n\tchar *buf;\n\toff_t start = -1, end = -1;\n\tsize_t i;\n\tint ln, fd, ret = 1;\n\n\tif (line_no == 1) start = 0;\n\telse if (line_no < 1){\n\t\twarn(\"line_no too small\");\n\t\treturn 0; \n\t}\n\n\tline_no--; \n\n\tfd = open(path, O_RDONLY);\n\tfstat(fd, &s);\n\n\t\n\tbuf = mmap(0, s.st_size, PROT_READ, MAP_PRIVATE, fd, 0);\n\n\t\n\tmadvise(buf, s.st_size, MADV_SEQUENTIAL);\n\n\tfor (i = ln = 0; i < s.st_size && ln <= line_no; i++) {\n\t\tif (buf[i] != '\\n') continue;\n\n\t\tif (++ln == line_no) start = i + 1;\n\t\telse if (ln == line_no + 1) end = i + 1;\n\t}\n\n\tif (start >= s.st_size || start < 0) {\n\t\twarn(\"file does not have line %d\", line_no + 1);\n\t\tret = 0;\n\t} else {\n\t\t\n\t}\n\n\tmunmap(buf, s.st_size);\n\tclose(fd);\n\n\treturn ret;\n}", "gold": "package linenbr7;\n\nimport java.io.*;\n\npublic class LineNbr7 {\n\n    public static void main(String[] args) throws Exception {\n        File f = new File(args[0]);\n        if (!f.isFile() || !f.canRead())\n            throw new IOException(\"can't read \" + args[0]);\n\n        BufferedReader br = new BufferedReader(new FileReader(f));\n        try (LineNumberReader lnr = new LineNumberReader(br)) {\n            String line = null;\n            int lnum = 0;\n            while ((line = lnr.readLine()) != null\n                    && (lnum = lnr.getLineNumber()) < 7) {\n            }\n\n            switch (lnum) {\n                case 0:\n                    System.out.println(\"the file has zero length\");\n                    break;\n                case 7:\n                    boolean empty = \"\".equals(line);\n                    System.out.println(\"line 7: \" + (empty ? \"empty\" : line));\n                    break;\n                default:\n                    System.out.println(\"the file has only \" + lnum + \" line(s)\");\n            }\n        }\n    }\n}", "llm": "magic-7b", "output": "import java.io.File;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\n\npublic class Main {\n    public static int read_file_line(String path, int line_no) {\n        File file = new File(path);\n        long start = -1, end = -1;\n        int ln = 0, ret = 1;\n\n        if (line_no == 1) start = 0;\n        else if (line_no < 1) {\n            System.out.println(\"line_no too small\");\n            return 0;\n        }\n\n        line_no--;\n\n        try (RandomAccessFile raf = new RandomAccessFile(file, \"r\");\n             FileChannel channel = raf.getChannel()) {\n\n            MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_ONLY, 0, file.length());\n\n            for (int i = 0; i < buffer.limit(); i++) {\n                if (buffer.get(i) != '\\n') continue;\n\n                if (++ln == line_no) start = i + 1;\n                else if (ln == line_no + 1) end = i + 1;\n            }\n\n            if (start >= file.length() || start < 0) {\n                System.out.println(\"file does not have line \" + (line_no + 1));\n                ret = 0;\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        return ret;\n    }\n}", "index": 65}
{"lang": "C++, Java", "input": "#include <vector>\n#include <sstream>\n#include <iostream>\n#include <iterator>\n#include <stdlib.h>\n#include <string.h>\n\nusing namespace std;\n\nstruct node\n{\n    int val;\n    unsigned char neighbors;\n};\n\nclass nSolver\n{\npublic:\n    nSolver()\n    {\n\tdx[0] = -2; dy[0] = -2; dx[1] = -2; dy[1] =  2;\n\tdx[2] =  2; dy[2] = -2; dx[3] =  2; dy[3] =  2;\n\tdx[4] = -3; dy[4] =  0; dx[5] =  3; dy[5] =  0; \n\tdx[6] =  0; dy[6] = -3; dx[7] =  0; dy[7] =  3;\n    }\n\n    void solve( vector<string>& puzz, int max_wid )\n    {\n\tif( puzz.size() < 1 ) return;\n\twid = max_wid; hei = static_cast<int>( puzz.size() ) / wid;\n\tint len = wid * hei, c = 0; max = len;\n\tarr = new node[len]; memset( arr, 0, len * sizeof( node ) );\n\n\tfor( vector<string>::iterator i = puzz.begin(); i != puzz.end(); i++ )\n\t{\n\t    if( ( *i ) == \"*\" ) { max--; arr[c++].val = -1; continue; }\n\t    arr[c].val = atoi( ( *i ).c_str() );\n\t    c++;\n\t}\n\n\tsolveIt(); c = 0;\n\tfor( vector<string>::iterator i = puzz.begin(); i != puzz.end(); i++ )\n\t{\n\t    if( ( *i ) == \".\" )\n\t    {\n\t\tostringstream o; o << arr[c].val;\n\t\t( *i ) = o.str();\n\t    }\n\t    c++;\n\t}\n\tdelete [] arr;\n    }\n\nprivate:\n    bool search( int x, int y, int w )\n    {\n\tif( w > max ) return true;\n\n\tnode* n = &arr[x + y * wid];\n\tn->neighbors = getNeighbors( x, y );\n\n\tfor( int d = 0; d < 8; d++ )\n\t{\n\t    if( n->neighbors & ( 1 << d ) )\n\t    {\n\t\tint a = x + dx[d], b = y + dy[d];\n\t\tif( arr[a + b * wid].val == 0 )\n\t\t{\n\t\t    arr[a + b * wid].val = w;\n\t\t    if( search( a, b, w + 1 ) ) return true;\n\t\t    arr[a + b * wid].val = 0;\n\t\t}\n\t    }\n\t}\n\treturn false;\n    }\n\n    unsigned char getNeighbors( int x, int y )\n    {\n\tunsigned char c = 0; int a, b;\n\tfor( int xx = 0; xx < 8; xx++ )\n\t{\n\t    a = x + dx[xx], b = y + dy[xx];\n\t    if( a < 0 || b < 0 || a >= wid || b >= hei ) continue;\n\t    if( arr[a + b * wid].val > -1 ) c |= ( 1 << xx );\n\t}\n\treturn c;\n    }\n\n    void solveIt()\n    {\n\tint x, y, z; findStart( x, y, z );\n\tif( z == 99999 ) { cout << \"\\nCan't find start point!\\n\"; return; }\n\tsearch( x, y, z + 1 );\n    }\n\n    void findStart( int& x, int& y, int& z )\n    {\n\tfor( int b = 0; b < hei; b++ )\n\t    for( int a = 0; a < wid; a++ )\n\t\tif( arr[a + wid * b].val == 0 ) \n\t\t{ \n\t\t    x = a; y = b; z = 1;\n\t\t    arr[a + wid * b].val = z;\n\t\t    return;\n\t\t}\n    }\n\n    int wid, hei, max, dx[8], dy[8];\n    node* arr;\n};\n\nint main( int argc, char* argv[] )\n{\n    int wid; string p;\n    p = \"* . . * . . * . . . . . . . . . . . . . . * . . . . . * * * . . . * * * * * . * * *\"; wid = 7;\n    istringstream iss( p ); vector<string> puzz;\n    copy( istream_iterator<string>( iss ), istream_iterator<string>(), back_inserter<vector<string> >( puzz ) );\n    nSolver s; s.solve( puzz, wid );\n    int c = 0;\n    for( vector<string>::iterator i = puzz.begin(); i != puzz.end(); i++ )\n    {\n\tif( ( *i ) != \"*\" && ( *i ) != \".\" )\n\t{\n\t    if( atoi( ( *i ).c_str() ) < 10 ) cout << \"0\";\n\t    cout << ( *i ) << \" \";\n\t}\n\telse cout << \"   \";\n\tif( ++c >= wid ) { cout << endl; c = 0; }\n    }\n    cout << endl << endl;\n    return system( \"pause\" );\n}", "gold": "import java.util.*;\n\npublic class Hopido {\n\n    final static String[] board = {\n        \".00.00.\",\n        \"0000000\",\n        \"0000000\",\n        \".00000.\",\n        \"..000..\",\n        \"...0...\"};\n\n    final static int[][] moves = {{-3, 0}, {0, 3}, {3, 0}, {0, -3},\n    {2, 2}, {2, -2}, {-2, 2}, {-2, -2}};\n    static int[][] grid;\n    static int totalToFill;\n\n    public static void main(String[] args) {\n        int nRows = board.length + 6;\n        int nCols = board[0].length() + 6;\n\n        grid = new int[nRows][nCols];\n\n        for (int r = 0; r < nRows; r++) {\n            Arrays.fill(grid[r], -1);\n            for (int c = 3; c < nCols - 3; c++)\n                if (r >= 3 && r < nRows - 3) {\n                    if (board[r - 3].charAt(c - 3) == '0') {\n                        grid[r][c] = 0;\n                        totalToFill++;\n                    }\n                }\n        }\n\n        int pos = -1, r, c;\n        do {\n            do {\n                pos++;\n                r = pos / nCols;\n                c = pos % nCols;\n            } while (grid[r][c] == -1);\n\n            grid[r][c] = 1;\n            if (solve(r, c, 2))\n                break;\n            grid[r][c] = 0;\n\n        } while (pos < nRows * nCols);\n\n        printResult();\n    }\n\n    static boolean solve(int r, int c, int count) {\n        if (count > totalToFill)\n            return true;\n\n        List<int[]> nbrs = neighbors(r, c);\n\n        if (nbrs.isEmpty() && count != totalToFill)\n            return false;\n\n        Collections.sort(nbrs, (a, b) -> a[2] - b[2]);\n\n        for (int[] nb : nbrs) {\n            r = nb[0];\n            c = nb[1];\n            grid[r][c] = count;\n            if (solve(r, c, count + 1))\n                return true;\n            grid[r][c] = 0;\n        }\n\n        return false;\n    }\n\n    static List<int[]> neighbors(int r, int c) {\n        List<int[]> nbrs = new ArrayList<>();\n\n        for (int[] m : moves) {\n            int x = m[0];\n            int y = m[1];\n            if (grid[r + y][c + x] == 0) {\n                int num = countNeighbors(r + y, c + x) - 1;\n                nbrs.add(new int[]{r + y, c + x, num});\n            }\n        }\n        return nbrs;\n    }\n\n    static int countNeighbors(int r, int c) {\n        int num = 0;\n        for (int[] m : moves)\n            if (grid[r + m[1]][c + m[0]] == 0)\n                num++;\n        return num;\n    }\n\n    static void printResult() {\n        for (int[] row : grid) {\n            for (int i : row) {\n                if (i == -1)\n                    System.out.printf(\"%2s \", ' ');\n                else\n                    System.out.printf(\"%2d \", i);\n            }\n            System.out.println();\n        }\n    }\n}", "llm": "dsc-33b", "output": "import java.util.*;\nimport java.io.*;\n\npublic class NSolver {\n    private int[] dx = new int[]{-2, -2, 2, 2, -3, 3, 0, 0};\n    private int[] dy = new int[]{-2, 2, -2, 2, 0, 0, -3, 3};\n    private int wid, hei, max;\n    private Node[] arr;\n\n    public NSolver() {\n    }\n\n    public void solve(List<String> puzz, int max_wid) {\n        if (puzz.size() < 1) return;\n        wid = max_wid;\n        hei = puzz.size() / wid;\n        int len = wid * hei, c = 0;\n        max = len;\n        arr = new Node[len];\n\n        for (String i : puzz) {\n            if (i.equals(\"*\")) {\n                max--;\n                arr[c++].val = -1;\n                continue;\n            }\n            arr[c].val = Integer.parseInt(i);\n            c++;\n        }\n\n        solveIt();\n        c = 0;\n        for (String i : puzz) {\n            if (i.equals(\".\")) {\n                puzz.set(c, String.valueOf(arr[c].val));\n            }\n            c++;\n        }\n    }\n\n    private boolean search(int x, int y, int w) {\n        if (w > max) return true;\n\n        Node n = arr[x + y * wid];\n        n.neighbors = getNeighbors(x, y);\n\n        for (int d = 0; d < 8; d++) {\n            if ((n.neighbors & (1 << d)) != 0) {\n                int a = x + dx[d], b = y + dy[d];\n                if (arr[a + b * wid].val == 0) {\n                    arr[a + b * wid].val = w;\n                    if (search(a, b, w + 1)) return true;\n                    arr[a + b * wid].val = 0;\n                }\n            }\n        }\n        return false;\n    }\n\n    private int getNeighbors(int x, int y) {\n        int c = 0, a, b;\n        for (int xx = 0; xx < 8; xx++) {\n            a = x + dx[xx];\n            b = y + dy[xx];\n            if (a < 0 || b < 0 || a >= wid || b >= hei) continue;\n            if (arr[a + b * wid].val > -1) c |= (1 << xx);\n        }\n        return c;\n    }\n\n    private void solveIt() {\n        int x, y, z;\n        findStart(x, y, z);\n        if (z == 99999) {\n            System.out.println(\"\\nCan't find start point!\\n\");\n            return;\n        }\n        search(x, y, z + 1);\n    }\n\n    private void findStart(int x, int y, int z) {\n        for (int b = 0; b < hei; b++)\n            for (int a = 0; a < wid; a++)\n                if (arr[a + wid * b].val == 0) {\n                    x = a;\n                    y = b;\n                    z = 1;\n                    arr[a + wid * b].val = z;\n                    return;\n                }\n    }\n\n    private class Node {\n        int val;\n        int neighbors;\n    }\n}", "index": 66}
{"lang": "C++, Java", "input": "#include <vector>\n#include <sstream>\n#include <iostream>\n#include <iterator>\n#include <stdlib.h>\n#include <string.h>\n\nusing namespace std;\n\nstruct node\n{\n    int val;\n    unsigned char neighbors;\n};\n\nclass nSolver\n{\npublic:\n    nSolver()\n    {\n\tdx[0] = -2; dy[0] = -2; dx[1] = -2; dy[1] =  2;\n\tdx[2] =  2; dy[2] = -2; dx[3] =  2; dy[3] =  2;\n\tdx[4] = -3; dy[4] =  0; dx[5] =  3; dy[5] =  0; \n\tdx[6] =  0; dy[6] = -3; dx[7] =  0; dy[7] =  3;\n    }\n\n    void solve( vector<string>& puzz, int max_wid )\n    {\n\tif( puzz.size() < 1 ) return;\n\twid = max_wid; hei = static_cast<int>( puzz.size() ) / wid;\n\tint len = wid * hei, c = 0; max = len;\n\tarr = new node[len]; memset( arr, 0, len * sizeof( node ) );\n\n\tfor( vector<string>::iterator i = puzz.begin(); i != puzz.end(); i++ )\n\t{\n\t    if( ( *i ) == \"*\" ) { max--; arr[c++].val = -1; continue; }\n\t    arr[c].val = atoi( ( *i ).c_str() );\n\t    c++;\n\t}\n\n\tsolveIt(); c = 0;\n\tfor( vector<string>::iterator i = puzz.begin(); i != puzz.end(); i++ )\n\t{\n\t    if( ( *i ) == \".\" )\n\t    {\n\t\tostringstream o; o << arr[c].val;\n\t\t( *i ) = o.str();\n\t    }\n\t    c++;\n\t}\n\tdelete [] arr;\n    }\n\nprivate:\n    bool search( int x, int y, int w )\n    {\n\tif( w > max ) return true;\n\n\tnode* n = &arr[x + y * wid];\n\tn->neighbors = getNeighbors( x, y );\n\n\tfor( int d = 0; d < 8; d++ )\n\t{\n\t    if( n->neighbors & ( 1 << d ) )\n\t    {\n\t\tint a = x + dx[d], b = y + dy[d];\n\t\tif( arr[a + b * wid].val == 0 )\n\t\t{\n\t\t    arr[a + b * wid].val = w;\n\t\t    if( search( a, b, w + 1 ) ) return true;\n\t\t    arr[a + b * wid].val = 0;\n\t\t}\n\t    }\n\t}\n\treturn false;\n    }\n\n    unsigned char getNeighbors( int x, int y )\n    {\n\tunsigned char c = 0; int a, b;\n\tfor( int xx = 0; xx < 8; xx++ )\n\t{\n\t    a = x + dx[xx], b = y + dy[xx];\n\t    if( a < 0 || b < 0 || a >= wid || b >= hei ) continue;\n\t    if( arr[a + b * wid].val > -1 ) c |= ( 1 << xx );\n\t}\n\treturn c;\n    }\n\n    void solveIt()\n    {\n\tint x, y, z; findStart( x, y, z );\n\tif( z == 99999 ) { cout << \"\\nCan't find start point!\\n\"; return; }\n\tsearch( x, y, z + 1 );\n    }\n\n    void findStart( int& x, int& y, int& z )\n    {\n\tfor( int b = 0; b < hei; b++ )\n\t    for( int a = 0; a < wid; a++ )\n\t\tif( arr[a + wid * b].val == 0 ) \n\t\t{ \n\t\t    x = a; y = b; z = 1;\n\t\t    arr[a + wid * b].val = z;\n\t\t    return;\n\t\t}\n    }\n\n    int wid, hei, max, dx[8], dy[8];\n    node* arr;\n};\n\nint main( int argc, char* argv[] )\n{\n    int wid; string p;\n    p = \"* . . * . . * . . . . . . . . . . . . . . * . . . . . * * * . . . * * * * * . * * *\"; wid = 7;\n    istringstream iss( p ); vector<string> puzz;\n    copy( istream_iterator<string>( iss ), istream_iterator<string>(), back_inserter<vector<string> >( puzz ) );\n    nSolver s; s.solve( puzz, wid );\n    int c = 0;\n    for( vector<string>::iterator i = puzz.begin(); i != puzz.end(); i++ )\n    {\n\tif( ( *i ) != \"*\" && ( *i ) != \".\" )\n\t{\n\t    if( atoi( ( *i ).c_str() ) < 10 ) cout << \"0\";\n\t    cout << ( *i ) << \" \";\n\t}\n\telse cout << \"   \";\n\tif( ++c >= wid ) { cout << endl; c = 0; }\n    }\n    cout << endl << endl;\n    return system( \"pause\" );\n}", "gold": "import java.util.*;\n\npublic class Hopido {\n\n    final static String[] board = {\n        \".00.00.\",\n        \"0000000\",\n        \"0000000\",\n        \".00000.\",\n        \"..000..\",\n        \"...0...\"};\n\n    final static int[][] moves = {{-3, 0}, {0, 3}, {3, 0}, {0, -3},\n    {2, 2}, {2, -2}, {-2, 2}, {-2, -2}};\n    static int[][] grid;\n    static int totalToFill;\n\n    public static void main(String[] args) {\n        int nRows = board.length + 6;\n        int nCols = board[0].length() + 6;\n\n        grid = new int[nRows][nCols];\n\n        for (int r = 0; r < nRows; r++) {\n            Arrays.fill(grid[r], -1);\n            for (int c = 3; c < nCols - 3; c++)\n                if (r >= 3 && r < nRows - 3) {\n                    if (board[r - 3].charAt(c - 3) == '0') {\n                        grid[r][c] = 0;\n                        totalToFill++;\n                    }\n                }\n        }\n\n        int pos = -1, r, c;\n        do {\n            do {\n                pos++;\n                r = pos / nCols;\n                c = pos % nCols;\n            } while (grid[r][c] == -1);\n\n            grid[r][c] = 1;\n            if (solve(r, c, 2))\n                break;\n            grid[r][c] = 0;\n\n        } while (pos < nRows * nCols);\n\n        printResult();\n    }\n\n    static boolean solve(int r, int c, int count) {\n        if (count > totalToFill)\n            return true;\n\n        List<int[]> nbrs = neighbors(r, c);\n\n        if (nbrs.isEmpty() && count != totalToFill)\n            return false;\n\n        Collections.sort(nbrs, (a, b) -> a[2] - b[2]);\n\n        for (int[] nb : nbrs) {\n            r = nb[0];\n            c = nb[1];\n            grid[r][c] = count;\n            if (solve(r, c, count + 1))\n                return true;\n            grid[r][c] = 0;\n        }\n\n        return false;\n    }\n\n    static List<int[]> neighbors(int r, int c) {\n        List<int[]> nbrs = new ArrayList<>();\n\n        for (int[] m : moves) {\n            int x = m[0];\n            int y = m[1];\n            if (grid[r + y][c + x] == 0) {\n                int num = countNeighbors(r + y, c + x) - 1;\n                nbrs.add(new int[]{r + y, c + x, num});\n            }\n        }\n        return nbrs;\n    }\n\n    static int countNeighbors(int r, int c) {\n        int num = 0;\n        for (int[] m : moves)\n            if (grid[r + m[1]][c + m[0]] == 0)\n                num++;\n        return num;\n    }\n\n    static void printResult() {\n        for (int[] row : grid) {\n            for (int i : row) {\n                if (i == -1)\n                    System.out.printf(\"%2s \", ' ');\n                else\n                    System.out.printf(\"%2d \", i);\n            }\n            System.out.println();\n        }\n    }\n}", "llm": "q2.5-7b", "output": "import java.util.*;\n\nclass Node {\n    int val;\n    byte neighbors;\n}\n\nclass NSolver {\n    private static final int[] dx = {-2, -2, 2, 2, -3, 3, 0, 0};\n    private static final int[] dy = {-2, 2, -2, 2, 0, 0, -3, 3};\n    private int wid, hei, max;\n    private Node[] arr;\n\n    public NSolver() {}\n\n    public void solve(List<String> puzz, int max_wid) {\n        if (puzz.size() < 1) return;\n        wid = max_wid;\n        hei = puzz.size() / wid;\n        int len = wid * hei, c = 0;\n        max = len;\n        arr = new Node[len];\n        Arrays.fill(arr, new Node());\n\n        for (String s : puzz) {\n            if (s.equals(\"*\")) {\n                max--;\n                arr[c++].val = -1;\n                continue;\n            }\n            arr[c].val = Integer.parseInt(s);\n            c++;\n        }\n\n        solveIt();\n        c = 0;\n        for (String s : puzz) {\n            if (s.equals(\".\")) {\n                puzz.set(c, String.valueOf(arr[c].val));\n            }\n            c++;\n        }\n    }\n\n    private boolean search(int x, int y, int w) {\n        if (w > max) return true;\n\n        Node n = arr[x + y * wid];\n        n.neighbors = getNeighbors(x, y);\n\n        for (int d = 0; d < 8; d++) {\n            if ((n.neighbors & (1 << d)) != 0) {\n                int a = x + dx[d], b = y + dy[d];\n                if (arr[a + b * wid].val == 0) {\n                    arr[a + b * wid].val = w;\n                    if (search(a, b, w + 1)) return true;\n                    arr[a + b * wid].val = 0;\n                }\n            }\n        }\n        return false;\n    }\n\n    private byte getNeighbors(int x, int y) {\n        byte c = 0;\n        int a, b;\n        for (int xx = 0; xx < 8; xx++) {\n            a = x + dx[xx];\n            b = y + dy[xx];\n            if (a < 0 || b < 0 || a >= wid || b >= hei) continue;\n            if (arr[a + b * wid].val > -1) c |= (1 << xx);\n        }\n        return c;\n    }\n\n    private void solveIt() {\n        int x, y, z;\n        findStart(x, y, z);\n        if (z == 99999) {\n            System.out.println(\"\\nCan't find start point!\\n\");\n            return;\n        }\n        search(x, y, z + 1);\n    }\n\n    private void findStart(int[] start) {\n        for (int b = 0; b < hei; b++) {\n            for (int a = 0; a < wid; a++) {\n                if (arr[a + wid * b].val == 0) {\n                    start[0] = a;\n                    start[1] = b;\n                    start[2] = 1;\n                    arr[a + wid * b].val = start[2];\n                    return;\n                }\n            }\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        int wid = 7;\n        String p = \"* . . * . . * . . . . . . . . . . . . . . * . . . . . * * * . . . * * * * * . * * *\";\n        String[] puzzArray = p.split(\" \");\n        List<String> puzz = new ArrayList<>(Arrays.asList(puzzArray));\n        NSolver s = new NSolver();\n        s.solve(puzz, wid);\n        int c = 0;\n        for (String s1 : puzz) {\n            if (!s1.equals(\"*\") && !s1.equals(\".\")) {\n                if (Integer.parseInt(s1) < 10) System.out.print(\"0\");\n                System.out.print(s1 + \" \");\n            } else System.out.print(\"   \");\n            if (++c >= wid) {\n                System.out.println();\n                c = 0;\n            }\n        }\n        System.out.println();\n    }\n}", "index": 67}
{"lang": "C++, Java", "input": "#include <vector>\n#include <sstream>\n#include <iostream>\n#include <iterator>\n#include <stdlib.h>\n#include <string.h>\n\nusing namespace std;\n\nstruct node\n{\n    int val;\n    unsigned char neighbors;\n};\n\nclass nSolver\n{\npublic:\n    nSolver()\n    {\n\tdx[0] = -2; dy[0] = -2; dx[1] = -2; dy[1] =  2;\n\tdx[2] =  2; dy[2] = -2; dx[3] =  2; dy[3] =  2;\n\tdx[4] = -3; dy[4] =  0; dx[5] =  3; dy[5] =  0; \n\tdx[6] =  0; dy[6] = -3; dx[7] =  0; dy[7] =  3;\n    }\n\n    void solve( vector<string>& puzz, int max_wid )\n    {\n\tif( puzz.size() < 1 ) return;\n\twid = max_wid; hei = static_cast<int>( puzz.size() ) / wid;\n\tint len = wid * hei, c = 0; max = len;\n\tarr = new node[len]; memset( arr, 0, len * sizeof( node ) );\n\n\tfor( vector<string>::iterator i = puzz.begin(); i != puzz.end(); i++ )\n\t{\n\t    if( ( *i ) == \"*\" ) { max--; arr[c++].val = -1; continue; }\n\t    arr[c].val = atoi( ( *i ).c_str() );\n\t    c++;\n\t}\n\n\tsolveIt(); c = 0;\n\tfor( vector<string>::iterator i = puzz.begin(); i != puzz.end(); i++ )\n\t{\n\t    if( ( *i ) == \".\" )\n\t    {\n\t\tostringstream o; o << arr[c].val;\n\t\t( *i ) = o.str();\n\t    }\n\t    c++;\n\t}\n\tdelete [] arr;\n    }\n\nprivate:\n    bool search( int x, int y, int w )\n    {\n\tif( w > max ) return true;\n\n\tnode* n = &arr[x + y * wid];\n\tn->neighbors = getNeighbors( x, y );\n\n\tfor( int d = 0; d < 8; d++ )\n\t{\n\t    if( n->neighbors & ( 1 << d ) )\n\t    {\n\t\tint a = x + dx[d], b = y + dy[d];\n\t\tif( arr[a + b * wid].val == 0 )\n\t\t{\n\t\t    arr[a + b * wid].val = w;\n\t\t    if( search( a, b, w + 1 ) ) return true;\n\t\t    arr[a + b * wid].val = 0;\n\t\t}\n\t    }\n\t}\n\treturn false;\n    }\n\n    unsigned char getNeighbors( int x, int y )\n    {\n\tunsigned char c = 0; int a, b;\n\tfor( int xx = 0; xx < 8; xx++ )\n\t{\n\t    a = x + dx[xx], b = y + dy[xx];\n\t    if( a < 0 || b < 0 || a >= wid || b >= hei ) continue;\n\t    if( arr[a + b * wid].val > -1 ) c |= ( 1 << xx );\n\t}\n\treturn c;\n    }\n\n    void solveIt()\n    {\n\tint x, y, z; findStart( x, y, z );\n\tif( z == 99999 ) { cout << \"\\nCan't find start point!\\n\"; return; }\n\tsearch( x, y, z + 1 );\n    }\n\n    void findStart( int& x, int& y, int& z )\n    {\n\tfor( int b = 0; b < hei; b++ )\n\t    for( int a = 0; a < wid; a++ )\n\t\tif( arr[a + wid * b].val == 0 ) \n\t\t{ \n\t\t    x = a; y = b; z = 1;\n\t\t    arr[a + wid * b].val = z;\n\t\t    return;\n\t\t}\n    }\n\n    int wid, hei, max, dx[8], dy[8];\n    node* arr;\n};\n\nint main( int argc, char* argv[] )\n{\n    int wid; string p;\n    p = \"* . . * . . * . . . . . . . . . . . . . . * . . . . . * * * . . . * * * * * . * * *\"; wid = 7;\n    istringstream iss( p ); vector<string> puzz;\n    copy( istream_iterator<string>( iss ), istream_iterator<string>(), back_inserter<vector<string> >( puzz ) );\n    nSolver s; s.solve( puzz, wid );\n    int c = 0;\n    for( vector<string>::iterator i = puzz.begin(); i != puzz.end(); i++ )\n    {\n\tif( ( *i ) != \"*\" && ( *i ) != \".\" )\n\t{\n\t    if( atoi( ( *i ).c_str() ) < 10 ) cout << \"0\";\n\t    cout << ( *i ) << \" \";\n\t}\n\telse cout << \"   \";\n\tif( ++c >= wid ) { cout << endl; c = 0; }\n    }\n    cout << endl << endl;\n    return system( \"pause\" );\n}", "gold": "import java.util.*;\n\npublic class Hopido {\n\n    final static String[] board = {\n        \".00.00.\",\n        \"0000000\",\n        \"0000000\",\n        \".00000.\",\n        \"..000..\",\n        \"...0...\"};\n\n    final static int[][] moves = {{-3, 0}, {0, 3}, {3, 0}, {0, -3},\n    {2, 2}, {2, -2}, {-2, 2}, {-2, -2}};\n    static int[][] grid;\n    static int totalToFill;\n\n    public static void main(String[] args) {\n        int nRows = board.length + 6;\n        int nCols = board[0].length() + 6;\n\n        grid = new int[nRows][nCols];\n\n        for (int r = 0; r < nRows; r++) {\n            Arrays.fill(grid[r], -1);\n            for (int c = 3; c < nCols - 3; c++)\n                if (r >= 3 && r < nRows - 3) {\n                    if (board[r - 3].charAt(c - 3) == '0') {\n                        grid[r][c] = 0;\n                        totalToFill++;\n                    }\n                }\n        }\n\n        int pos = -1, r, c;\n        do {\n            do {\n                pos++;\n                r = pos / nCols;\n                c = pos % nCols;\n            } while (grid[r][c] == -1);\n\n            grid[r][c] = 1;\n            if (solve(r, c, 2))\n                break;\n            grid[r][c] = 0;\n\n        } while (pos < nRows * nCols);\n\n        printResult();\n    }\n\n    static boolean solve(int r, int c, int count) {\n        if (count > totalToFill)\n            return true;\n\n        List<int[]> nbrs = neighbors(r, c);\n\n        if (nbrs.isEmpty() && count != totalToFill)\n            return false;\n\n        Collections.sort(nbrs, (a, b) -> a[2] - b[2]);\n\n        for (int[] nb : nbrs) {\n            r = nb[0];\n            c = nb[1];\n            grid[r][c] = count;\n            if (solve(r, c, count + 1))\n                return true;\n            grid[r][c] = 0;\n        }\n\n        return false;\n    }\n\n    static List<int[]> neighbors(int r, int c) {\n        List<int[]> nbrs = new ArrayList<>();\n\n        for (int[] m : moves) {\n            int x = m[0];\n            int y = m[1];\n            if (grid[r + y][c + x] == 0) {\n                int num = countNeighbors(r + y, c + x) - 1;\n                nbrs.add(new int[]{r + y, c + x, num});\n            }\n        }\n        return nbrs;\n    }\n\n    static int countNeighbors(int r, int c) {\n        int num = 0;\n        for (int[] m : moves)\n            if (grid[r + m[1]][c + m[0]] == 0)\n                num++;\n        return num;\n    }\n\n    static void printResult() {\n        for (int[] row : grid) {\n            for (int i : row) {\n                if (i == -1)\n                    System.out.printf(\"%2s \", ' ');\n                else\n                    System.out.printf(\"%2d \", i);\n            }\n            System.out.println();\n        }\n    }\n}", "llm": "dsc2-16b", "output": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nclass Node {\n    int val;\n    byte neighbors;\n}\n\nclass nSolver {\n    private int[] dx = {-2, -2, 2, 2, -3, 3, 0, 0};\n    private int[] dy = {-2, 2, -2, 2, 0, 0, -3, 3};\n    private int wid, hei, max;\n    private Node[] arr;\n\n    public nSolver() {\n        dx[0] = -2; dy[0] = -2; dx[1] = -2; dy[1] = 2;\n        dx[2] = 2; dy[2] = -2; dx[3] = 2; dy[3] = 2;\n        dx[4] = -3; dy[4] = 0; dx[5] = 3; dy[5] = 0;\n        dx[6] = 0; dy[6] = -3; dx[7] = 0; dy[7] = 3;\n    }\n\n    public void solve(List<String> puzz, int max_wid) {\n        if (puzz.size() < 1) return;\n        wid = max_wid; hei = puzz.size() / wid;\n        int len = wid * hei, c = 0; max = len;\n        arr = new Node[len];\n        for (int i = 0; i < len; i++) {\n            arr[i] = new Node();\n            arr[i].val = 0;\n        }\n\n        for (String s : puzz) {\n            if (s.equals(\"*\")) {\n                max--;\n                arr[c++].val = -1;\n                continue;\n            }\n            arr[c++].val = Integer.parseInt(s);\n        }\n\n        solveIt();\n        c = 0;\n        for (String s : puzz) {\n            if (s.equals(\".\")) {\n                arr[c].val = arr[c].val == 0 ? 0 : arr[c].val;\n                c++;\n            }\n        }\n    }\n\n    private boolean search(int x, int y, int w) {\n        if (w > max) return true;\n\n        Node n = arr[x + y * wid];\n        n.neighbors = getNeighbors(x, y);\n\n        for (int d = 0; d < 8; d++) {\n            if ((n.neighbors & (1 << d)) != 0) {\n                int a = x + dx[d], b = y + dy[d];\n                if (arr[a + b * wid].val == 0) {\n                    arr[a + b * wid].val = w;\n                    if (search(a, b, w + 1)) return true;\n                    arr[a + b * wid].val = 0;\n                }\n            }\n        }\n        return false;\n    }\n\n    private byte getNeighbors(int x, int y) {\n        byte c = 0;\n        for (int xx = 0; xx < 8; xx++) {\n            int a = x + dx[xx], b = y + dy[xx];\n            if (a < 0 || b < 0 || a >= wid || b >= hei) continue;\n            if (arr[a + b * wid].val > -1) c |= (byte) (1 << xx);\n        }\n        return c;\n    }\n\n    private void solveIt() {\n        int x = 0, y = 0, z = 0;\n        findStart(x, y, z);\n        if (z == 99999) {\n            System.out.println(\"\\nCan't find start point!\");\n            return;\n        }\n        search(x, y, z + 1);\n    }\n\n    private void findStart(int x, int y, int z) {\n        for (int b = 0; b < hei; b++) {\n            for (int a = 0; a < wid; a++) {\n                if (arr[a + wid * b].val == 0) {\n                    x = a; y = b; z = 1;\n                    arr[a + wid * b].val = z;\n                    return;\n                }\n            }\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        int wid = 7;\n        List<String> puzz = Stream.of(\"*\", \".\", \".\", \"*\", \".\", \".\", \"*\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \"*\", \".\", \".\", \".\", \".\", \".\", \"*\", \"*\", \"*\", \".\", \".\", \".\", \"*\", \"*\", \"*\", \"*\", \"*\", \".\", \"*\", \"*\", \"*\").collect(Collectors.toList());\n        nSolver s = new nSolver();\n        s.solve(puzz, wid);\n        int c = 0;\n        for (String s : puzz) {\n            if (!s.equals(\"*\") && !s.equals(\".\")) {\n                if (Integer.parseInt(s) < 10) System.out.print(\"0\");\n                System.out.print(s + \" \");\n            } else System.out.print(\"   \");\n            if (++c >= wid) {\n                System.out.println();\n                c = 0;\n            }\n        }\n        System.out.println();\n    }\n}", "index": 68}
{"lang": "C, C++", "input": "#include<math.h>\n#include<stdio.h>\n\nint\nmain ()\n{\n  double inputs[11], check = 400, result;\n  int i;\n\n  printf (\"\\nPlease enter 11 numbers\u00a0:\");\n\n  for (i = 0; i < 11; i++)\n    {\n      scanf (\"%lf\", &inputs[i]);\n    }\n\n  printf (\"\\n\\n\\nEvaluating f(x) = |x|^0.5 + 5x^3 for the given inputs\u00a0:\");\n\n  for (i = 10; i >= 0; i--)\n    {\n      result = sqrt (fabs (inputs[i])) + 5 * pow (inputs[i], 3);\n\n      printf (\"\\nf(%lf) = \");\n\n      if (result > check)\n        {\n          printf (\"Overflow!\");\n        }\n\n      else\n        {\n          printf (\"%lf\", result);\n        }\n    }\n\n  return 0;\n}", "gold": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n\nint main( ) {\n   std::vector<double> input( 11 ) , results( 11 ) ;\n   std::cout << \"Please enter 11 numbers!\\n\" ;\n   for ( int i = 0 ; i < input.size( ) ; i++ ) \n      std::cin >> input[i];\n      \n   std::transform( input.begin( ) , input.end( ) , results.begin( ) ,\n\t [ ]( double n )-> double { return sqrt( abs( n ) ) + 5 * pow( n , 3 ) ; } ) ;\n   for ( int i = 10 ; i > -1 ; i-- ) {\n      std::cout << \"f( \" << std::setw( 3 ) << input[ i ] << \" )\u00a0: \" ; \n      if ( results[ i ] > 400 ) \n\t std::cout << \"too large!\" ;\n      else \n\t std::cout << results[ i ] << \"\u00a0!\" ;\n      std::cout << std::endl ;\n   }\n   return 0 ;\n}", "llm": "dsc-1b", "output": "#include<iostream>\n#include<cmath>\n\nint main()\n{\n    double inputs[11], check = 400, result;\n\n    std::cout << \"Please enter 11 numbers: \";\n\n    for(int i = 0; i < 11; i++)\n    {\n        std::cin >> inputs[i];\n    }\n\n    std::cout << \"\\n\\n\\nEvaluating f(x) = |x|^0.5 + 5x^3 for the given inputs:\";\n\n    for(int i = 10; i >= 0; i--)\n    {\n        result = std::sqrt(std::fabs(inputs[i])) + 5 * std::pow(inputs[i], 3);\n\n        std::cout << \"\\nf(\" << inputs[i] << \") = \";\n\n        if(result > check)\n        {\n            std::cout << \"Overflow!\";\n        }\n        else\n        {\n            std::cout << result;\n        }\n    }\n\n    return 0;\n}", "index": 69}
{"lang": "C, C++", "input": "#include<math.h>\n#include<stdio.h>\n\nint\nmain ()\n{\n  double inputs[11], check = 400, result;\n  int i;\n\n  printf (\"\\nPlease enter 11 numbers\u00a0:\");\n\n  for (i = 0; i < 11; i++)\n    {\n      scanf (\"%lf\", &inputs[i]);\n    }\n\n  printf (\"\\n\\n\\nEvaluating f(x) = |x|^0.5 + 5x^3 for the given inputs\u00a0:\");\n\n  for (i = 10; i >= 0; i--)\n    {\n      result = sqrt (fabs (inputs[i])) + 5 * pow (inputs[i], 3);\n\n      printf (\"\\nf(%lf) = \");\n\n      if (result > check)\n        {\n          printf (\"Overflow!\");\n        }\n\n      else\n        {\n          printf (\"%lf\", result);\n        }\n    }\n\n  return 0;\n}", "gold": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n\nint main( ) {\n   std::vector<double> input( 11 ) , results( 11 ) ;\n   std::cout << \"Please enter 11 numbers!\\n\" ;\n   for ( int i = 0 ; i < input.size( ) ; i++ ) \n      std::cin >> input[i];\n      \n   std::transform( input.begin( ) , input.end( ) , results.begin( ) ,\n\t [ ]( double n )-> double { return sqrt( abs( n ) ) + 5 * pow( n , 3 ) ; } ) ;\n   for ( int i = 10 ; i > -1 ; i-- ) {\n      std::cout << \"f( \" << std::setw( 3 ) << input[ i ] << \" )\u00a0: \" ; \n      if ( results[ i ] > 400 ) \n\t std::cout << \"too large!\" ;\n      else \n\t std::cout << results[ i ] << \"\u00a0!\" ;\n      std::cout << std::endl ;\n   }\n   return 0 ;\n}", "llm": "q2.5-1.5b", "output": "#include<cmath>\n#include<stdio.h>\n\nint\nmain ()\n{\n  double inputs[11], check = 400, result;\n  int i;\n\n  printf (\"\\nPlease enter 11 numbers\u00a0:\");\n\n  for (i = 0; i < 11; i++)\n    {\n      scanf (\"%lf\", &inputs[i]);\n    }\n\n  printf (\"\\n\\n\\nEvaluating f(x) = |x|^0.5 + 5x^3 for the given inputs\u00a0:\");\n\n  for (i = 10; i >= 0; i--)\n    {\n      result = sqrt (fabs (inputs[i])) + 5 * pow (inputs[i], 3);\n\n      printf (\"\\nf(%lf) = \");\n\n      if (result > check)\n        {\n          printf (\"Overflow!\");\n        }\n\n      else\n        {\n          printf (\"%lf\", result);\n        }\n    }\n\n  return 0;\n}", "index": 70}
{"lang": "C, C++", "input": "#include<math.h>\n#include<stdio.h>\n\nint\nmain ()\n{\n  double inputs[11], check = 400, result;\n  int i;\n\n  printf (\"\\nPlease enter 11 numbers\u00a0:\");\n\n  for (i = 0; i < 11; i++)\n    {\n      scanf (\"%lf\", &inputs[i]);\n    }\n\n  printf (\"\\n\\n\\nEvaluating f(x) = |x|^0.5 + 5x^3 for the given inputs\u00a0:\");\n\n  for (i = 10; i >= 0; i--)\n    {\n      result = sqrt (fabs (inputs[i])) + 5 * pow (inputs[i], 3);\n\n      printf (\"\\nf(%lf) = \");\n\n      if (result > check)\n        {\n          printf (\"Overflow!\");\n        }\n\n      else\n        {\n          printf (\"%lf\", result);\n        }\n    }\n\n  return 0;\n}", "gold": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n\nint main( ) {\n   std::vector<double> input( 11 ) , results( 11 ) ;\n   std::cout << \"Please enter 11 numbers!\\n\" ;\n   for ( int i = 0 ; i < input.size( ) ; i++ ) \n      std::cin >> input[i];\n      \n   std::transform( input.begin( ) , input.end( ) , results.begin( ) ,\n\t [ ]( double n )-> double { return sqrt( abs( n ) ) + 5 * pow( n , 3 ) ; } ) ;\n   for ( int i = 10 ; i > -1 ; i-- ) {\n      std::cout << \"f( \" << std::setw( 3 ) << input[ i ] << \" )\u00a0: \" ; \n      if ( results[ i ] > 400 ) \n\t std::cout << \"too large!\" ;\n      else \n\t std::cout << results[ i ] << \"\u00a0!\" ;\n      std::cout << std::endl ;\n   }\n   return 0 ;\n}", "llm": "q2.5-7b", "output": "#include <cmath>\n#include <cstdio>\n\nint main() {\n    double inputs[11], check = 400, result;\n    int i;\n\n    printf(\"\\nPlease enter 11 numbers: \");\n\n    for (i = 0; i < 11; i++) {\n        scanf(\"%lf\", &inputs[i]);\n    }\n\n    printf(\"\\n\\n\\nEvaluating f(x) = |x|^0.5 + 5x^3 for the given inputs: \");\n\n    for (i = 10; i >= 0; i--) {\n        result = std::sqrt(std::fabs(inputs[i])) + 5 * std::pow(inputs[i], 3);\n\n        printf(\"\\nf(%lf) = \", inputs[i]);\n\n        if (result > check) {\n            printf(\"Overflow!\");\n        } else {\n            printf(\"%lf\", result);\n        }\n    }\n\n    return 0;\n}", "index": 71}
{"lang": "C, Python", "input": "#include<stdio.h>\nlong long seed;\nlong long random(){\n        seed = seed * seed / 1000 % 1000000;\n        return seed;\n}\nint main(){\n        seed = 675248;\n        for(int i=1;i<=5;i++)\n                printf(\"%lld\\n\",random());\n        return 0;\n}", "gold": "seed = 675248\ndef random():\n    global seed\n    seed = int(str(seed ** 2).zfill(12)[3:9])\n    return seed\nfor _ in range(5):\n    print(random())", "llm": "cl-7b", "output": "import random\n\nseed = 675248\n\nfor i in range(1, 6):\n    print(random.randint(0, 1000000))", "index": 72}
{"lang": "C, Python", "input": "#include<stdio.h>\nlong long seed;\nlong long random(){\n        seed = seed * seed / 1000 % 1000000;\n        return seed;\n}\nint main(){\n        seed = 675248;\n        for(int i=1;i<=5;i++)\n                printf(\"%lld\\n\",random());\n        return 0;\n}", "gold": "seed = 675248\ndef random():\n    global seed\n    seed = int(str(seed ** 2).zfill(12)[3:9])\n    return seed\nfor _ in range(5):\n    print(random())", "llm": "q2.5-1.5b", "output": "import random\n\nseed = 675248\nfor i in range(1, 6):\n    print(random.randint(0, 999999))", "index": 73}
{"lang": "C, Python", "input": "#include<stdio.h>\nlong long seed;\nlong long random(){\n        seed = seed * seed / 1000 % 1000000;\n        return seed;\n}\nint main(){\n        seed = 675248;\n        for(int i=1;i<=5;i++)\n                printf(\"%lld\\n\",random());\n        return 0;\n}", "gold": "seed = 675248\ndef random():\n    global seed\n    seed = int(str(seed ** 2).zfill(12)[3:9])\n    return seed\nfor _ in range(5):\n    print(random())", "llm": "q2.5-7b", "output": "seed = 675248\ndef random():\n    global seed\n    seed = seed * seed // 1000 % 1000000\n    return seed\n\nfor i in range(1, 6):\n    print(random())", "index": 74}
{"lang": "C, Python", "input": "#include<stdlib.h>\n#include<stdio.h>\n\nint\nmain ()\n{\n  int i;\n  char *str = getenv (\"LANG\");\n\n  for (i = 0; str[i + 2] != 00; i++)\n    {\n      if ((str[i] == 'u' && str[i + 1] == 't' && str[i + 2] == 'f')\n          || (str[i] == 'U' && str[i + 1] == 'T' && str[i + 2] == 'F'))\n        {\n          printf\n            (\"Unicode is supported on this terminal and U+25B3 is\u00a0: \\u25b3\");\n          i = -1;\n          break;\n        }\n    }\n\n  if (i != -1)\n    printf (\"Unicode is not supported on this terminal.\");\n\n  return 0;\n}", "gold": "import sys\n\nif \"UTF-8\" in sys.stdout.encoding:\n    print(\"\u25b3\")\nelse:\n    raise Exception(\"Terminal can't handle UTF-8\")", "llm": "dsc-1b", "output": "#include <stdlib.h>\n#include <stdio.h>\n\nint\nmain():\n\n    i = 0\n    str = getenv(\"LANG\")\n\n    for i in range(len(str)):\n        if (str[i:i+3] == 'utf' or str[i:i+3] == 'UTF'):\n            print(\"Unicode is supported on this terminal and U+25B3 is : \\u25b3\")\n            i = -1\n            break\n\n    if i != -1:\n        print(\"Unicode is not supported on this terminal.\")\n\n    return 0", "index": 75}
{"lang": "C, Python", "input": "#include<stdlib.h>\n#include<stdio.h>\n\nint\nmain ()\n{\n  int i;\n  char *str = getenv (\"LANG\");\n\n  for (i = 0; str[i + 2] != 00; i++)\n    {\n      if ((str[i] == 'u' && str[i + 1] == 't' && str[i + 2] == 'f')\n          || (str[i] == 'U' && str[i + 1] == 'T' && str[i + 2] == 'F'))\n        {\n          printf\n            (\"Unicode is supported on this terminal and U+25B3 is\u00a0: \\u25b3\");\n          i = -1;\n          break;\n        }\n    }\n\n  if (i != -1)\n    printf (\"Unicode is not supported on this terminal.\");\n\n  return 0;\n}", "gold": "import sys\n\nif \"UTF-8\" in sys.stdout.encoding:\n    print(\"\u25b3\")\nelse:\n    raise Exception(\"Terminal can't handle UTF-8\")", "llm": "magic-7b", "output": "import os\n\ndef main():\n    str = os.getenv(\"LANG\")\n\n    for i in range(len(str) - 2):\n        if (str[i] == 'u' and str[i + 1] == 't' and str[i + 2] == 'f') or (str[i] == 'U' and str[i + 1] == 'T' and str[i + 2] == 'F'):\n            print(\"Unicode is supported on this terminal and U+25B3 is \\u25b3\")\n            break\n    else:\n        print(\"Unicode is not supported on this terminal.\")\n\nif __name__ == \"__main__\":\n    main()", "index": 76}
{"lang": "C, Python", "input": "#include<stdlib.h>\n#include<stdio.h>\n\nint\nmain ()\n{\n  int i;\n  char *str = getenv (\"LANG\");\n\n  for (i = 0; str[i + 2] != 00; i++)\n    {\n      if ((str[i] == 'u' && str[i + 1] == 't' && str[i + 2] == 'f')\n          || (str[i] == 'U' && str[i + 1] == 'T' && str[i + 2] == 'F'))\n        {\n          printf\n            (\"Unicode is supported on this terminal and U+25B3 is\u00a0: \\u25b3\");\n          i = -1;\n          break;\n        }\n    }\n\n  if (i != -1)\n    printf (\"Unicode is not supported on this terminal.\");\n\n  return 0;\n}", "gold": "import sys\n\nif \"UTF-8\" in sys.stdout.encoding:\n    print(\"\u25b3\")\nelse:\n    raise Exception(\"Terminal can't handle UTF-8\")", "llm": "cs-22b", "output": "import os\n\nstr = os.getenv(\"LANG\")\n\ni = 0\nwhile i < len(str) - 2:\n    if (str[i] == 'u' and str[i + 1] == 't' and str[i + 2] == 'f') or (str[i] == 'U' and str[i + 1] == 'T' and str[i + 2] == 'F'):\n        print(\"Unicode is supported on this terminal and U+25B3 is: \u25b3\")\n        i = -1\n        break\n    i += 1\n\nif i != -1:\n    print(\"Unicode is not supported on this terminal.\")", "index": 77}
{"lang": "Python, C", "input": ">>> def a(answer):\n\tprint(\"  \n\treturn answer\n\n>>> def b(answer):\n\tprint(\"  \n\treturn answer\n\n>>> for i in (False, True):\n\tfor j in (False, True):\n\t\tprint (\"\\nCalculating: x = a(i) and b(j)\")\n\t\tx = a(i) and b(j)\n\t\tprint (\"Calculating: y = a(i) or  b(j)\")\n\t\ty = a(i) or  b(j)\n\n\t\t\n\nCalculating: x = a(i) and b(j)\n  \nCalculating: y = a(i) or  b(j)\n  \n  \n\nCalculating: x = a(i) and b(j)\n  \nCalculating: y = a(i) or  b(j)\n  \n  \n\nCalculating: x = a(i) and b(j)\n  \n  \nCalculating: y = a(i) or  b(j)\n  \n\nCalculating: x = a(i) and b(j)\n  \n  \nCalculating: y = a(i) or  b(j)", "gold": "#include <stdio.h>\n#include <stdbool.h>\n\nbool a(bool in)\n{\n  printf(\"I am a\\n\");\n  return in;\n}\n\nbool b(bool in)\n{\n  printf(\"I am b\\n\");\n  return in;\n}\n\n#define TEST(X,Y,O)\t\t\t\t\t\t\\\n  do {\t\t\t\t\t\t\t\t\\\n    x = a(X) O b(Y);\t\t\t\t\t\t\\\n    printf(#X \" \" #O \" \" #Y \" = %s\\n\\n\", x\u00a0? \"true\"\u00a0: \"false\");\t\\\n  } while(false);\n\nint main()\n{\n  bool x;\n\n  TEST(false, true, &&); \n  TEST(true, false, ||); \n  TEST(true, false, &&); \n  TEST(false, false, ||); \n\n  return 0;\n}", "llm": "cl-7b", "output": "#include <stdio.h>\n\nint a(int answer) {\n    return answer;\n}\n\nint b(int answer) {\n    return answer;\n}\n\nint main() {\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < 2; j++) {\n            printf(\"Calculating: x = a(%d) and b(%d)\\n\", i, j);\n            int x = a(i) && b(j);\n            printf(\"Calculating: y = a(%d) or b(%d)\\n\", i, j);\n            int y = a(i) || b(j);\n        }\n    }\n    return 0;\n}", "index": 78}
{"lang": "Python, C", "input": ">>> def a(answer):\n\tprint(\"  \n\treturn answer\n\n>>> def b(answer):\n\tprint(\"  \n\treturn answer\n\n>>> for i in (False, True):\n\tfor j in (False, True):\n\t\tprint (\"\\nCalculating: x = a(i) and b(j)\")\n\t\tx = a(i) and b(j)\n\t\tprint (\"Calculating: y = a(i) or  b(j)\")\n\t\ty = a(i) or  b(j)\n\n\t\t\n\nCalculating: x = a(i) and b(j)\n  \nCalculating: y = a(i) or  b(j)\n  \n  \n\nCalculating: x = a(i) and b(j)\n  \nCalculating: y = a(i) or  b(j)\n  \n  \n\nCalculating: x = a(i) and b(j)\n  \n  \nCalculating: y = a(i) or  b(j)\n  \n\nCalculating: x = a(i) and b(j)\n  \n  \nCalculating: y = a(i) or  b(j)", "gold": "#include <stdio.h>\n#include <stdbool.h>\n\nbool a(bool in)\n{\n  printf(\"I am a\\n\");\n  return in;\n}\n\nbool b(bool in)\n{\n  printf(\"I am b\\n\");\n  return in;\n}\n\n#define TEST(X,Y,O)\t\t\t\t\t\t\\\n  do {\t\t\t\t\t\t\t\t\\\n    x = a(X) O b(Y);\t\t\t\t\t\t\\\n    printf(#X \" \" #O \" \" #Y \" = %s\\n\\n\", x\u00a0? \"true\"\u00a0: \"false\");\t\\\n  } while(false);\n\nint main()\n{\n  bool x;\n\n  TEST(false, true, &&); \n  TEST(true, false, ||); \n  TEST(true, false, &&); \n  TEST(false, false, ||); \n\n  return 0;\n}", "llm": "cl-13b", "output": "#include <stdio.h>\n\nint a(int answer) {\n    printf(\"Calculating: x = a(i) and b(j)\\n\");\n    return answer;\n}\n\nint b(int answer) {\n    printf(\"Calculating: y = a(i) or b(j)\\n\");\n    return answer;\n}\n\nint main() {\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < 2; j++) {\n            int x = a(i) && b(j);\n            int y = a(i) || b(j);\n            printf(\"x = %d, y = %d\\n\", x, y);\n        }\n    }\n    return 0;\n}", "index": 79}
{"lang": "Python, C", "input": ">>> def a(answer):\n\tprint(\"  \n\treturn answer\n\n>>> def b(answer):\n\tprint(\"  \n\treturn answer\n\n>>> for i in (False, True):\n\tfor j in (False, True):\n\t\tprint (\"\\nCalculating: x = a(i) and b(j)\")\n\t\tx = a(i) and b(j)\n\t\tprint (\"Calculating: y = a(i) or  b(j)\")\n\t\ty = a(i) or  b(j)\n\n\t\t\n\nCalculating: x = a(i) and b(j)\n  \nCalculating: y = a(i) or  b(j)\n  \n  \n\nCalculating: x = a(i) and b(j)\n  \nCalculating: y = a(i) or  b(j)\n  \n  \n\nCalculating: x = a(i) and b(j)\n  \n  \nCalculating: y = a(i) or  b(j)\n  \n\nCalculating: x = a(i) and b(j)\n  \n  \nCalculating: y = a(i) or  b(j)", "gold": "#include <stdio.h>\n#include <stdbool.h>\n\nbool a(bool in)\n{\n  printf(\"I am a\\n\");\n  return in;\n}\n\nbool b(bool in)\n{\n  printf(\"I am b\\n\");\n  return in;\n}\n\n#define TEST(X,Y,O)\t\t\t\t\t\t\\\n  do {\t\t\t\t\t\t\t\t\\\n    x = a(X) O b(Y);\t\t\t\t\t\t\\\n    printf(#X \" \" #O \" \" #Y \" = %s\\n\\n\", x\u00a0? \"true\"\u00a0: \"false\");\t\\\n  } while(false);\n\nint main()\n{\n  bool x;\n\n  TEST(false, true, &&); \n  TEST(true, false, ||); \n  TEST(true, false, &&); \n  TEST(false, false, ||); \n\n  return 0;\n}", "llm": "cl-34b", "output": "#include <stdio.h>\n\nint a(int answer) {\n    printf(\"  \n    return answer;\n}\n\nint b(int answer) {\n    printf(\"  \n    return answer;\n}\n\nint main() {\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < 2; j++) {\n            printf(\"\\nCalculating: x = a(i) and b(j)\");\n            int x = a(i) && b(j);\n            printf(\"\\nCalculating: y = a(i) or  b(j)\");\n            int y = a(i) || b(j);\n        }\n    }\n    return 0;\n}", "index": 80}
{"lang": "Python, C++", "input": ">>> import hashlib\n>>> \n>>> tests = (\n  (b\"\", 'd41d8cd98f00b204e9800998ecf8427e'),\n  (b\"a\", '0cc175b9c0f1b6a831c399e269772661'),\n  (b\"abc\", '900150983cd24fb0d6963f7d28e17f72'),\n  (b\"message digest\", 'f96b697d7cb7938d525a2f31aaf161d0'),\n  (b\"abcdefghijklmnopqrstuvwxyz\", 'c3fcd3d76192e4007dfb496cca67e13b'),\n  (b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\", 'd174ab98d277d9f5a5611c2c9f419d9f'),\n  (b\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\", '57edf4a22be3c955ac49da2e2107b67a') )\n>>> for text, golden in tests: assert hashlib.md5(text).hexdigest() == golden\n\n>>>", "gold": "#include <string>\n#include <iostream>\n#include \"Poco/MD5Engine.h\"\n#include \"Poco/DigestStream.h\"\n\nusing Poco::DigestEngine ;\nusing Poco::MD5Engine ;\nusing Poco::DigestOutputStream ;\n\nint main( ) {\n   std::string myphrase ( \"The quick brown fox jumped over the lazy dog's back\" ) ;\n   MD5Engine md5 ;\n   DigestOutputStream outstr( md5 ) ;\n   outstr << myphrase ;\n   outstr.flush( ) ; \n   const DigestEngine::Digest& digest = md5.digest( ) ;\n   std::cout << myphrase << \" as a MD5 digest\u00a0:\\n\" << DigestEngine::digestToHex( digest ) \n      << \"\u00a0!\" << std::endl ;\n   return 0 ;\n}", "llm": "cl-7b", "output": "#include <iostream>\n#include <string>\n#include <cassert>\n#include <hashlib.h>\n\nint main() {\n    std::string text = \"\";\n    std::string golden = \"d41d8cd98f00b204e9800998ecf8427e\";\n    assert(hashlib::md5(text).hexdigest() == golden);\n\n    text = \"a\";\n    golden = \"0cc175b9c0f1b6a831c399e269772661\";\n    assert(hashlib::md5(text).hexdigest() == golden);\n\n    text = \"abc\";\n    golden = \"900150983cd24fb0d6963f7d28e17f72\";\n    assert(hashlib::md5(text).hexdigest() == golden);\n\n    text = \"message digest\";\n    golden = \"f96b697d7cb7938d525a2f31aaf161d0\";\n    assert(hashlib::md5(text).hexdigest() == golden);\n\n    text = \"abcdefghijklmnopqrstuvwxyz\";\n    golden = \"c3fcd3d76192e4007dfb496cca67e13b\";\n    assert(hashlib::md5(text).hexdigest() == golden);\n\n    text = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    golden = \"d174ab98d277d9f5a5611c2c9f419d9f\";\n    assert(hashlib::md5(text).hexdigest() == golden);\n\n    text = \"12345678901234567890123456789012345678901234567890123456789012345678901234567890\";\n    golden = \"57edf4a22be3c955ac49da2e2107b67a\";\n    assert(hashlib::md5(text).hexdigest() == golden);\n\n    return 0;\n}", "index": 81}
{"lang": "Python, C++", "input": ">>> import hashlib\n>>> \n>>> tests = (\n  (b\"\", 'd41d8cd98f00b204e9800998ecf8427e'),\n  (b\"a\", '0cc175b9c0f1b6a831c399e269772661'),\n  (b\"abc\", '900150983cd24fb0d6963f7d28e17f72'),\n  (b\"message digest\", 'f96b697d7cb7938d525a2f31aaf161d0'),\n  (b\"abcdefghijklmnopqrstuvwxyz\", 'c3fcd3d76192e4007dfb496cca67e13b'),\n  (b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\", 'd174ab98d277d9f5a5611c2c9f419d9f'),\n  (b\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\", '57edf4a22be3c955ac49da2e2107b67a') )\n>>> for text, golden in tests: assert hashlib.md5(text).hexdigest() == golden\n\n>>>", "gold": "#include <string>\n#include <iostream>\n#include \"Poco/MD5Engine.h\"\n#include \"Poco/DigestStream.h\"\n\nusing Poco::DigestEngine ;\nusing Poco::MD5Engine ;\nusing Poco::DigestOutputStream ;\n\nint main( ) {\n   std::string myphrase ( \"The quick brown fox jumped over the lazy dog's back\" ) ;\n   MD5Engine md5 ;\n   DigestOutputStream outstr( md5 ) ;\n   outstr << myphrase ;\n   outstr.flush( ) ; \n   const DigestEngine::Digest& digest = md5.digest( ) ;\n   std::cout << myphrase << \" as a MD5 digest\u00a0:\\n\" << DigestEngine::digestToHex( digest ) \n      << \"\u00a0!\" << std::endl ;\n   return 0 ;\n}", "llm": "dsc-7b", "output": "#include <iostream>\n#include <openssl/md5.h>\n#include <string>\n#include <cstring>\n\nstd::string md5(const std::string &input) {\n    unsigned char digest[16];\n    char mdString[33];\n    MD5((unsigned char*)input.c_str(), input.size(), (unsigned char*)&digest);\n    for(int i = 0; i < 16; i++)\n        sprintf(&mdString[i*2], \"%02x\", (unsigned int)digest[i]);\n    return std::string(mdString);\n}\n\nint main() {\n    std::pair<std::string, std::string> tests[] = {\n        {\"\", \"d41d8cd98f00b204e9800998ecf8427e\"},\n        {\"a\", \"0cc175b9c0f1b6a831c399e269772661\"},\n        {\"abc\", \"900150983cd24fb0d6963f7d28e17f72\"},\n        {\"message digest\", \"f96b697d7cb7938d525a2f31aaf161d0\"},\n        {\"abcdefghijklmnopqrstuvwxyz\", \"c3fcd3d76192e4007dfb496cca67e13b\"},\n        {\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\", \"d174ab98d277d9f5a5611c2c9f419d9f\"},\n        {\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\", \"57edf4a22be3c955ac49da2e2107b67a\"}\n    };\n\n    for (auto &test : tests) {\n        if (md5(test.first) != test.second) {\n            std::cout << \"Test failed for input: \" << test.first << std::endl;\n            return 1;\n        }\n    }\n\n    std::cout << \"All tests passed.\" << std::endl;\n    return 0;\n}", "index": 82}
{"lang": "Python, C++", "input": ">>> import hashlib\n>>> \n>>> tests = (\n  (b\"\", 'd41d8cd98f00b204e9800998ecf8427e'),\n  (b\"a\", '0cc175b9c0f1b6a831c399e269772661'),\n  (b\"abc\", '900150983cd24fb0d6963f7d28e17f72'),\n  (b\"message digest\", 'f96b697d7cb7938d525a2f31aaf161d0'),\n  (b\"abcdefghijklmnopqrstuvwxyz\", 'c3fcd3d76192e4007dfb496cca67e13b'),\n  (b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\", 'd174ab98d277d9f5a5611c2c9f419d9f'),\n  (b\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\", '57edf4a22be3c955ac49da2e2107b67a') )\n>>> for text, golden in tests: assert hashlib.md5(text).hexdigest() == golden\n\n>>>", "gold": "#include <string>\n#include <iostream>\n#include \"Poco/MD5Engine.h\"\n#include \"Poco/DigestStream.h\"\n\nusing Poco::DigestEngine ;\nusing Poco::MD5Engine ;\nusing Poco::DigestOutputStream ;\n\nint main( ) {\n   std::string myphrase ( \"The quick brown fox jumped over the lazy dog's back\" ) ;\n   MD5Engine md5 ;\n   DigestOutputStream outstr( md5 ) ;\n   outstr << myphrase ;\n   outstr.flush( ) ; \n   const DigestEngine::Digest& digest = md5.digest( ) ;\n   std::cout << myphrase << \" as a MD5 digest\u00a0:\\n\" << DigestEngine::digestToHex( digest ) \n      << \"\u00a0!\" << std::endl ;\n   return 0 ;\n}", "llm": "cg4-9b", "output": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <openssl/md5.h>\n\nstd::string md5(const std::string& text) {\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((const unsigned char*)text.c_str(), text.length(), digest);\n\n    std::stringstream ss;\n    for (int i = 0; i < MD5_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)digest[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    std::vector<std::pair<std::string, std::string>> tests = {\n        {\"\", \"d41d8cd98f00b204e9800998ecf8427e\"},\n        {\"a\", \"0cc175b9c0f1b6a831c399e269772661\"},\n        {\"abc\", \"900150983cd24fb0d6963f7d28e17f72\"},\n        {\"message digest\", \"f96b697d7cb7938d525a2f31aaf161d0\"},\n        {\"abcdefghijklmnopqrstuvwxyz\", \"c3fcd3d76192e4007dfb496cca67e13b\"},\n        {\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\", \"d174ab98d277d9f5a5611c2c9f419d9f\"},\n        {\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\", \"57edf4a22be3c955ac49da2e2107b67a\"}\n    };\n\n    for (const auto& test : tests) {\n        std::string result = md5(test.first);\n        if (result != test.second) {\n            std::cout << \"Test failed for input: \" << test.first << std::endl;\n            std::cout << \"Expected: \" << test.second << std::endl;\n            std::cout << \"Got: \" << result << std::endl;\n            return 1;\n        }\n    }\n\n    std::cout << \"All tests passed!\" << std::endl;\n    return 0;\n}", "index": 83}
{"lang": "Python, Java", "input": "def isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\n\nif __name__ == '__main__':\n    p = 3\n    i = 2\n\n    print(\"2 3\", end = \" \");\n    while True:\n        if isPrime(p + i) == 1:\n            p += i\n            print(p, end = \" \");\n        i += 2\n        if p + i >= 1050:\n            break", "gold": "class SpecialPrimes {\n    private static boolean isPrime(int n) {\n        if (n < 2)  return false;\n        if (n%2 == 0) return n == 2;\n        if (n%3 == 0) return n == 3;\n        int d = 5;\n        while (d*d <= n) {\n            if (n%d == 0) return false;\n            d += 2;\n            if (n%d == 0) return false;\n            d += 4;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"Special primes under 1,050:\");\n        System.out.println(\"Prime1 Prime2 Gap\");\n        int lastSpecial = 3;\n        int lastGap = 1;\n        System.out.printf(\"%6d %6d %3d\\n\", 2, 3, lastGap);\n        for (int i = 5; i < 1050; i += 2) {\n            if (isPrime(i) && (i-lastSpecial) > lastGap) {\n                lastGap = i - lastSpecial;\n                System.out.printf(\"%6d %6d %3d\\n\", lastSpecial, i, lastGap);\n                lastSpecial = i;\n            }\n        }\n    }\n}", "llm": "dsc2-16b", "output": "import java.util.Scanner;\n\npublic class PrimePrinter {\n    public static boolean isPrime(int n) {\n        for (int i = 2; i <= Math.sqrt(n); i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        int p = 3;\n        int i = 2;\n\n        System.out.print(\"2 3 \");\n        while (true) {\n            if (isPrime(p + i) ? 1 : 0 == 1) {\n                p += i;\n                System.out.print(p + \" \");\n            }\n            i += 2;\n            if (p + i >= 1050) {\n                break;\n            }\n        }\n    }\n}", "index": 84}
{"lang": "Python, Java", "input": "def isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\n\nif __name__ == '__main__':\n    p = 3\n    i = 2\n\n    print(\"2 3\", end = \" \");\n    while True:\n        if isPrime(p + i) == 1:\n            p += i\n            print(p, end = \" \");\n        i += 2\n        if p + i >= 1050:\n            break", "gold": "class SpecialPrimes {\n    private static boolean isPrime(int n) {\n        if (n < 2)  return false;\n        if (n%2 == 0) return n == 2;\n        if (n%3 == 0) return n == 3;\n        int d = 5;\n        while (d*d <= n) {\n            if (n%d == 0) return false;\n            d += 2;\n            if (n%d == 0) return false;\n            d += 4;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"Special primes under 1,050:\");\n        System.out.println(\"Prime1 Prime2 Gap\");\n        int lastSpecial = 3;\n        int lastGap = 1;\n        System.out.printf(\"%6d %6d %3d\\n\", 2, 3, lastGap);\n        for (int i = 5; i < 1050; i += 2) {\n            if (isPrime(i) && (i-lastSpecial) > lastGap) {\n                lastGap = i - lastSpecial;\n                System.out.printf(\"%6d %6d %3d\\n\", lastSpecial, i, lastGap);\n                lastSpecial = i;\n            }\n        }\n    }\n}", "llm": "cs-22b", "output": "public class Main {\n    public static boolean isPrime(int n) {\n        for (int i = 2; i <= Math.sqrt(n); i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        int p = 3;\n        int i = 2;\n\n        System.out.print(\"2 3 \");\n        while (true) {\n            if (isPrime(p + i)) {\n                p += i;\n                System.out.print(p + \" \");\n            }\n            i += 2;\n            if (p + i >= 1050) {\n                break;\n            }\n        }\n    }\n}", "index": 85}
{"lang": "Python, Java", "input": "def isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\n\nif __name__ == '__main__':\n    p = 3\n    i = 2\n\n    print(\"2 3\", end = \" \");\n    while True:\n        if isPrime(p + i) == 1:\n            p += i\n            print(p, end = \" \");\n        i += 2\n        if p + i >= 1050:\n            break", "gold": "class SpecialPrimes {\n    private static boolean isPrime(int n) {\n        if (n < 2)  return false;\n        if (n%2 == 0) return n == 2;\n        if (n%3 == 0) return n == 3;\n        int d = 5;\n        while (d*d <= n) {\n            if (n%d == 0) return false;\n            d += 2;\n            if (n%d == 0) return false;\n            d += 4;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"Special primes under 1,050:\");\n        System.out.println(\"Prime1 Prime2 Gap\");\n        int lastSpecial = 3;\n        int lastGap = 1;\n        System.out.printf(\"%6d %6d %3d\\n\", 2, 3, lastGap);\n        for (int i = 5; i < 1050; i += 2) {\n            if (isPrime(i) && (i-lastSpecial) > lastGap) {\n                lastGap = i - lastSpecial;\n                System.out.printf(\"%6d %6d %3d\\n\", lastSpecial, i, lastGap);\n                lastSpecial = i;\n            }\n        }\n    }\n}", "llm": "cg4-9b", "output": "public class Main {\n    public static boolean isPrime(int n) {\n        for (int i = 2; i <= Math.sqrt(n); i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        int p = 3;\n        int i = 2;\n\n        System.out.print(\"2 3 \");\n        while (true) {\n            if (isPrime(p + i)) {\n                p += i;\n                System.out.print(p + \" \");\n            }\n            i += 2;\n            if (p + i >= 1050) {\n                break;\n            }\n        }\n    }\n}", "index": 86}
{"lang": "Python, C", "input": "def main():\n    resources = int(input(\"Cantidad de recursos: \"))\n    processes = int(input(\"Cantidad de procesos: \"))\n    max_resources = [int(i) for i in input(\"Recursos m\u00e1ximos: \").split()]\n\n    print(\"\\n-- recursos asignados para cada proceso  --\")\n    currently_allocated = [[int(i) for i in input(f\"proceso {j + 1}: \").split()] for j in range(processes)]\n\n    print(\"\\n--- recursos m\u00e1ximos para cada proceso  ---\")\n    max_need = [[int(i) for i in input(f\"proceso {j + 1}: \").split()] for j in range(processes)]\n\n    allocated = [0] * resources\n    for i in range(processes):\n        for j in range(resources):\n            allocated[j] += currently_allocated[i][j]\n    print(f\"\\nRecursos totales asignados \u00a0: {allocated}\")\n\n    available = [max_resources[i] - allocated[i] for i in range(resources)]\n    print(f\"Recursos totales disponibles: {available}\\n\")\n\n    running = [True] * processes\n    count = processes\n    while count != 0:\n        safe = False\n        for i in range(processes):\n            if running[i]:\n                executing = True\n                for j in range(resources):\n                    if max_need[i][j] - currently_allocated[i][j] > available[j]:\n                        executing = False\n                        break\n                if executing:\n                    print(f\"proceso {i + 1} ejecut\u00e1ndose\")\n                    running[i] = False\n                    count -= 1\n                    safe = True\n                    for j in range(resources):\n                        available[j] += currently_allocated[i][j]\n                    break\n        if not safe:\n            print(\"El proceso est\u00e1 en un estado inseguro.\")\n            break\n\n        print(f\"El proceso est\u00e1 en un estado seguro.\\nRecursos disponibles: {available}\\n\")\n\n\nif __name__ == '__main__':\n    main()", "gold": "#include <stdio.h>\n#include <stdbool.h>\n\nint main() {\n    int curr[5][5];\n    int max_claim[5][5];\n    int avl[5];\n    int alloc[5] = {0, 0, 0, 0, 0};\n    int max_res[5];\n    int running[5];\n\n    int i, j, exec, r, p;\n    int count = 0;\n    bool safe = false;\n\n    printf(\"\\nEnter the number of resources: \");\n    scanf(\"%d\", &r);\n\n    printf(\"\\nEnter the number of processes: \");\n    scanf(\"%d\", &p);\n    for (i = 0; i < p; i++) {\n        running[i] = 1;\n        count++;\n    }\n\n    printf(\"\\nEnter Claim Vector: \");\n    for (i = 0; i < r; i++)\n        scanf(\"%d\", &max_res[i]);\n\n    printf(\"\\nEnter Allocated Resource Table: \");\n    for (i = 0; i < p; i++) {\n        for (j = 0; j < r; j++)\n            scanf(\"%d\", &curr[i][j]);\n    }\n\n    printf(\"\\nEnter Maximum Claim table: \");\n    for (i = 0; i < p; i++) {\n        for (j = 0; j < r; j++)\n            scanf(\"%d\", &max_claim[i][j]);\n    }\n\n    printf(\"\\nThe Claim Vector is: \");\n    for (i = 0; i < r; i++)\n        printf(\"%d \", max_res[i]);\n\n    printf(\"\\nThe Allocated Resource Table:\\n\");\n    for (i = 0; i < p; i++) {\n        for (j = 0; j < r; j++)\n            printf(\"\\t%d\", curr[i][j]);\n        printf(\"\\n\");\n    }\n\n    printf(\"\\nThe Maximum Claim Table:\\n\");\n    for (i = 0; i < p; i++) {\n        for (j = 0; j < r; j++)\n            printf(\"\\t%d\", max_claim[i][j]);\n        printf(\"\\n\");\n    }\n\n    for (i = 0; i < p; i++)\n        for (j = 0; j < r; j++)\n            alloc[j] += curr[i][j];\n\n    printf(\"\\nAllocated resources: \");\n    for (i = 0; i < r; i++)\n        printf(\"%d \", alloc[i]);\n    for (i = 0; i < r; i++)\n        avl[i] = max_res[i] - alloc[i];\n\n    printf(\"\\nAvailable resources: \");\n    for (i = 0; i < r; i++)\n        printf(\"%d \", avl[i]);\n    printf(\"\\n\");\n\n    while (count != 0) {\n        safe = false;\n        for (i = 0; i < p; i++) {\n            if (running[i]) {\n                exec = 1;\n                for (j = 0; j < r; j++) {\n                    if (max_claim[i][j] - curr[i][j] > avl[j]) {\n                        exec = 0;\n                        break;\n                    }\n                }\n\n                if (exec) {\n                    printf(\"\\nProcess%d is executing.\\n\", i + 1);\n                    running[i] = 0;\n                    count--;\n                    safe = true;\n                    for (j = 0; j < r; j++)\n                        avl[j] += curr[i][j];\n                    break;\n                }\n            }\n        }\n\n        if (!safe) {\n            printf(\"\\nThe processes are in unsafe state.\");\n            break;\n        }\n\n        if (safe)\n            printf(\"\\nThe process is in safe state.\");\n\n        printf(\"\\nAvailable vector: \");\n        for (i = 0; i < r; i++)\n            printf(\"%d \", avl[i]);\n    }\n\n    return 0;\n}", "llm": "cl-13b", "output": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int resources, processes, max_resources[10], currently_allocated[10][10], max_need[10][10], allocated[10], available[10], running[10], count, i, j;\n\n    printf(\"Cantidad de recursos: \");\n    scanf(\"%d\", &resources);\n    printf(\"Cantidad de procesos: \");\n    scanf(\"%d\", &processes);\n    printf(\"Recursos m\u00e1ximos: \");\n    for (i = 0; i < resources; i++) {\n        scanf(\"%d\", &max_resources[i]);\n    }\n\n    printf(\"\\n-- recursos asignados para cada proceso  --\\n\");\n    for (i = 0; i < processes; i++) {\n        printf(\"proceso %d: \", i + 1);\n        for (j = 0; j < resources; j++) {\n            scanf(\"%d\", &currently_allocated[i][j]);\n        }\n    }\n\n    printf(\"\\n--- recursos m\u00e1ximos para cada proceso  ---\\n\");\n    for (i = 0; i < processes; i++) {\n        printf(\"proceso %d: \", i + 1);\n        for (j = 0; j < resources; j++) {\n            scanf(\"%d\", &max_need[i][j]);\n        }\n    }\n\n    for (i = 0; i < resources; i++) {\n        allocated[i] = 0;\n        for (j = 0; j < processes; j++) {\n            allocated[i] += currently_allocated[j][i];\n        }\n    }\n    printf(\"\\nRecursos totales asignados \u00a0: %d\", allocated);\n\n    for (i = 0; i < resources; i++) {\n        available[i] = max_resources[i] - allocated[i];\n    }\n    printf(\"\\nRecursos totales disponibles: %d\\n\", available);\n\n    for (i = 0; i < processes; i++) {\n        running[i] = 1;\n    }\n    count = processes;\n    while (count != 0) {\n        safe = 0;\n        for (i = 0; i < processes; i++) {\n            if (running[i]) {\n                executing = 1;\n                for (j = 0; j < resources; j++) {\n                    if (max_need[i][j] - currently_allocated[i][j] > available[j]) {\n                        executing = 0;\n                        break;\n                    }\n                }\n                if (executing) {\n                    printf(\"proceso %d ejecut\u00e1ndose\\n\", i + 1);\n                    running[i] = 0;\n                    count--;\n                    safe = 1;\n                    for (j = 0; j < resources; j++) {\n                        available[j] += currently_allocated[i][j];\n                    }\n                    break;\n                }\n            }\n        }\n        if (!safe) {\n            printf(\"El proceso est\u00e1 en un estado inseguro.\\n\");\n            break;\n        }\n\n        printf(\"El proceso est\u00e1 en un estado seguro.\\nRecursos disponibles: %d\\n\", available);\n    }\n\n    return 0;\n}", "index": 87}
{"lang": "Python, C", "input": "def main():\n    resources = int(input(\"Cantidad de recursos: \"))\n    processes = int(input(\"Cantidad de procesos: \"))\n    max_resources = [int(i) for i in input(\"Recursos m\u00e1ximos: \").split()]\n\n    print(\"\\n-- recursos asignados para cada proceso  --\")\n    currently_allocated = [[int(i) for i in input(f\"proceso {j + 1}: \").split()] for j in range(processes)]\n\n    print(\"\\n--- recursos m\u00e1ximos para cada proceso  ---\")\n    max_need = [[int(i) for i in input(f\"proceso {j + 1}: \").split()] for j in range(processes)]\n\n    allocated = [0] * resources\n    for i in range(processes):\n        for j in range(resources):\n            allocated[j] += currently_allocated[i][j]\n    print(f\"\\nRecursos totales asignados \u00a0: {allocated}\")\n\n    available = [max_resources[i] - allocated[i] for i in range(resources)]\n    print(f\"Recursos totales disponibles: {available}\\n\")\n\n    running = [True] * processes\n    count = processes\n    while count != 0:\n        safe = False\n        for i in range(processes):\n            if running[i]:\n                executing = True\n                for j in range(resources):\n                    if max_need[i][j] - currently_allocated[i][j] > available[j]:\n                        executing = False\n                        break\n                if executing:\n                    print(f\"proceso {i + 1} ejecut\u00e1ndose\")\n                    running[i] = False\n                    count -= 1\n                    safe = True\n                    for j in range(resources):\n                        available[j] += currently_allocated[i][j]\n                    break\n        if not safe:\n            print(\"El proceso est\u00e1 en un estado inseguro.\")\n            break\n\n        print(f\"El proceso est\u00e1 en un estado seguro.\\nRecursos disponibles: {available}\\n\")\n\n\nif __name__ == '__main__':\n    main()", "gold": "#include <stdio.h>\n#include <stdbool.h>\n\nint main() {\n    int curr[5][5];\n    int max_claim[5][5];\n    int avl[5];\n    int alloc[5] = {0, 0, 0, 0, 0};\n    int max_res[5];\n    int running[5];\n\n    int i, j, exec, r, p;\n    int count = 0;\n    bool safe = false;\n\n    printf(\"\\nEnter the number of resources: \");\n    scanf(\"%d\", &r);\n\n    printf(\"\\nEnter the number of processes: \");\n    scanf(\"%d\", &p);\n    for (i = 0; i < p; i++) {\n        running[i] = 1;\n        count++;\n    }\n\n    printf(\"\\nEnter Claim Vector: \");\n    for (i = 0; i < r; i++)\n        scanf(\"%d\", &max_res[i]);\n\n    printf(\"\\nEnter Allocated Resource Table: \");\n    for (i = 0; i < p; i++) {\n        for (j = 0; j < r; j++)\n            scanf(\"%d\", &curr[i][j]);\n    }\n\n    printf(\"\\nEnter Maximum Claim table: \");\n    for (i = 0; i < p; i++) {\n        for (j = 0; j < r; j++)\n            scanf(\"%d\", &max_claim[i][j]);\n    }\n\n    printf(\"\\nThe Claim Vector is: \");\n    for (i = 0; i < r; i++)\n        printf(\"%d \", max_res[i]);\n\n    printf(\"\\nThe Allocated Resource Table:\\n\");\n    for (i = 0; i < p; i++) {\n        for (j = 0; j < r; j++)\n            printf(\"\\t%d\", curr[i][j]);\n        printf(\"\\n\");\n    }\n\n    printf(\"\\nThe Maximum Claim Table:\\n\");\n    for (i = 0; i < p; i++) {\n        for (j = 0; j < r; j++)\n            printf(\"\\t%d\", max_claim[i][j]);\n        printf(\"\\n\");\n    }\n\n    for (i = 0; i < p; i++)\n        for (j = 0; j < r; j++)\n            alloc[j] += curr[i][j];\n\n    printf(\"\\nAllocated resources: \");\n    for (i = 0; i < r; i++)\n        printf(\"%d \", alloc[i]);\n    for (i = 0; i < r; i++)\n        avl[i] = max_res[i] - alloc[i];\n\n    printf(\"\\nAvailable resources: \");\n    for (i = 0; i < r; i++)\n        printf(\"%d \", avl[i]);\n    printf(\"\\n\");\n\n    while (count != 0) {\n        safe = false;\n        for (i = 0; i < p; i++) {\n            if (running[i]) {\n                exec = 1;\n                for (j = 0; j < r; j++) {\n                    if (max_claim[i][j] - curr[i][j] > avl[j]) {\n                        exec = 0;\n                        break;\n                    }\n                }\n\n                if (exec) {\n                    printf(\"\\nProcess%d is executing.\\n\", i + 1);\n                    running[i] = 0;\n                    count--;\n                    safe = true;\n                    for (j = 0; j < r; j++)\n                        avl[j] += curr[i][j];\n                    break;\n                }\n            }\n        }\n\n        if (!safe) {\n            printf(\"\\nThe processes are in unsafe state.\");\n            break;\n        }\n\n        if (safe)\n            printf(\"\\nThe process is in safe state.\");\n\n        printf(\"\\nAvailable vector: \");\n        for (i = 0; i < r; i++)\n            printf(\"%d \", avl[i]);\n    }\n\n    return 0;\n}", "llm": "dsc-1b", "output": "#include <stdio.h>\n\nint main() {\n    int resources, processes, i, j, k;\n    printf(\"Enter the number of resources: \");\n    scanf(\"%d\", &resources);\n    printf(\"Enter the number of processes: \");\n    scanf(\"%d\", &processes);\n\n    int max_resources[processes];\n    printf(\"Enter the maximum resources for each process: \");\n    for(i = 0; i < processes; i++) {\n        scanf(\"%d\", &max_resources[i]);\n    }\n\n    int currently_allocated[processes][resources];\n    printf(\"Enter the resources currently allocated for each process:\\n\");\n    for(i = 0; i < processes; i++) {\n        for(j = 0; j < resources; j++) {\n            scanf(\"%d\", &currently_allocated[i][j]);\n        }\n    }\n\n    int max_need[processes][resources];\n    printf(\"Enter the maximum resources needed for each process:\\n\");\n    for(i = 0; i < processes; i++) {\n        for(j = 0; j < resources; j++) {\n            scanf(\"%d\", &max_need[i][j]);\n        }\n    }\n\n    int allocated[resources] = {0};\n    for(i = 0; i < processes; i++) {\n        for(j = 0; j < resources; j++) {\n            allocated[j] += currently_allocated[i][j];\n        }\n    }\n\n    printf(\"\\nTotal resources allocated: \");\n    for(i = 0; i < resources; i++) {\n        printf(\"%d \", allocated[i]);\n    }\n\n    int available[resources] = {0};\n    for(i = 0; i < resources; i++) {\n        available[i] = max_resources[i] - allocated[i];\n    }\n\n    printf(\"\\nTotal available resources: \");\n    for(i = 0; i < resources; i++) {\n        printf(\"%d \", available[i]);\n    }\n\n    return 0;\n}", "index": 88}
{"lang": "Python, C", "input": "def main():\n    resources = int(input(\"Cantidad de recursos: \"))\n    processes = int(input(\"Cantidad de procesos: \"))\n    max_resources = [int(i) for i in input(\"Recursos m\u00e1ximos: \").split()]\n\n    print(\"\\n-- recursos asignados para cada proceso  --\")\n    currently_allocated = [[int(i) for i in input(f\"proceso {j + 1}: \").split()] for j in range(processes)]\n\n    print(\"\\n--- recursos m\u00e1ximos para cada proceso  ---\")\n    max_need = [[int(i) for i in input(f\"proceso {j + 1}: \").split()] for j in range(processes)]\n\n    allocated = [0] * resources\n    for i in range(processes):\n        for j in range(resources):\n            allocated[j] += currently_allocated[i][j]\n    print(f\"\\nRecursos totales asignados \u00a0: {allocated}\")\n\n    available = [max_resources[i] - allocated[i] for i in range(resources)]\n    print(f\"Recursos totales disponibles: {available}\\n\")\n\n    running = [True] * processes\n    count = processes\n    while count != 0:\n        safe = False\n        for i in range(processes):\n            if running[i]:\n                executing = True\n                for j in range(resources):\n                    if max_need[i][j] - currently_allocated[i][j] > available[j]:\n                        executing = False\n                        break\n                if executing:\n                    print(f\"proceso {i + 1} ejecut\u00e1ndose\")\n                    running[i] = False\n                    count -= 1\n                    safe = True\n                    for j in range(resources):\n                        available[j] += currently_allocated[i][j]\n                    break\n        if not safe:\n            print(\"El proceso est\u00e1 en un estado inseguro.\")\n            break\n\n        print(f\"El proceso est\u00e1 en un estado seguro.\\nRecursos disponibles: {available}\\n\")\n\n\nif __name__ == '__main__':\n    main()", "gold": "#include <stdio.h>\n#include <stdbool.h>\n\nint main() {\n    int curr[5][5];\n    int max_claim[5][5];\n    int avl[5];\n    int alloc[5] = {0, 0, 0, 0, 0};\n    int max_res[5];\n    int running[5];\n\n    int i, j, exec, r, p;\n    int count = 0;\n    bool safe = false;\n\n    printf(\"\\nEnter the number of resources: \");\n    scanf(\"%d\", &r);\n\n    printf(\"\\nEnter the number of processes: \");\n    scanf(\"%d\", &p);\n    for (i = 0; i < p; i++) {\n        running[i] = 1;\n        count++;\n    }\n\n    printf(\"\\nEnter Claim Vector: \");\n    for (i = 0; i < r; i++)\n        scanf(\"%d\", &max_res[i]);\n\n    printf(\"\\nEnter Allocated Resource Table: \");\n    for (i = 0; i < p; i++) {\n        for (j = 0; j < r; j++)\n            scanf(\"%d\", &curr[i][j]);\n    }\n\n    printf(\"\\nEnter Maximum Claim table: \");\n    for (i = 0; i < p; i++) {\n        for (j = 0; j < r; j++)\n            scanf(\"%d\", &max_claim[i][j]);\n    }\n\n    printf(\"\\nThe Claim Vector is: \");\n    for (i = 0; i < r; i++)\n        printf(\"%d \", max_res[i]);\n\n    printf(\"\\nThe Allocated Resource Table:\\n\");\n    for (i = 0; i < p; i++) {\n        for (j = 0; j < r; j++)\n            printf(\"\\t%d\", curr[i][j]);\n        printf(\"\\n\");\n    }\n\n    printf(\"\\nThe Maximum Claim Table:\\n\");\n    for (i = 0; i < p; i++) {\n        for (j = 0; j < r; j++)\n            printf(\"\\t%d\", max_claim[i][j]);\n        printf(\"\\n\");\n    }\n\n    for (i = 0; i < p; i++)\n        for (j = 0; j < r; j++)\n            alloc[j] += curr[i][j];\n\n    printf(\"\\nAllocated resources: \");\n    for (i = 0; i < r; i++)\n        printf(\"%d \", alloc[i]);\n    for (i = 0; i < r; i++)\n        avl[i] = max_res[i] - alloc[i];\n\n    printf(\"\\nAvailable resources: \");\n    for (i = 0; i < r; i++)\n        printf(\"%d \", avl[i]);\n    printf(\"\\n\");\n\n    while (count != 0) {\n        safe = false;\n        for (i = 0; i < p; i++) {\n            if (running[i]) {\n                exec = 1;\n                for (j = 0; j < r; j++) {\n                    if (max_claim[i][j] - curr[i][j] > avl[j]) {\n                        exec = 0;\n                        break;\n                    }\n                }\n\n                if (exec) {\n                    printf(\"\\nProcess%d is executing.\\n\", i + 1);\n                    running[i] = 0;\n                    count--;\n                    safe = true;\n                    for (j = 0; j < r; j++)\n                        avl[j] += curr[i][j];\n                    break;\n                }\n            }\n        }\n\n        if (!safe) {\n            printf(\"\\nThe processes are in unsafe state.\");\n            break;\n        }\n\n        if (safe)\n            printf(\"\\nThe process is in safe state.\");\n\n        printf(\"\\nAvailable vector: \");\n        for (i = 0; i < r; i++)\n            printf(\"%d \", avl[i]);\n    }\n\n    return 0;\n}", "llm": "cs-22b", "output": "#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_SIZE 100\n\nint main() {\n    int resources, processes;\n    int max_resources[MAX_SIZE];\n    int currently_allocated[MAX_SIZE][MAX_SIZE];\n    int max_need[MAX_SIZE][MAX_SIZE];\n    int allocated[MAX_SIZE] = {0};\n    int available[MAX_SIZE];\n    bool running[MAX_SIZE];\n    int count, i, j;\n\n    printf(\"Cantidad de recursos: \");\n    scanf(\"%d\", &resources);\n    printf(\"Cantidad de procesos: \");\n    scanf(\"%d\", &processes);\n\n    printf(\"\\n-- recursos asignados para cada proceso  --\\n\");\n    for (i = 0; i < processes; i++) {\n        printf(\"proceso %d: \", i + 1);\n        for (j = 0; j < resources; j++) {\n            scanf(\"%d\", &currently_allocated[i][j]);\n        }\n    }\n\n    printf(\"\\n--- recursos m\u00e1ximos para cada proceso  ---\\n\");\n    for (i = 0; i < processes; i++) {\n        printf(\"proceso %d: \", i + 1);\n        for (j = 0; j < resources; j++) {\n            scanf(\"%d\", &max_need[i][j]);\n        }\n    }\n\n    for (i = 0; i < processes; i++) {\n        for (j = 0; j < resources; j++) {\n            allocated[j] += currently_allocated[i][j];\n        }\n    }\n    printf(\"\\nRecursos totales asignados  : \");\n    for (i = 0; i < resources; i++) {\n        printf(\"%d \", allocated[i]);\n    }\n\n    for (i = 0; i < resources; i++) {\n        available[i] = max_resources[i] - allocated[i];\n    }\n    printf(\"\\nRecursos totales disponibles: \");\n    for (i = 0; i < resources; i++) {\n        printf(\"%d \", available[i]);\n    }\n    printf(\"\\n\");\n\n    for (i = 0; i < processes; i++) {\n        running[i] = true;\n    }\n    count = processes;\n    while (count != 0) {\n        bool safe = false;\n        for (i = 0; i < processes; i++) {\n            if (running[i]) {\n                bool executing = true;\n                for (j = 0; j < resources; j++) {\n                    if (max_need[i][j] - currently_allocated[i][j] > available[j]) {\n                        executing = false;\n                        break;\n                    }\n                }\n                if (executing) {\n                    printf(\"proceso %d ejecut\u00e1ndose\\n\", i + 1);\n                    running[i] = false;\n                    count--;\n                    safe = true;\n                    for (j = 0; j < resources; j++) {\n                        available[j] += currently_allocated[i][j];\n                    }\n                    break;\n                }\n            }\n        }\n        if (!safe) {\n            printf(\"El proceso est\u00e1 en un estado inseguro.\\n\");\n            break;\n        }\n        printf(\"El proceso est\u00e1 en un estado seguro.\\nRecursos disponibles: \");\n        for (i = 0; i < resources; i++) {\n            printf(\"%d \", available[i]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}", "index": 89}
{"lang": "Python, C++", "input": "def p(n):\n    \n    return 9 < n and (9 < n % 16 or p(n // 16))\n\n\n\n\ndef main():\n    \n    xs = [\n        str(n) for n in range(1, 1 + 500)\n        if p(n)\n    ]\n    print(f'{len(xs)} matches for the predicate:\\n')\n    print(\n        table(6)(xs)\n    )\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\ndef table(n):\n    \n    def go(xs):\n        w = len(xs[-1])\n        return '\\n'.join(\n            ' '.join(row) for row in chunksOf(n)([\n                s.rjust(w, ' ') for s in xs\n            ])\n        )\n    return go\n\n\n\nif __name__ == '__main__':\n    main()", "gold": "#include <iomanip>\n#include <iostream>\n\n\n\nbool nondecimal(unsigned int n) {\n    for (; n > 0; n >>= 4) {\n        if ((n & 0xF) > 9)\n            return true;\n    }\n    return false;\n}\n\nint main() {\n    unsigned int count = 0;\n    for (unsigned int n = 0; n < 501; ++n) {\n        if (nondecimal(n)) {\n            ++count;\n            std::cout << std::setw(3) << n << (count % 15 == 0 ? '\\n' : ' ');\n        }\n    }\n    std::cout << \"\\n\\n\" << count << \" such numbers found.\\n\";\n}", "llm": "cl-13b", "output": "#include <iostream>\n#include <string>\n#include <vector>\n\nbool p(int n) {\n    return n > 9 && (n % 16 > 9 || p(n / 16));\n}\n\nint main() {\n    std::vector<std::string> xs;\n    for (int i = 1; i <= 500; i++) {\n        if (p(i)) {\n            xs.push_back(std::to_string(i));\n        }\n    }\n    std::cout << \"Number of matches: \" << xs.size() << std::endl;\n    std::cout << \"Matches: \" << std::endl;\n    for (int i = 0; i < xs.size(); i++) {\n        std::cout << xs[i] << std::endl;\n    }\n    return 0;\n}\n\nstd::vector<std::string> chunksOf(int n, std::vector<std::string> xs) {\n    std::vector<std::string> result;\n    for (int i = 0; i < xs.size(); i += n) {\n        result.push_back(xs[i]);\n    }\n    return result;\n}\n\nstd::string table(int n, std::vector<std::string> xs) {\n    std::string result;\n    for (int i = 0; i < xs.size(); i++) {\n        result += xs[i].rjust(n, ' ');\n    }\n    return result;\n}", "index": 90}
{"lang": "Python, C++", "input": "def p(n):\n    \n    return 9 < n and (9 < n % 16 or p(n // 16))\n\n\n\n\ndef main():\n    \n    xs = [\n        str(n) for n in range(1, 1 + 500)\n        if p(n)\n    ]\n    print(f'{len(xs)} matches for the predicate:\\n')\n    print(\n        table(6)(xs)\n    )\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\ndef table(n):\n    \n    def go(xs):\n        w = len(xs[-1])\n        return '\\n'.join(\n            ' '.join(row) for row in chunksOf(n)([\n                s.rjust(w, ' ') for s in xs\n            ])\n        )\n    return go\n\n\n\nif __name__ == '__main__':\n    main()", "gold": "#include <iomanip>\n#include <iostream>\n\n\n\nbool nondecimal(unsigned int n) {\n    for (; n > 0; n >>= 4) {\n        if ((n & 0xF) > 9)\n            return true;\n    }\n    return false;\n}\n\nint main() {\n    unsigned int count = 0;\n    for (unsigned int n = 0; n < 501; ++n) {\n        if (nondecimal(n)) {\n            ++count;\n            std::cout << std::setw(3) << n << (count % 15 == 0 ? '\\n' : ' ');\n        }\n    }\n    std::cout << \"\\n\\n\" << count << \" such numbers found.\\n\";\n}", "llm": "dsc-1b", "output": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nbool p(int n) {\n    if(n >= 9 && n < 16)\n        return true;\n    if(n >= 16)\n        return p(n / 16) || p(n % 16);\n    return false;\n}\n\nvoid main() {\n    std::vector<std::string> xs;\n    for(int n = 1; n <= 500; ++n)\n        if(p(n))\n            xs.push_back(std::to_string(n));\n    std::cout << xs.size() << \" matches for the predicate:\\n\";\n    for(const auto &s : xs)\n        std::cout << s << \"\\n\";\n}\n\nint main() {\n    main();\n    return 0;\n}", "index": 91}
{"lang": "Python, C++", "input": "def p(n):\n    \n    return 9 < n and (9 < n % 16 or p(n // 16))\n\n\n\n\ndef main():\n    \n    xs = [\n        str(n) for n in range(1, 1 + 500)\n        if p(n)\n    ]\n    print(f'{len(xs)} matches for the predicate:\\n')\n    print(\n        table(6)(xs)\n    )\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\ndef table(n):\n    \n    def go(xs):\n        w = len(xs[-1])\n        return '\\n'.join(\n            ' '.join(row) for row in chunksOf(n)([\n                s.rjust(w, ' ') for s in xs\n            ])\n        )\n    return go\n\n\n\nif __name__ == '__main__':\n    main()", "gold": "#include <iomanip>\n#include <iostream>\n\n\n\nbool nondecimal(unsigned int n) {\n    for (; n > 0; n >>= 4) {\n        if ((n & 0xF) > 9)\n            return true;\n    }\n    return false;\n}\n\nint main() {\n    unsigned int count = 0;\n    for (unsigned int n = 0; n < 501; ++n) {\n        if (nondecimal(n)) {\n            ++count;\n            std::cout << std::setw(3) << n << (count % 15 == 0 ? '\\n' : ' ');\n        }\n    }\n    std::cout << \"\\n\\n\" << count << \" such numbers found.\\n\";\n}", "llm": "dsc-7b", "output": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nbool p(int n) {\n    if (9 < n) {\n        if (9 < n % 16) {\n            return true;\n        } else if (p(n / 16)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nstd::vector<std::string> main_func() {\n    std::vector<std::string> xs;\n    for (int n = 1; n <= 500; ++n) {\n        if (p(n)) {\n            xs.push_back(std::to_string(n));\n        }\n    }\n    std::cout << xs.size() << \" matches for the predicate:\\n\" << std::endl;\n    return xs;\n}\n\nstd::vector<std::vector<std::string>> chunksOf(int n, std::vector<std::string> xs) {\n    std::vector<std::vector<std::string>> chunks;\n    if (n > 0) {\n        for (int i = 0; i < xs.size(); i += n) {\n            chunks.push_back(std::vector<std::string>(xs.begin() + i, xs.begin() + i + n));\n        }\n    }\n    return chunks;\n}\n\nstd::string table(int n, std::vector<std::string> xs) {\n    int w = xs.back().size();\n    std::string result = \"\";\n    std::vector<std::vector<std::string>> chunks = chunksOf(n, xs);\n    for (auto &row : chunks) {\n        for (auto &s : row) {\n            s = std::string(std::max(0, w - (int)s.size()), ' ') + s;\n        }\n        result += std::accumulate(std::begin(row), std::end(row), std::string(\"\"), \n                                  [](const std::string& a, const std::string& b) { return a + \" \" + b; }) + \"\\n\";\n    }\n    return result;\n}\n\nint main() {\n    std::vector<std::string> xs = main_func();\n    std::cout << table(6, xs);\n    return 0;\n}", "index": 92}
{"lang": "Python, Java", "input": "def product_of_divisors(n):\n    assert(isinstance(n, int) and 0 < n)\n    ans = i = j = 1\n    while i*i <= n:\n        if 0 == n%i:\n            ans *= i\n            j = n//i\n            if j != i:\n                ans *= j\n        i += 1\n    return ans\n    \nif __name__ == \"__main__\":\n    print([product_of_divisors(n) for n in range(1,51)])", "gold": "public class ProductOfDivisors {\n    private static long divisorCount(long n) {\n        long total = 1;\n        \n        for (; (n & 1) == 0; n >>= 1) {\n            ++total;\n        }\n        \n        for (long p = 3; p * p <= n; p += 2) {\n            long count = 1;\n            for (; n % p == 0; n /= p) {\n                ++count;\n            }\n            total *= count;\n        }\n        \n        if (n > 1) {\n            total *= 2;\n        }\n        return total;\n    }\n\n    private static long divisorProduct(long n) {\n        return (long) Math.pow(n, divisorCount(n) / 2.0);\n    }\n\n    public static void main(String[] args) {\n        final long limit = 50;\n        System.out.printf(\"Product of divisors for the first %d positive integers:%n\", limit);\n        for (long n = 1; n <= limit; n++) {\n            System.out.printf(\"%11d\", divisorProduct(n));\n            if (n % 5 == 0) {\n                System.out.println();\n            }\n        }\n    }\n}", "llm": "cl-13b", "output": "public static int productOfDivisors(int n) {\n    assert(n instanceof Integer && n > 0);\n    int ans = 1, i = 1, j = 1;\n    while (i*i <= n) {\n        if (n % i == 0) {\n            ans *= i;\n            j = n / i;\n            if (j != i) {\n                ans *= j;\n            }\n        }\n        i++;\n    }\n    return ans;\n}\n\npublic static void main(String[] args) {\n    for (int n = 1; n <= 50; n++) {\n        System.out.println(productOfDivisors(n));\n    }\n}", "index": 93}
{"lang": "Python, Java", "input": "def product_of_divisors(n):\n    assert(isinstance(n, int) and 0 < n)\n    ans = i = j = 1\n    while i*i <= n:\n        if 0 == n%i:\n            ans *= i\n            j = n//i\n            if j != i:\n                ans *= j\n        i += 1\n    return ans\n    \nif __name__ == \"__main__\":\n    print([product_of_divisors(n) for n in range(1,51)])", "gold": "public class ProductOfDivisors {\n    private static long divisorCount(long n) {\n        long total = 1;\n        \n        for (; (n & 1) == 0; n >>= 1) {\n            ++total;\n        }\n        \n        for (long p = 3; p * p <= n; p += 2) {\n            long count = 1;\n            for (; n % p == 0; n /= p) {\n                ++count;\n            }\n            total *= count;\n        }\n        \n        if (n > 1) {\n            total *= 2;\n        }\n        return total;\n    }\n\n    private static long divisorProduct(long n) {\n        return (long) Math.pow(n, divisorCount(n) / 2.0);\n    }\n\n    public static void main(String[] args) {\n        final long limit = 50;\n        System.out.printf(\"Product of divisors for the first %d positive integers:%n\", limit);\n        for (long n = 1; n <= limit; n++) {\n            System.out.printf(\"%11d\", divisorProduct(n));\n            if (n % 5 == 0) {\n                System.out.println();\n            }\n        }\n    }\n}", "llm": "cl-34b", "output": "public class ProductOfDivisors {\n    public static void main(String[] args) {\n        for (int n = 1; n <= 50; n++) {\n            System.out.println(productOfDivisors(n));\n        }\n    }\n\n    public static int productOfDivisors(int n) {\n        assert (n > 0);\n        int ans = 1;\n        int i = 1;\n        int j = 1;\n        while (i * i <= n) {\n            if (n % i == 0) {\n                ans *= i;\n                j = n / i;\n                if (j != i) {\n                    ans *= j;\n                }\n            }\n            i++;\n        }\n        return ans;\n    }\n}", "index": 94}
{"lang": "Python, Java", "input": "def product_of_divisors(n):\n    assert(isinstance(n, int) and 0 < n)\n    ans = i = j = 1\n    while i*i <= n:\n        if 0 == n%i:\n            ans *= i\n            j = n//i\n            if j != i:\n                ans *= j\n        i += 1\n    return ans\n    \nif __name__ == \"__main__\":\n    print([product_of_divisors(n) for n in range(1,51)])", "gold": "public class ProductOfDivisors {\n    private static long divisorCount(long n) {\n        long total = 1;\n        \n        for (; (n & 1) == 0; n >>= 1) {\n            ++total;\n        }\n        \n        for (long p = 3; p * p <= n; p += 2) {\n            long count = 1;\n            for (; n % p == 0; n /= p) {\n                ++count;\n            }\n            total *= count;\n        }\n        \n        if (n > 1) {\n            total *= 2;\n        }\n        return total;\n    }\n\n    private static long divisorProduct(long n) {\n        return (long) Math.pow(n, divisorCount(n) / 2.0);\n    }\n\n    public static void main(String[] args) {\n        final long limit = 50;\n        System.out.printf(\"Product of divisors for the first %d positive integers:%n\", limit);\n        for (long n = 1; n <= limit; n++) {\n            System.out.printf(\"%11d\", divisorProduct(n));\n            if (n % 5 == 0) {\n                System.out.println();\n            }\n        }\n    }\n}", "llm": "cg4-9b", "output": "public class Main {\n    public static void main(String[] args) {\n        for (int n = 1; n <= 50; n++) {\n            System.out.print(productOfDivisors(n) + \" \");\n        }\n    }\n\n    public static int productOfDivisors(int n) {\n        assert (n > 0);\n        int ans = 1;\n        int i = 1;\n        while (i * i <= n) {\n            if (n % i == 0) {\n                ans *= i;\n                int j = n / i;\n                if (j != i) {\n                    ans *= j;\n                }\n            }\n            i++;\n        }\n        return ans;\n    }\n}", "index": 95}
{"lang": "Python, C", "input": "for i in xrange(10, -1, -1):\n    print i", "gold": "int i;\nfor(i = 10; i >= 0; --i)\n  printf(\"%d\\n\",i);", "llm": "dsc-7b", "output": "for(int i=10; i>=0; i--)\n    printf(\"%d\\n\", i);", "index": 96}
{"lang": "Python, C", "input": "for i in xrange(10, -1, -1):\n    print i", "gold": "int i;\nfor(i = 10; i >= 0; --i)\n  printf(\"%d\\n\",i);", "llm": "magic-7b", "output": "#include <stdio.h>\n\nint main() {\n    for(int i = 10; i >= 0; i--) {\n        printf(\"%d\\n\", i);\n    }\n    return 0;\n}", "index": 97}
{"lang": "Python, C", "input": "for i in xrange(10, -1, -1):\n    print i", "gold": "int i;\nfor(i = 10; i >= 0; --i)\n  printf(\"%d\\n\",i);", "llm": "cg4-9b", "output": "#include <stdio.h>\n\nint main() {\n    for (int i = 10; i >= 0; i--) {\n        printf(\"%d\\n\", i);\n    }\n    return 0;\n}", "index": 98}
{"lang": "Python, C++", "input": "from mpmath import mp\nheegner = [19,43,67,163]\nmp.dps = 50\nx = mp.exp(mp.pi*mp.sqrt(163))\nprint(\"calculated Ramanujan's constant: {}\".format(x))\nprint(\"Heegner numbers yielding 'almost' integers:\")\nfor i in heegner:\n    print(\" for {}: {} ~ {} error: {}\".format(str(i),mp.exp(mp.pi*mp.sqrt(i)),round(mp.exp(mp.pi*mp.sqrt(i))),(mp.pi*mp.sqrt(i)) - round(mp.pi*mp.sqrt(i))))", "gold": "#include <iomanip>\n#include <iostream>\n#include <boost/math/constants/constants.hpp>\n#include <boost/multiprecision/cpp_dec_float.hpp>\n\nusing big_float = boost::multiprecision::cpp_dec_float_100;\n\nbig_float f(unsigned int n) {\n    big_float pi(boost::math::constants::pi<big_float>());\n    return exp(sqrt(big_float(n)) * pi);\n}\n\nint main() {\n    std::cout << \"Ramanujan's constant using formula f(N) = exp(pi*sqrt(N)):\\n\"\n        << std::setprecision(80) << f(163) << '\\n';\n    std::cout << \"\\nResult with last four Heegner numbers:\\n\";\n    std::cout << std::setprecision(30);\n    for (unsigned int n : {19, 43, 67, 163}) {\n        auto x = f(n);\n        auto c = ceil(x);\n        auto pc = 100.0 * (x/c);\n        std::cout << \"f(\" << n << \") = \" << x << \" = \"\n            << pc << \"% of \" << c << '\\n';\n    }\n    return 0;\n}", "llm": "cl-7b", "output": "#include <iostream>\n#include <cmath>\n#include <mpmath.h>\n\nint main() {\n    mp::dps = 50;\n    mp::exp(mp::pi * mp::sqrt(163));\n    std::cout << \"calculated Ramanujan's constant: \" << x << std::endl;\n    std::cout << \"Heegner numbers yielding 'almost' integers:\" << std::endl;\n    for (int i : heegner) {\n        std::cout << \" for \" << i << \": \" << mp::exp(mp::pi * mp::sqrt(i)) << \" ~ \" << round(mp::exp(mp::pi * mp::sqrt(i))) << \" error: \" << (mp::pi * mp::sqrt(i)) - round(mp::pi * mp::sqrt(i)) << std::endl;\n    }\n    return 0;\n}", "index": 99}
{"lang": "Python, C++", "input": "from mpmath import mp\nheegner = [19,43,67,163]\nmp.dps = 50\nx = mp.exp(mp.pi*mp.sqrt(163))\nprint(\"calculated Ramanujan's constant: {}\".format(x))\nprint(\"Heegner numbers yielding 'almost' integers:\")\nfor i in heegner:\n    print(\" for {}: {} ~ {} error: {}\".format(str(i),mp.exp(mp.pi*mp.sqrt(i)),round(mp.exp(mp.pi*mp.sqrt(i))),(mp.pi*mp.sqrt(i)) - round(mp.pi*mp.sqrt(i))))", "gold": "#include <iomanip>\n#include <iostream>\n#include <boost/math/constants/constants.hpp>\n#include <boost/multiprecision/cpp_dec_float.hpp>\n\nusing big_float = boost::multiprecision::cpp_dec_float_100;\n\nbig_float f(unsigned int n) {\n    big_float pi(boost::math::constants::pi<big_float>());\n    return exp(sqrt(big_float(n)) * pi);\n}\n\nint main() {\n    std::cout << \"Ramanujan's constant using formula f(N) = exp(pi*sqrt(N)):\\n\"\n        << std::setprecision(80) << f(163) << '\\n';\n    std::cout << \"\\nResult with last four Heegner numbers:\\n\";\n    std::cout << std::setprecision(30);\n    for (unsigned int n : {19, 43, 67, 163}) {\n        auto x = f(n);\n        auto c = ceil(x);\n        auto pc = 100.0 * (x/c);\n        std::cout << \"f(\" << n << \") = \" << x << \" = \"\n            << pc << \"% of \" << c << '\\n';\n    }\n    return 0;\n}", "llm": "q2.5-1.5b", "output": "#include <iostream>\n#include <cmath>\n#include <iomanip>\n#include <mpmath.h>\n\nint main() {\n    mp::mpf_t x;\n    mp::mpf_set_dps(50);\n    x = mp::exp(M_PI * sqrt(163));\n    std::cout << \"calculated Ramanujan's constant: \" << x << std::endl;\n    std::cout << \"Heegner numbers yielding 'almost' integers:\" << std::endl;\n    for (int i : {19, 43, 67, 163}) {\n        mp::mpf_t exp_val;\n        mp::mpf_set_dps(50);\n        exp_val = mp::exp(M_PI * sqrt(i));\n        std::cout << \" for {}: {} ~ {} error: {}\" << std::fixed << std::setprecision(10) << i << \" \" << exp_val << \" \" << round(exp_val) << \" \" << (M_PI * sqrt(i)) - round(exp_val) << std::endl;\n    }\n    return 0;\n}", "index": 100}
{"lang": "Python, C++", "input": "from mpmath import mp\nheegner = [19,43,67,163]\nmp.dps = 50\nx = mp.exp(mp.pi*mp.sqrt(163))\nprint(\"calculated Ramanujan's constant: {}\".format(x))\nprint(\"Heegner numbers yielding 'almost' integers:\")\nfor i in heegner:\n    print(\" for {}: {} ~ {} error: {}\".format(str(i),mp.exp(mp.pi*mp.sqrt(i)),round(mp.exp(mp.pi*mp.sqrt(i))),(mp.pi*mp.sqrt(i)) - round(mp.pi*mp.sqrt(i))))", "gold": "#include <iomanip>\n#include <iostream>\n#include <boost/math/constants/constants.hpp>\n#include <boost/multiprecision/cpp_dec_float.hpp>\n\nusing big_float = boost::multiprecision::cpp_dec_float_100;\n\nbig_float f(unsigned int n) {\n    big_float pi(boost::math::constants::pi<big_float>());\n    return exp(sqrt(big_float(n)) * pi);\n}\n\nint main() {\n    std::cout << \"Ramanujan's constant using formula f(N) = exp(pi*sqrt(N)):\\n\"\n        << std::setprecision(80) << f(163) << '\\n';\n    std::cout << \"\\nResult with last four Heegner numbers:\\n\";\n    std::cout << std::setprecision(30);\n    for (unsigned int n : {19, 43, 67, 163}) {\n        auto x = f(n);\n        auto c = ceil(x);\n        auto pc = 100.0 * (x/c);\n        std::cout << \"f(\" << n << \") = \" << x << \" = \"\n            << pc << \"% of \" << c << '\\n';\n    }\n    return 0;\n}", "llm": "magic-7b", "output": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <iomanip>\n\nint main() {\n    std::vector<int> heegner = {19, 43, 67, 163};\n    double x = exp(M_PI * sqrt(163));\n    std::cout << \"calculated Ramanujan's constant: \" << std::setprecision(50) << x << std::endl;\n    std::cout << \"Heegner numbers yielding 'almost' integers:\" << std::endl;\n    for (int i : heegner) {\n        double y = exp(M_PI * sqrt(i));\n        double z = round(y);\n        std::cout << \" for \" << i << \": \" << y << \" ~ \" << z << \" error: \" << (M_PI * sqrt(i)) - z << std::endl;\n    }\n    return 0;\n}", "index": 101}
{"lang": "Python, C++", "input": "from sympy import divisors\n\nfrom sympy.combinatorics.subsets import Subset\n\ndef isZumkeller(n):\n    d = divisors(n)\n    s = sum(d)\n    if not s % 2 and max(d) <= s/2:\n        for x in range(1, 2**len(d)):\n            if sum(Subset.unrank_binary(x, d).subset) == s/2:\n                return True\n\n    return False\n\n\n\ndef printZumkellers(N, oddonly=False):\n    nprinted = 0\n    for n in range(1, 10**5):\n        if (oddonly == False or n % 2) and isZumkeller(n):\n            print(f'{n:>8}', end='')\n            nprinted += 1\n            if nprinted % 10 == 0:\n                print()\n            if nprinted >= N:\n                return\n\n\nprint(\"220 Zumkeller numbers:\")\nprintZumkellers(220)\nprint(\"\\n\\n40 odd Zumkeller numbers:\")\nprintZumkellers(40, True)", "gold": "#include <iostream\">\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n#include <numeric>\n\nusing namespace std;\n\n\nconst uint* binary(uint n, uint length);\n\n\n\nuint sum_subset_unrank_bin(const vector<uint>& d, uint r);\n\nvector<uint> factors(uint x);\n\nbool isPrime(uint number);\n\nbool isZum(uint n);\n\nostream& operator<<(ostream& os, const vector<uint>& zumz) {\n    for (uint i = 0; i < zumz.size(); i++) {\n        if (i % 10 == 0)\n            os << endl;\n        os << setw(10) << zumz[i] << ' ';\n    }\n    return os;\n}\n\nint main() {\n    cout << \"First 220 Zumkeller numbers:\" << endl;\n    vector<uint> zumz;\n    for (uint n = 2; zumz.size() < 220; n++)\n        if (isZum(n))\n            zumz.push_back(n);\n    cout << zumz << endl << endl;\n\n    cout << \"First 40 odd Zumkeller numbers:\" << endl;\n    vector<uint> zumz2;\n    for (uint n = 2; zumz2.size() < 40; n++)\n        if (n % 2 && isZum(n))\n            zumz2.push_back(n);\n    cout << zumz2 << endl << endl;\n\n    cout << \"First 40 odd Zumkeller numbers not ending in 5:\" << endl;\n    vector<uint> zumz3;\n    for (uint n = 2; zumz3.size() < 40; n++)\n        if (n % 2 && (n % 10) !=  5 && isZum(n))\n            zumz3.push_back(n);\n    cout << zumz3 << endl << endl;\n\n    return 0;\n}\n\n\nconst uint* binary(uint n, uint length) {\n    uint* bin = new uint[length];\t    \n    fill(bin, bin + length, 0);         \n    \n    for (uint i = 0; n > 0; i++) {\n        uint rem = n % 2;\n        n /= 2;\n        if (rem)\n            bin[length - 1 - i] = 1;\n    }\n\n    return bin;\n}\n\n\n\nuint sum_subset_unrank_bin(const vector<uint>& d, uint r) {\n    vector<uint> subset;\n    \n    const uint* bits = binary(r, d.size() - 1);\n\n    \n    for (uint i = 0; i < d.size() - 1; i++)\n        if (bits[i])\n            subset.push_back(d[i]);\n\n    delete[] bits;\n\n    return accumulate(subset.begin(), subset.end(), 0u);\n}\n\nvector<uint> factors(uint x) {\n    vector<uint> result;\n    \n    for (uint i = 1; i * i <= x; i++) {\n        \n        if (x % i == 0) {\n            result.push_back(i);\n\n            if (x / i != i)\n                result.push_back(x / i);\n        }\n    }\n\n    \n    sort(result.begin(), result.end());\n    return result;\n}\n\nbool isPrime(uint number) {\n    if (number < 2) return false;\n    if (number == 2) return true;\n    if (number % 2 == 0) return false;\n    for (uint i = 3; i * i <= number; i += 2)\n        if (number % i == 0) return false;\n\n    return true;\n}\n\nbool isZum(uint n) {\n    \n    if (isPrime(n))\n        return false;\n\n    \n    const auto d = factors(n);\n    uint s = accumulate(d.begin(), d.end(), 0u);\n\n    \n    if (s % 2 || s < 2 * n)\n        return false;\n\n    \n    \n    \n    if (n % 2 || d.size() >= 24)\n        return true;\n\n    if (!(s % 2) && d[d.size() - 1] <= s / 2)\n        for (uint x = 2; (uint) log2(x) < (d.size() - 1); x++) \n            if (sum_subset_unrank_bin(d, x) == s / 2)\n                return true; \n\n    \n    return false;\n}", "llm": "cl-7b", "output": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool isZumkeller(int n) {\n    vector<int> d = divisors(n);\n    int s = sum(d);\n    if (s % 2 == 0 && max(d) <= s/2) {\n        for (int x = 1; x < pow(2, d.size()); x++) {\n            if (sum(Subset.unrank_binary(x, d).subset) == s/2) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nvoid printZumkellers(int N, bool oddonly) {\n    int nprinted = 0;\n    for (int n = 1; n < pow(10, 5); n++) {\n        if ((!oddonly || n % 2) && isZumkeller(n)) {\n            cout << setw(8) << n;\n            nprinted++;\n            if (nprinted % 10 == 0) {\n                cout << endl;\n            }\n            if (nprinted >= N) {\n                return;\n            }\n        }\n    }\n}\n\nint main() {\n    cout << \"220 Zumkeller numbers:\" << endl;\n    printZumkellers(220);\n    cout << \"\\n\\n40 odd Zumkeller numbers:\" << endl;\n    printZumkellers(40, true);\n    return 0;\n}", "index": 102}
{"lang": "Python, C++", "input": "from sympy import divisors\n\nfrom sympy.combinatorics.subsets import Subset\n\ndef isZumkeller(n):\n    d = divisors(n)\n    s = sum(d)\n    if not s % 2 and max(d) <= s/2:\n        for x in range(1, 2**len(d)):\n            if sum(Subset.unrank_binary(x, d).subset) == s/2:\n                return True\n\n    return False\n\n\n\ndef printZumkellers(N, oddonly=False):\n    nprinted = 0\n    for n in range(1, 10**5):\n        if (oddonly == False or n % 2) and isZumkeller(n):\n            print(f'{n:>8}', end='')\n            nprinted += 1\n            if nprinted % 10 == 0:\n                print()\n            if nprinted >= N:\n                return\n\n\nprint(\"220 Zumkeller numbers:\")\nprintZumkellers(220)\nprint(\"\\n\\n40 odd Zumkeller numbers:\")\nprintZumkellers(40, True)", "gold": "#include <iostream\">\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n#include <numeric>\n\nusing namespace std;\n\n\nconst uint* binary(uint n, uint length);\n\n\n\nuint sum_subset_unrank_bin(const vector<uint>& d, uint r);\n\nvector<uint> factors(uint x);\n\nbool isPrime(uint number);\n\nbool isZum(uint n);\n\nostream& operator<<(ostream& os, const vector<uint>& zumz) {\n    for (uint i = 0; i < zumz.size(); i++) {\n        if (i % 10 == 0)\n            os << endl;\n        os << setw(10) << zumz[i] << ' ';\n    }\n    return os;\n}\n\nint main() {\n    cout << \"First 220 Zumkeller numbers:\" << endl;\n    vector<uint> zumz;\n    for (uint n = 2; zumz.size() < 220; n++)\n        if (isZum(n))\n            zumz.push_back(n);\n    cout << zumz << endl << endl;\n\n    cout << \"First 40 odd Zumkeller numbers:\" << endl;\n    vector<uint> zumz2;\n    for (uint n = 2; zumz2.size() < 40; n++)\n        if (n % 2 && isZum(n))\n            zumz2.push_back(n);\n    cout << zumz2 << endl << endl;\n\n    cout << \"First 40 odd Zumkeller numbers not ending in 5:\" << endl;\n    vector<uint> zumz3;\n    for (uint n = 2; zumz3.size() < 40; n++)\n        if (n % 2 && (n % 10) !=  5 && isZum(n))\n            zumz3.push_back(n);\n    cout << zumz3 << endl << endl;\n\n    return 0;\n}\n\n\nconst uint* binary(uint n, uint length) {\n    uint* bin = new uint[length];\t    \n    fill(bin, bin + length, 0);         \n    \n    for (uint i = 0; n > 0; i++) {\n        uint rem = n % 2;\n        n /= 2;\n        if (rem)\n            bin[length - 1 - i] = 1;\n    }\n\n    return bin;\n}\n\n\n\nuint sum_subset_unrank_bin(const vector<uint>& d, uint r) {\n    vector<uint> subset;\n    \n    const uint* bits = binary(r, d.size() - 1);\n\n    \n    for (uint i = 0; i < d.size() - 1; i++)\n        if (bits[i])\n            subset.push_back(d[i]);\n\n    delete[] bits;\n\n    return accumulate(subset.begin(), subset.end(), 0u);\n}\n\nvector<uint> factors(uint x) {\n    vector<uint> result;\n    \n    for (uint i = 1; i * i <= x; i++) {\n        \n        if (x % i == 0) {\n            result.push_back(i);\n\n            if (x / i != i)\n                result.push_back(x / i);\n        }\n    }\n\n    \n    sort(result.begin(), result.end());\n    return result;\n}\n\nbool isPrime(uint number) {\n    if (number < 2) return false;\n    if (number == 2) return true;\n    if (number % 2 == 0) return false;\n    for (uint i = 3; i * i <= number; i += 2)\n        if (number % i == 0) return false;\n\n    return true;\n}\n\nbool isZum(uint n) {\n    \n    if (isPrime(n))\n        return false;\n\n    \n    const auto d = factors(n);\n    uint s = accumulate(d.begin(), d.end(), 0u);\n\n    \n    if (s % 2 || s < 2 * n)\n        return false;\n\n    \n    \n    \n    if (n % 2 || d.size() >= 24)\n        return true;\n\n    if (!(s % 2) && d[d.size() - 1] <= s / 2)\n        for (uint x = 2; (uint) log2(x) < (d.size() - 1); x++) \n            if (sum_subset_unrank_bin(d, x) == s / 2)\n                return true; \n\n    \n    return false;\n}", "llm": "dsc-33b", "output": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <algorithm>\n\nstd::vector<int> divisors(int n) {\n    std::vector<int> divs;\n    for (int i = 1; i <= n; i++) {\n        if (n % i == 0) {\n            divs.push_back(i);\n        }\n    }\n    return divs;\n}\n\nbool isZumkeller(int n) {\n    std::vector<int> d = divisors(n);\n    int s = std::accumulate(d.begin(), d.end(), 0);\n    if (s % 2 == 0 && *max_element(d.begin(), d.end()) <= s/2) {\n        for (int x = 1; x < (1 << d.size()); x++) {\n            int sum = 0;\n            for (int i = 0; i < d.size(); i++) {\n                if (x & (1 << i)) {\n                    sum += d[i];\n                }\n            }\n            if (sum == s/2) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nvoid printZumkellers(int N, bool oddonly = false) {\n    int nprinted = 0;\n    for (int n = 1; n < 100000; n++) {\n        if ((oddonly == false || n % 2 != 0) && isZumkeller(n)) {\n            std::cout << n << \" \";\n            nprinted++;\n            if (nprinted % 10 == 0) {\n                std::cout << std::endl;\n            }\n            if (nprinted >= N) {\n                return;\n            }\n        }\n    }\n}\n\nint main() {\n    std::cout << \"220 Zumkeller numbers:\" << std::endl;\n    printZumkellers(220);\n    std::cout << \"\\n\\n40 odd Zumkeller numbers:\" << std::endl;\n    printZumkellers(40, true);\n    return 0;\n}", "index": 103}
{"lang": "Python, C++", "input": "from sympy import divisors\n\nfrom sympy.combinatorics.subsets import Subset\n\ndef isZumkeller(n):\n    d = divisors(n)\n    s = sum(d)\n    if not s % 2 and max(d) <= s/2:\n        for x in range(1, 2**len(d)):\n            if sum(Subset.unrank_binary(x, d).subset) == s/2:\n                return True\n\n    return False\n\n\n\ndef printZumkellers(N, oddonly=False):\n    nprinted = 0\n    for n in range(1, 10**5):\n        if (oddonly == False or n % 2) and isZumkeller(n):\n            print(f'{n:>8}', end='')\n            nprinted += 1\n            if nprinted % 10 == 0:\n                print()\n            if nprinted >= N:\n                return\n\n\nprint(\"220 Zumkeller numbers:\")\nprintZumkellers(220)\nprint(\"\\n\\n40 odd Zumkeller numbers:\")\nprintZumkellers(40, True)", "gold": "#include <iostream\">\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n#include <numeric>\n\nusing namespace std;\n\n\nconst uint* binary(uint n, uint length);\n\n\n\nuint sum_subset_unrank_bin(const vector<uint>& d, uint r);\n\nvector<uint> factors(uint x);\n\nbool isPrime(uint number);\n\nbool isZum(uint n);\n\nostream& operator<<(ostream& os, const vector<uint>& zumz) {\n    for (uint i = 0; i < zumz.size(); i++) {\n        if (i % 10 == 0)\n            os << endl;\n        os << setw(10) << zumz[i] << ' ';\n    }\n    return os;\n}\n\nint main() {\n    cout << \"First 220 Zumkeller numbers:\" << endl;\n    vector<uint> zumz;\n    for (uint n = 2; zumz.size() < 220; n++)\n        if (isZum(n))\n            zumz.push_back(n);\n    cout << zumz << endl << endl;\n\n    cout << \"First 40 odd Zumkeller numbers:\" << endl;\n    vector<uint> zumz2;\n    for (uint n = 2; zumz2.size() < 40; n++)\n        if (n % 2 && isZum(n))\n            zumz2.push_back(n);\n    cout << zumz2 << endl << endl;\n\n    cout << \"First 40 odd Zumkeller numbers not ending in 5:\" << endl;\n    vector<uint> zumz3;\n    for (uint n = 2; zumz3.size() < 40; n++)\n        if (n % 2 && (n % 10) !=  5 && isZum(n))\n            zumz3.push_back(n);\n    cout << zumz3 << endl << endl;\n\n    return 0;\n}\n\n\nconst uint* binary(uint n, uint length) {\n    uint* bin = new uint[length];\t    \n    fill(bin, bin + length, 0);         \n    \n    for (uint i = 0; n > 0; i++) {\n        uint rem = n % 2;\n        n /= 2;\n        if (rem)\n            bin[length - 1 - i] = 1;\n    }\n\n    return bin;\n}\n\n\n\nuint sum_subset_unrank_bin(const vector<uint>& d, uint r) {\n    vector<uint> subset;\n    \n    const uint* bits = binary(r, d.size() - 1);\n\n    \n    for (uint i = 0; i < d.size() - 1; i++)\n        if (bits[i])\n            subset.push_back(d[i]);\n\n    delete[] bits;\n\n    return accumulate(subset.begin(), subset.end(), 0u);\n}\n\nvector<uint> factors(uint x) {\n    vector<uint> result;\n    \n    for (uint i = 1; i * i <= x; i++) {\n        \n        if (x % i == 0) {\n            result.push_back(i);\n\n            if (x / i != i)\n                result.push_back(x / i);\n        }\n    }\n\n    \n    sort(result.begin(), result.end());\n    return result;\n}\n\nbool isPrime(uint number) {\n    if (number < 2) return false;\n    if (number == 2) return true;\n    if (number % 2 == 0) return false;\n    for (uint i = 3; i * i <= number; i += 2)\n        if (number % i == 0) return false;\n\n    return true;\n}\n\nbool isZum(uint n) {\n    \n    if (isPrime(n))\n        return false;\n\n    \n    const auto d = factors(n);\n    uint s = accumulate(d.begin(), d.end(), 0u);\n\n    \n    if (s % 2 || s < 2 * n)\n        return false;\n\n    \n    \n    \n    if (n % 2 || d.size() >= 24)\n        return true;\n\n    if (!(s % 2) && d[d.size() - 1] <= s / 2)\n        for (uint x = 2; (uint) log2(x) < (d.size() - 1); x++) \n            if (sum_subset_unrank_bin(d, x) == s / 2)\n                return true; \n\n    \n    return false;\n}", "llm": "q2.5-7b", "output": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <algorithm>\n\nbool isZumkeller(int n) {\n    std::vector<int> d;\n    for (int i = 1; i <= n / 2; ++i) {\n        if (n % i == 0) {\n            d.push_back(i);\n        }\n    }\n    int s = std::accumulate(d.begin(), d.end(), 0);\n    if (s % 2 == 0 && *std::max_element(d.begin(), d.end()) <= s / 2) {\n        for (int x = 1; x < (1 << d.size()); ++x) {\n            int sum = 0;\n            for (int i = 0; i < d.size(); ++i) {\n                if (x & (1 << i)) {\n                    sum += d[i];\n                }\n            }\n            if (sum == s / 2) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nvoid printZumkellers(int N, bool oddonly) {\n    int nprinted = 0;\n    for (int n = 1; n < 100000; ++n) {\n        if (!oddonly || n % 2) {\n            if (isZumkeller(n)) {\n                std::cout << std::setw(8) << n;\n                ++nprinted;\n                if (nprinted % 10 == 0) {\n                    std::cout << std::endl;\n                }\n                if (nprinted >= N) {\n                    return;\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    std::cout << \"220 Zumkeller numbers:\" << std::endl;\n    printZumkellers(220);\n    std::cout << \"\\n\\n40 odd Zumkeller numbers:\" << std::endl;\n    printZumkellers(40, true);\n    return 0;\n}", "index": 104}
{"lang": "Python, Java", "input": "from sys import stdin, stdout\n\ndef char_in(): return stdin.read(1)\ndef char_out(c): stdout.write(c)\n\ndef odd(prev = lambda: None):\n\ta = char_in()\n\tif not a.isalpha():\n\t\tprev()\n\t\tchar_out(a)\n\t\treturn a != '.'\n\n\t\n\tdef clos():\n\t\tchar_out(a)\n\t\tprev()\n\n\treturn odd(clos)\n\ndef even():\n\twhile True:\n\t\tc = char_in()\n\t\tchar_out(c)\n\t\tif not c.isalpha(): return c != '.'\n\ne = False\nwhile odd() if e else even():\n\te = not e", "gold": "public class OddWord {\n    interface CharHandler {\n\tCharHandler handle(char c) throws Exception;\n    }\n    final CharHandler fwd = new CharHandler() {\n\tpublic CharHandler handle(char c) {\n\t    System.out.print(c);\n\t    return (Character.isLetter(c) ? fwd : rev);\n\t}\n    };\n    class Reverser extends Thread implements CharHandler {\n\tReverser() {\n\t    setDaemon(true);\n\t    start();\n\t}\n\tprivate Character ch; \n\tprivate char recur() throws Exception {\n\t    notify();\n\t    while (ch == null) wait();\n\t    char c = ch, ret = c;\n\t    ch = null;\n\t    if (Character.isLetter(c)) {\n\t\tret = recur();\n\t\tSystem.out.print(c);\n\t    }\n\t    return ret;\n\t}\n\tpublic synchronized void run() {\n\t    try {\n\t\twhile (true) {\n\t\t    System.out.print(recur());\n\t\t    notify();\n\t\t}\n\t    } catch (Exception e) {}\n\t}\n\tpublic synchronized CharHandler handle(char c) throws Exception {\n\t    while (ch != null) wait();\n\t    ch = c;\n\t    notify();\n\t    while (ch != null) wait();\n\t    return (Character.isLetter(c) ? rev : fwd);\n\t}\n    }\n    final CharHandler rev = new Reverser();\n\n    public void loop() throws Exception {\n\tCharHandler handler = fwd;\n\tint c;\n\twhile ((c = System.in.read()) >= 0) {\n\t    handler = handler.handle((char) c);\n\t}\n    }\n\n    public static void main(String[] args) throws Exception {\n\tnew OddWord().loop();\n    }\n}", "llm": "cl-34b", "output": "import java.util.Scanner;\n\npublic class OddEven {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        boolean e = false;\n        while (odd(e) || even(e)) {\n            e = !e;\n        }\n    }\n\n    public static boolean odd(boolean e) {\n        char a = scanner.next().charAt(0);\n        if (!Character.isLetter(a)) {\n            return false;\n        }\n        System.out.print(a);\n        return true;\n    }\n\n    public static boolean even(boolean e) {\n        char c = scanner.next().charAt(0);\n        if (!Character.isLetter(c)) {\n            return false;\n        }\n        System.out.print(c);\n        return true;\n    }\n}", "index": 105}
{"lang": "Python, Java", "input": "from sys import stdin, stdout\n\ndef char_in(): return stdin.read(1)\ndef char_out(c): stdout.write(c)\n\ndef odd(prev = lambda: None):\n\ta = char_in()\n\tif not a.isalpha():\n\t\tprev()\n\t\tchar_out(a)\n\t\treturn a != '.'\n\n\t\n\tdef clos():\n\t\tchar_out(a)\n\t\tprev()\n\n\treturn odd(clos)\n\ndef even():\n\twhile True:\n\t\tc = char_in()\n\t\tchar_out(c)\n\t\tif not c.isalpha(): return c != '.'\n\ne = False\nwhile odd() if e else even():\n\te = not e", "gold": "public class OddWord {\n    interface CharHandler {\n\tCharHandler handle(char c) throws Exception;\n    }\n    final CharHandler fwd = new CharHandler() {\n\tpublic CharHandler handle(char c) {\n\t    System.out.print(c);\n\t    return (Character.isLetter(c) ? fwd : rev);\n\t}\n    };\n    class Reverser extends Thread implements CharHandler {\n\tReverser() {\n\t    setDaemon(true);\n\t    start();\n\t}\n\tprivate Character ch; \n\tprivate char recur() throws Exception {\n\t    notify();\n\t    while (ch == null) wait();\n\t    char c = ch, ret = c;\n\t    ch = null;\n\t    if (Character.isLetter(c)) {\n\t\tret = recur();\n\t\tSystem.out.print(c);\n\t    }\n\t    return ret;\n\t}\n\tpublic synchronized void run() {\n\t    try {\n\t\twhile (true) {\n\t\t    System.out.print(recur());\n\t\t    notify();\n\t\t}\n\t    } catch (Exception e) {}\n\t}\n\tpublic synchronized CharHandler handle(char c) throws Exception {\n\t    while (ch != null) wait();\n\t    ch = c;\n\t    notify();\n\t    while (ch != null) wait();\n\t    return (Character.isLetter(c) ? rev : fwd);\n\t}\n    }\n    final CharHandler rev = new Reverser();\n\n    public void loop() throws Exception {\n\tCharHandler handler = fwd;\n\tint c;\n\twhile ((c = System.in.read()) >= 0) {\n\t    handler = handler.handle((char) c);\n\t}\n    }\n\n    public static void main(String[] args) throws Exception {\n\tnew OddWord().loop();\n    }\n}", "llm": "q2.5-1.5b", "output": "import java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw = new PrintWriter(System.out);\n\n        boolean e = false;\n        while (true) {\n            char c = br.read();\n            pw.print(c);\n            if (!Character.isLetter(c)) {\n                if (e) {\n                    pw.print(c);\n                    e = false;\n                } else {\n                    e = true;\n                }\n            }\n        }\n    }\n}", "index": 106}
{"lang": "Python, Java", "input": "from sys import stdin, stdout\n\ndef char_in(): return stdin.read(1)\ndef char_out(c): stdout.write(c)\n\ndef odd(prev = lambda: None):\n\ta = char_in()\n\tif not a.isalpha():\n\t\tprev()\n\t\tchar_out(a)\n\t\treturn a != '.'\n\n\t\n\tdef clos():\n\t\tchar_out(a)\n\t\tprev()\n\n\treturn odd(clos)\n\ndef even():\n\twhile True:\n\t\tc = char_in()\n\t\tchar_out(c)\n\t\tif not c.isalpha(): return c != '.'\n\ne = False\nwhile odd() if e else even():\n\te = not e", "gold": "public class OddWord {\n    interface CharHandler {\n\tCharHandler handle(char c) throws Exception;\n    }\n    final CharHandler fwd = new CharHandler() {\n\tpublic CharHandler handle(char c) {\n\t    System.out.print(c);\n\t    return (Character.isLetter(c) ? fwd : rev);\n\t}\n    };\n    class Reverser extends Thread implements CharHandler {\n\tReverser() {\n\t    setDaemon(true);\n\t    start();\n\t}\n\tprivate Character ch; \n\tprivate char recur() throws Exception {\n\t    notify();\n\t    while (ch == null) wait();\n\t    char c = ch, ret = c;\n\t    ch = null;\n\t    if (Character.isLetter(c)) {\n\t\tret = recur();\n\t\tSystem.out.print(c);\n\t    }\n\t    return ret;\n\t}\n\tpublic synchronized void run() {\n\t    try {\n\t\twhile (true) {\n\t\t    System.out.print(recur());\n\t\t    notify();\n\t\t}\n\t    } catch (Exception e) {}\n\t}\n\tpublic synchronized CharHandler handle(char c) throws Exception {\n\t    while (ch != null) wait();\n\t    ch = c;\n\t    notify();\n\t    while (ch != null) wait();\n\t    return (Character.isLetter(c) ? rev : fwd);\n\t}\n    }\n    final CharHandler rev = new Reverser();\n\n    public void loop() throws Exception {\n\tCharHandler handler = fwd;\n\tint c;\n\twhile ((c = System.in.read()) >= 0) {\n\t    handler = handler.handle((char) c);\n\t}\n    }\n\n    public static void main(String[] args) throws Exception {\n\tnew OddWord().loop();\n    }\n}", "llm": "cs-22b", "output": "import java.io.IOException;\nimport java.util.Scanner;\n\ninterface Prev {\n    void call();\n}\n\nclass Main {\n    static Scanner scanner = new Scanner(System.in);\n\n    static char charIn() throws IOException {\n        return (char) System.in.read();\n    }\n\n    static void charOut(char c) {\n        System.out.print(c);\n    }\n\n    static boolean odd(Prev prev) throws IOException {\n        char a = charIn();\n        if (!Character.isLetter(a)) {\n            prev.call();\n            charOut(a);\n            return a != '.';\n        }\n\n        Prev clos = () -> {\n            charOut(a);\n            prev.call();\n        };\n\n        return odd(clos);\n    }\n\n    static boolean even() throws IOException {\n        while (true) {\n            char c = charIn();\n            charOut(c);\n            if (!Character.isLetter(c)) return c != '.';\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        boolean e = false;\n        while ((e ? odd(() -> {}) : even())) {\n            e = !e;\n        }\n    }\n}", "index": 107}
{"lang": "Java, C", "input": "import java.awt.*;\nimport javax.swing.*;\n\npublic class FibonacciWordFractal extends JPanel {\n    String wordFractal;\n\n    FibonacciWordFractal(int n) {\n        setPreferredSize(new Dimension(450, 620));\n        setBackground(Color.white);\n        wordFractal = wordFractal(n);\n    }\n\n    public String wordFractal(int n) {\n        if (n < 2)\n            return n == 1 ? \"1\" : \"\";\n\n        \n        StringBuilder f1 = new StringBuilder(\"1\");\n        StringBuilder f2 = new StringBuilder(\"0\");\n\n        for (n = n - 2; n > 0; n--) {\n            String tmp = f2.toString();\n            f2.append(f1);\n\n            f1.setLength(0);\n            f1.append(tmp);\n        }\n\n        return f2.toString();\n    }\n\n    void drawWordFractal(Graphics2D g, int x, int y, int dx, int dy) {\n        for (int n = 0; n < wordFractal.length(); n++) {\n            g.drawLine(x, y, x + dx, y + dy);\n            x += dx;\n            y += dy;\n            if (wordFractal.charAt(n) == '0') {\n                int tx = dx;\n                dx = (n % 2 == 0) ? -dy : dy;\n                dy = (n % 2 == 0) ? tx : -tx;\n            }\n        }\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawWordFractal(g, 20, 20, 1, 0);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Fibonacci Word Fractal\");\n            f.setResizable(false);\n            f.add(new FibonacciWordFractal(23), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}", "gold": "#include <stdio.h>\n\nint main(void)\n{\n\tputs(\t\"%!PS-Adobe-3.0 EPSF\\n\"\n\t\t\"%%BoundingBox: -10 -10 400 565\\n\"\n\t\t\"/a{0 0 moveto 0 .4 translate 0 0 lineto stroke -1 1 scale}def\\n\"\n\t\t\"/b{a 90 rotate}def\");\n\n\tchar i;\n\tfor (i = 'c'; i <= 'z'; i++)\n\t\tprintf(\"/%c{%c %c}def\\n\", i, i-1, i-2);\n\n\tputs(\"0 setlinewidth z showpage\\n%%EOF\");\n\n\treturn 0;\n}", "llm": "cl-34b", "output": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#define WIDTH 450\n#define HEIGHT 620\n\ntypedef struct {\n    int x;\n    int y;\n} Point;\n\ntypedef struct {\n    Point p1;\n    Point p2;\n} Line;\n\ntypedef struct {\n    int n;\n    char* wordFractal;\n} FibonacciWordFractal;\n\nvoid drawWordFractal(FibonacciWordFractal* fwf, int x, int y, int dx, int dy) {\n    for (int n = 0; n < fwf->n; n++) {\n        Line line;\n        line.p1.x = x;\n        line.p1.y = y;\n        line.p2.x = x + dx;\n        line.p2.y = y + dy;\n        x += dx;\n        y += dy;\n        if (fwf->wordFractal[n] == '0') {\n            int tx = dx;\n            dx = (n % 2 == 0) ? -dy : dy;\n            dy = (n % 2 == 0) ? tx : -tx;\n        }\n    }\n}\n\nvoid paintComponent(FibonacciWordFractal* fwf, int x, int y, int dx, int dy) {\n    for (int n = 0; n < fwf->n; n++) {\n        drawWordFractal(fwf, x, y, dx, dy);\n    }\n}\n\nint main() {\n    FibonacciWordFractal fwf;\n    fwf.n = 23;\n    fwf.wordFractal = (char*)malloc(fwf.n * sizeof(char));\n    for (int n = 0; n < fwf.n; n++) {\n        fwf.wordFractal[n] = (n % 2 == 0) ? '1' : '0';\n    }\n    paintComponent(&fwf, 20, 20, 1, 0);\n    return 0;\n}", "index": 108}
{"lang": "Java, C", "input": "import java.awt.*;\nimport javax.swing.*;\n\npublic class FibonacciWordFractal extends JPanel {\n    String wordFractal;\n\n    FibonacciWordFractal(int n) {\n        setPreferredSize(new Dimension(450, 620));\n        setBackground(Color.white);\n        wordFractal = wordFractal(n);\n    }\n\n    public String wordFractal(int n) {\n        if (n < 2)\n            return n == 1 ? \"1\" : \"\";\n\n        \n        StringBuilder f1 = new StringBuilder(\"1\");\n        StringBuilder f2 = new StringBuilder(\"0\");\n\n        for (n = n - 2; n > 0; n--) {\n            String tmp = f2.toString();\n            f2.append(f1);\n\n            f1.setLength(0);\n            f1.append(tmp);\n        }\n\n        return f2.toString();\n    }\n\n    void drawWordFractal(Graphics2D g, int x, int y, int dx, int dy) {\n        for (int n = 0; n < wordFractal.length(); n++) {\n            g.drawLine(x, y, x + dx, y + dy);\n            x += dx;\n            y += dy;\n            if (wordFractal.charAt(n) == '0') {\n                int tx = dx;\n                dx = (n % 2 == 0) ? -dy : dy;\n                dy = (n % 2 == 0) ? tx : -tx;\n            }\n        }\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawWordFractal(g, 20, 20, 1, 0);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Fibonacci Word Fractal\");\n            f.setResizable(false);\n            f.add(new FibonacciWordFractal(23), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}", "gold": "#include <stdio.h>\n\nint main(void)\n{\n\tputs(\t\"%!PS-Adobe-3.0 EPSF\\n\"\n\t\t\"%%BoundingBox: -10 -10 400 565\\n\"\n\t\t\"/a{0 0 moveto 0 .4 translate 0 0 lineto stroke -1 1 scale}def\\n\"\n\t\t\"/b{a 90 rotate}def\");\n\n\tchar i;\n\tfor (i = 'c'; i <= 'z'; i++)\n\t\tprintf(\"/%c{%c %c}def\\n\", i, i-1, i-2);\n\n\tputs(\"0 setlinewidth z showpage\\n%%EOF\");\n\n\treturn 0;\n}", "llm": "magic-7b", "output": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <SDL.h>\n\ntypedef struct {\n    int x, y, dx, dy;\n    char *wordFractal;\n} FibonacciWordFractal;\n\nFibonacciWordFractal* FibonacciWordFractal_new(int n) {\n    FibonacciWordFractal* fwf = malloc(sizeof(FibonacciWordFractal));\n    fwf->wordFractal = wordFractal(n);\n    fwf->x = 20;\n    fwf->y = 20;\n    fwf->dx = 1;\n    fwf->dy = 0;\n    return fwf;\n}\n\nchar* wordFractal(int n) {\n    if (n < 2)\n        return n == 1 ? \"1\" : \"\";\n\n    char* f1 = \"1\";\n    char* f2 = \"0\";\n\n    for (n = n - 2; n > 0; n--) {\n        char* tmp = f2;\n        f2 = (char*)malloc(strlen(f1) + strlen(f2) + 1);\n        strcpy(f2, tmp);\n        strcat(f2, f1);\n\n        free(f1);\n        f1 = tmp;\n    }\n\n    return f2;\n}\n\nvoid drawWordFractal(FibonacciWordFractal* fwf, SDL_Renderer* renderer) {\n    for (int n = 0; n < strlen(fwf->wordFractal); n++) {\n        SDL_RenderDrawLine(renderer, fwf->x, fwf->y, fwf->x + fwf->dx, fwf->y + fwf->dy);\n        fwf->x += fwf->dx;\n        fwf->y += fwf->dy;\n        if (fwf->wordFractal[n] == '0') {\n            int tx = fwf->dx;\n            fwf->dx = (n % 2 == 0) ? -fwf->dy : fwf->dy;\n            fwf->dy = (n % 2 == 0) ? tx : -tx;\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    SDL_Init(SDL_INIT_VIDEO);\n\n    SDL_Window* window = SDL_CreateWindow(\"Fibonacci Word Fractal\", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, 450, 620, 0);\n    SDL_Renderer* renderer = SDL_CreateRenderer(window, -1, 0);\n\n    FibonacciWordFractal* fwf = FibonacciWordFractal_new(23);\n\n    SDL_Event event;\n    while (1) {\n        SDL_WaitEvent(&event);\n        if (event.type == SDL_QUIT)\n            break;\n\n        SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);\n        SDL_RenderClear(renderer);\n\n        drawWordFractal(fwf, renderer);\n\n        SDL_RenderPresent(renderer);\n    }\n\n    SDL_DestroyRenderer(renderer);\n    SDL_DestroyWindow(window);\n    SDL_Quit();\n\n    return 0;\n}", "index": 109}
{"lang": "Java, C", "input": "import java.awt.*;\nimport javax.swing.*;\n\npublic class FibonacciWordFractal extends JPanel {\n    String wordFractal;\n\n    FibonacciWordFractal(int n) {\n        setPreferredSize(new Dimension(450, 620));\n        setBackground(Color.white);\n        wordFractal = wordFractal(n);\n    }\n\n    public String wordFractal(int n) {\n        if (n < 2)\n            return n == 1 ? \"1\" : \"\";\n\n        \n        StringBuilder f1 = new StringBuilder(\"1\");\n        StringBuilder f2 = new StringBuilder(\"0\");\n\n        for (n = n - 2; n > 0; n--) {\n            String tmp = f2.toString();\n            f2.append(f1);\n\n            f1.setLength(0);\n            f1.append(tmp);\n        }\n\n        return f2.toString();\n    }\n\n    void drawWordFractal(Graphics2D g, int x, int y, int dx, int dy) {\n        for (int n = 0; n < wordFractal.length(); n++) {\n            g.drawLine(x, y, x + dx, y + dy);\n            x += dx;\n            y += dy;\n            if (wordFractal.charAt(n) == '0') {\n                int tx = dx;\n                dx = (n % 2 == 0) ? -dy : dy;\n                dy = (n % 2 == 0) ? tx : -tx;\n            }\n        }\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawWordFractal(g, 20, 20, 1, 0);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Fibonacci Word Fractal\");\n            f.setResizable(false);\n            f.add(new FibonacciWordFractal(23), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}", "gold": "#include <stdio.h>\n\nint main(void)\n{\n\tputs(\t\"%!PS-Adobe-3.0 EPSF\\n\"\n\t\t\"%%BoundingBox: -10 -10 400 565\\n\"\n\t\t\"/a{0 0 moveto 0 .4 translate 0 0 lineto stroke -1 1 scale}def\\n\"\n\t\t\"/b{a 90 rotate}def\");\n\n\tchar i;\n\tfor (i = 'c'; i <= 'z'; i++)\n\t\tprintf(\"/%c{%c %c}def\\n\", i, i-1, i-2);\n\n\tputs(\"0 setlinewidth z showpage\\n%%EOF\");\n\n\treturn 0;\n}", "llm": "cg4-9b", "output": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <sys/mman.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#include <sys/uio.h>\n#include <sys/file.h>\n#include <sys/sendfile.h>\n#include <sys/syscall.h>\n#include <sys/utsname.h>\n#include <sys/prctl.h>\n#include <sys/ptrace.h>\n#include <sys/reg.h>\n#include <sys/sysctl.h>\n#include <sys/auxv.h>\n#include <sys/times.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/epoll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/timerfd.h>\n#include <sys/inotify.h>\n#include <sys/mount.h>\n#include <sys/umount.h>\n#include <sys/reboot.h>\n#include <sys/swap.h>\n#include <sys/vfs.h>\n#include <sys/utsname.h>\n#include <sys/sysinfo.h>\n#include <sys/sysmacros.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/ptrace.h>\n#include <sys/", "index": 110}
{"lang": "Java, C", "input": "import java.awt.Color;\nimport java.awt.Graphics;\nimport javax.swing.JFrame;\n\npublic class DrawAPixel extends JFrame{\n\tpublic DrawAPixel() {\n\t\tsuper(\"Red Pixel\");\n\t\tsetSize(320, 240);\n\t\tsetDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\t\tsetVisible(true);\n\t}\n\t@Override\n\tpublic void paint(Graphics g) {\n\t\tg.setColor(new Color(255, 0, 0));\n\t\tg.drawRect(100, 100, 1, 1);\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew DrawAPixel();\n\t}\n}", "gold": "#include<graphics.h>\n\nint main()\n{\n\tinitwindow(320,240,\"Red Pixel\");\n\t\n\tputpixel(100,100,RED);\n\t\n\tgetch();\n\t\n\treturn 0;\n}", "llm": "cl-7b", "output": "#include <awt.h>\n#include <graphics.h>\n#include <jframe.h>\n\nclass DrawAPixel extends JFrame {\n\tpublic DrawAPixel() {\n\t\tsuper(\"Red Pixel\");\n\t\tsetSize(320, 240);\n\t\tsetDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\t\tsetVisible(true);\n\t}\n\t@Override\n\tpublic void paint(Graphics g) {\n\t\tg.setColor(new Color(255, 0, 0));\n\t\tg.drawRect(100, 100, 1, 1);\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew DrawAPixel();\n\t}\n}", "index": 111}
{"lang": "Java, C", "input": "import java.awt.Color;\nimport java.awt.Graphics;\nimport javax.swing.JFrame;\n\npublic class DrawAPixel extends JFrame{\n\tpublic DrawAPixel() {\n\t\tsuper(\"Red Pixel\");\n\t\tsetSize(320, 240);\n\t\tsetDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\t\tsetVisible(true);\n\t}\n\t@Override\n\tpublic void paint(Graphics g) {\n\t\tg.setColor(new Color(255, 0, 0));\n\t\tg.drawRect(100, 100, 1, 1);\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew DrawAPixel();\n\t}\n}", "gold": "#include<graphics.h>\n\nint main()\n{\n\tinitwindow(320,240,\"Red Pixel\");\n\t\n\tputpixel(100,100,RED);\n\t\n\tgetch();\n\t\n\treturn 0;\n}", "llm": "cl-34b", "output": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#define WIDTH 320\n#define HEIGHT 240\n\nstruct Color {\n    int r, g, b;\n};\n\nstruct Graphics {\n    void (*setColor)(struct Graphics*, struct Color);\n    void (*drawRect)(struct Graphics*, int, int, int, int);\n};\n\nstruct JFrame {\n    char* title;\n    int width;\n    int height;\n    int defaultCloseOperation;\n    int visible;\n    struct Graphics* graphics;\n};\n\nvoid setColor(struct Graphics* g, struct Color c) {\n    g->r = c.r;\n    g->g = c.g;\n    g->b = c.b;\n}\n\nvoid drawRect(struct Graphics* g, int x, int y, int w, int h) {\n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            printf(\"%c\", '*');\n        }\n        printf(\"\\n\");\n    }\n}\n\nvoid paint(struct Graphics* g) {\n    g->setColor(g, (struct Color){255, 0, 0});\n    g->drawRect(g, 100, 100, 1, 1);\n}\n\nint main(int argc, char* argv[]) {\n    struct JFrame* frame = malloc(sizeof(struct JFrame));\n    frame->title = \"Red Pixel\";\n    frame->width = WIDTH;\n    frame->height = HEIGHT;\n    frame->defaultCloseOperation = 1;\n    frame->visible = 1;\n    frame->graphics = malloc(sizeof(struct Graphics));\n    frame->graphics->setColor = setColor;\n    frame->graphics->drawRect = drawRect;\n    paint(frame->graphics);\n    return 0;\n}", "index": 112}
{"lang": "Java, C", "input": "import java.awt.Color;\nimport java.awt.Graphics;\nimport javax.swing.JFrame;\n\npublic class DrawAPixel extends JFrame{\n\tpublic DrawAPixel() {\n\t\tsuper(\"Red Pixel\");\n\t\tsetSize(320, 240);\n\t\tsetDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\t\tsetVisible(true);\n\t}\n\t@Override\n\tpublic void paint(Graphics g) {\n\t\tg.setColor(new Color(255, 0, 0));\n\t\tg.drawRect(100, 100, 1, 1);\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew DrawAPixel();\n\t}\n}", "gold": "#include<graphics.h>\n\nint main()\n{\n\tinitwindow(320,240,\"Red Pixel\");\n\t\n\tputpixel(100,100,RED);\n\t\n\tgetch();\n\t\n\treturn 0;\n}", "llm": "dsc-1b", "output": "Sorry, but it's not possible to directly translate this Java code to C. Java is a high-level, object-oriented programming language that is used for building software applications, while C is a low-level, procedural programming language. They are fundamentally different. \n\nJava is a statically-typed, object-oriented language that is used for building large-scale applications, while C is a dynamically-typed, procedural language that is used for writing small programs.\n\nJava is a compiled language, which means that the code is compiled into machine code before it is run. This is a significant advantage, but it also means that the code is harder to debug and maintain, as errors can be difficult to find.\n\nC, on the other hand, is a compiled language, but it is also a dynamically-typed, procedural language. This means that the code is interpreted, which means that the code is run line by line, which can be easier to debug and maintain.\n\nSo, if you want to create a program that draws a pixel in red on a 320x240 window, you would need to use a language that is both compiled and interpreted, like C.", "index": 113}
{"lang": "Java, Python", "input": "import java.lang.reflect.Field;\n\npublic class ListFields {\n    public int examplePublicField = 42;\n    private boolean examplePrivateField = true;\n    \n    public static void main(String[] args) throws IllegalAccessException {\n        ListFields obj = new ListFields();\n        Class clazz = obj.getClass();\n\n        System.out.println(\"All public fields (including inherited):\");\n        for (Field f : clazz.getFields()) {\n            System.out.printf(\"%s\\t%s\\n\", f, f.get(obj));\n        }\n        System.out.println();\n        System.out.println(\"All declared fields (excluding inherited):\");\n        for (Field f : clazz.getDeclaredFields()) {\n            System.out.printf(\"%s\\t%s\\n\", f, f.get(obj));\n        }\n    }\n}", "gold": "class Parent(object):\n    __priv = 'private'\n    \n    def __init__(self, name):\n        self.name = name\n    \n    def __repr__(self):\n        return '%s(%s)' % (type(self).__name__, self.name)\n    \n    def doNothing(self):\n        pass\n\nimport re\n\nclass Child(Parent):\n    \n    __rePrivate = re.compile('^_(Child|Parent)__')\n    \n    __reBleh = re.compile('\\Wbleh$')\n    @property\n    def reBleh(self):\n        return self.__reBleh\n    \n    def __init__(self, name, *args):\n        super(Child, self).__init__(name)\n        self.args = args\n    \n    def __dir__(self):\n        myDir = filter(\n            \n            lambda p: not self.__rePrivate.match(p),\n            list(set( \\\n                sum([dir(base) for base in type(self).__bases__], []) \\\n                + type(self).__dict__.keys() \\\n                + self.__dict__.keys() \\\n            )))\n        return myDir + map(\n            \n            lambda p: p + '_bleh',\n            filter(\n                \n                lambda p: (p[:2] != '__' or p[-2:] != '__') and not callable(getattr(self, p)),\n                myDir))\n    \n    def __getattr__(self, name):\n        if name[-5:] == '_bleh':\n            \n            return str(getattr(self, name[:-5])) + ' bleh'\n        if hasattr(super(Child, chld), '__getattr__'):\n            return super(Child, self).__getattr__(name)\n        raise AttributeError(\"'%s' object has no attribute '%s'\" % (type(self).__name__, name))\n    \n    def __setattr__(self, name, value):\n        if name[-5:] == '_bleh':\n            \n            if not (hasattr(self, name[:-5]) and callable(getattr(self, name[:-5]))):\n                setattr(self, name[:-5], self.reBleh.sub('', value))\n        elif hasattr(super(Child, self), '__setattr__'):\n            super(Child, self).__setattr__(name, value)\n        elif hasattr(self, '__dict__'):\n            self.__dict__[name] = value\n    \n    def __repr__(self):\n        return '%s(%s, %s)' % (type(self).__name__, self.name, str(self.args).strip('[]()'))\n    \n    def doStuff(self):\n        return (1+1.0/1e6) ** 1e6\n\npar = Parent('par')\npar.parent = True\ndir(par)\n\ninspect.getmembers(par)\n\n\nchld = Child('chld', 0, 'I', 'two')\nchld.own = \"chld's own\"\ndir(chld)\n\ninspect.getmembers(chld)", "llm": "cl-13b", "output": "import inspect\n\nclass ListFields:\n    example_public_field = 42\n    _example_private_field = True\n\n    def __init__(self):\n        pass\n\n    def main(self):\n        obj = ListFields()\n        clazz = obj.__class__\n\n        print(\"All public fields (including inherited):\")\n        for f in clazz.get_fields():\n            print(f, f.get(obj))\n        print()\n        print(\"All declared fields (excluding inherited):\")\n        for f in clazz.get_declared_fields():\n            print(f, f.get(obj))", "index": 114}
{"lang": "Java, Python", "input": "import java.lang.reflect.Field;\n\npublic class ListFields {\n    public int examplePublicField = 42;\n    private boolean examplePrivateField = true;\n    \n    public static void main(String[] args) throws IllegalAccessException {\n        ListFields obj = new ListFields();\n        Class clazz = obj.getClass();\n\n        System.out.println(\"All public fields (including inherited):\");\n        for (Field f : clazz.getFields()) {\n            System.out.printf(\"%s\\t%s\\n\", f, f.get(obj));\n        }\n        System.out.println();\n        System.out.println(\"All declared fields (excluding inherited):\");\n        for (Field f : clazz.getDeclaredFields()) {\n            System.out.printf(\"%s\\t%s\\n\", f, f.get(obj));\n        }\n    }\n}", "gold": "class Parent(object):\n    __priv = 'private'\n    \n    def __init__(self, name):\n        self.name = name\n    \n    def __repr__(self):\n        return '%s(%s)' % (type(self).__name__, self.name)\n    \n    def doNothing(self):\n        pass\n\nimport re\n\nclass Child(Parent):\n    \n    __rePrivate = re.compile('^_(Child|Parent)__')\n    \n    __reBleh = re.compile('\\Wbleh$')\n    @property\n    def reBleh(self):\n        return self.__reBleh\n    \n    def __init__(self, name, *args):\n        super(Child, self).__init__(name)\n        self.args = args\n    \n    def __dir__(self):\n        myDir = filter(\n            \n            lambda p: not self.__rePrivate.match(p),\n            list(set( \\\n                sum([dir(base) for base in type(self).__bases__], []) \\\n                + type(self).__dict__.keys() \\\n                + self.__dict__.keys() \\\n            )))\n        return myDir + map(\n            \n            lambda p: p + '_bleh',\n            filter(\n                \n                lambda p: (p[:2] != '__' or p[-2:] != '__') and not callable(getattr(self, p)),\n                myDir))\n    \n    def __getattr__(self, name):\n        if name[-5:] == '_bleh':\n            \n            return str(getattr(self, name[:-5])) + ' bleh'\n        if hasattr(super(Child, chld), '__getattr__'):\n            return super(Child, self).__getattr__(name)\n        raise AttributeError(\"'%s' object has no attribute '%s'\" % (type(self).__name__, name))\n    \n    def __setattr__(self, name, value):\n        if name[-5:] == '_bleh':\n            \n            if not (hasattr(self, name[:-5]) and callable(getattr(self, name[:-5]))):\n                setattr(self, name[:-5], self.reBleh.sub('', value))\n        elif hasattr(super(Child, self), '__setattr__'):\n            super(Child, self).__setattr__(name, value)\n        elif hasattr(self, '__dict__'):\n            self.__dict__[name] = value\n    \n    def __repr__(self):\n        return '%s(%s, %s)' % (type(self).__name__, self.name, str(self.args).strip('[]()'))\n    \n    def doStuff(self):\n        return (1+1.0/1e6) ** 1e6\n\npar = Parent('par')\npar.parent = True\ndir(par)\n\ninspect.getmembers(par)\n\n\nchld = Child('chld', 0, 'I', 'two')\nchld.own = \"chld's own\"\ndir(chld)\n\ninspect.getmembers(chld)", "llm": "cl-34b", "output": "import inspect\n\nclass ListFields:\n    def __init__(self):\n        self.examplePublicField = 42\n        self._examplePrivateField = True\n\n    def main(self):\n        print(\"All public fields (including inherited):\")\n        for field in inspect.getmembers(self, inspect.isfunction):\n            print(f\"{field}\\t{getattr(self, field)}\")\n        print()\n        print(\"All declared fields (excluding inherited):\")\n        for field in inspect.getmembers(self, inspect.isfunction):\n            print(f\"{field}\\t{getattr(self, field)}\")", "index": 115}
{"lang": "Java, Python", "input": "import java.lang.reflect.Field;\n\npublic class ListFields {\n    public int examplePublicField = 42;\n    private boolean examplePrivateField = true;\n    \n    public static void main(String[] args) throws IllegalAccessException {\n        ListFields obj = new ListFields();\n        Class clazz = obj.getClass();\n\n        System.out.println(\"All public fields (including inherited):\");\n        for (Field f : clazz.getFields()) {\n            System.out.printf(\"%s\\t%s\\n\", f, f.get(obj));\n        }\n        System.out.println();\n        System.out.println(\"All declared fields (excluding inherited):\");\n        for (Field f : clazz.getDeclaredFields()) {\n            System.out.printf(\"%s\\t%s\\n\", f, f.get(obj));\n        }\n    }\n}", "gold": "class Parent(object):\n    __priv = 'private'\n    \n    def __init__(self, name):\n        self.name = name\n    \n    def __repr__(self):\n        return '%s(%s)' % (type(self).__name__, self.name)\n    \n    def doNothing(self):\n        pass\n\nimport re\n\nclass Child(Parent):\n    \n    __rePrivate = re.compile('^_(Child|Parent)__')\n    \n    __reBleh = re.compile('\\Wbleh$')\n    @property\n    def reBleh(self):\n        return self.__reBleh\n    \n    def __init__(self, name, *args):\n        super(Child, self).__init__(name)\n        self.args = args\n    \n    def __dir__(self):\n        myDir = filter(\n            \n            lambda p: not self.__rePrivate.match(p),\n            list(set( \\\n                sum([dir(base) for base in type(self).__bases__], []) \\\n                + type(self).__dict__.keys() \\\n                + self.__dict__.keys() \\\n            )))\n        return myDir + map(\n            \n            lambda p: p + '_bleh',\n            filter(\n                \n                lambda p: (p[:2] != '__' or p[-2:] != '__') and not callable(getattr(self, p)),\n                myDir))\n    \n    def __getattr__(self, name):\n        if name[-5:] == '_bleh':\n            \n            return str(getattr(self, name[:-5])) + ' bleh'\n        if hasattr(super(Child, chld), '__getattr__'):\n            return super(Child, self).__getattr__(name)\n        raise AttributeError(\"'%s' object has no attribute '%s'\" % (type(self).__name__, name))\n    \n    def __setattr__(self, name, value):\n        if name[-5:] == '_bleh':\n            \n            if not (hasattr(self, name[:-5]) and callable(getattr(self, name[:-5]))):\n                setattr(self, name[:-5], self.reBleh.sub('', value))\n        elif hasattr(super(Child, self), '__setattr__'):\n            super(Child, self).__setattr__(name, value)\n        elif hasattr(self, '__dict__'):\n            self.__dict__[name] = value\n    \n    def __repr__(self):\n        return '%s(%s, %s)' % (type(self).__name__, self.name, str(self.args).strip('[]()'))\n    \n    def doStuff(self):\n        return (1+1.0/1e6) ** 1e6\n\npar = Parent('par')\npar.parent = True\ndir(par)\n\ninspect.getmembers(par)\n\n\nchld = Child('chld', 0, 'I', 'two')\nchld.own = \"chld's own\"\ndir(chld)\n\ninspect.getmembers(chld)", "llm": "cg4-9b", "output": "import inspect\n\nclass ListFields:\n    example_public_field = 42\n    __example_private_field = True\n\n    def __str__(self):\n        return f'example_public_field: {self.example_public_field}, __example_private_field: {self.__example_private_field}'\n\n    @staticmethod\n    def main():\n        obj = ListFields()\n        for name, value in inspect.getmembers(obj, lambda a: not(inspect.isroutine(a))):\n            print(f'{name}: {value}')\n\nif __name__ == \"__main__\":\n    ListFields.main()", "index": 116}
{"lang": "Java, C++", "input": "import java.math.BigDecimal;\nimport java.math.MathContext;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class RamanujanConstant {\n\n    public static void main(String[] args) {\n        System.out.printf(\"Ramanujan's Constant to 100 digits = %s%n%n\", ramanujanConstant(163, 100));\n        System.out.printf(\"Heegner numbers yielding 'almost' integers:%n\");\n        List<Integer> heegnerNumbers = Arrays.asList(19, 43, 67, 163);\n        List<Integer> heegnerVals = Arrays.asList(96, 960, 5280, 640320);\n        for ( int i = 0 ; i < heegnerNumbers.size() ; i++ ) {\n            int heegnerNumber = heegnerNumbers.get(i);\n            int heegnerVal = heegnerVals.get(i);\n            BigDecimal integer = BigDecimal.valueOf(heegnerVal).pow(3).add(BigDecimal.valueOf(744));\n            BigDecimal compute = ramanujanConstant(heegnerNumber, 50);\n            System.out.printf(\"%3d\u00a0: %50s ~ %18s (diff ~ %s)%n\", heegnerNumber, compute, integer, integer.subtract(compute, new MathContext(30)).toPlainString());\n        }\n    }\n    \n    public static BigDecimal ramanujanConstant(int sqrt, int digits) {\n        \n        MathContext mc = new MathContext(digits + 5);  \n        return bigE(bigPi(mc).multiply(bigSquareRoot(BigDecimal.valueOf(sqrt), mc), mc), mc).round(new MathContext(digits));\n    }\n\n    \n    public static BigDecimal bigE(BigDecimal exponent, MathContext mc) {\n        BigDecimal e = BigDecimal.ONE;\n        BigDecimal ak = e;\n        int k = 0;\n        BigDecimal min = BigDecimal.ONE.divide(BigDecimal.TEN.pow(mc.getPrecision()));\n        while ( true ) {\n            k++;\n            ak = ak.multiply(exponent).divide(BigDecimal.valueOf(k), mc);\n            e = e.add(ak, mc);\n            if ( ak.compareTo(min) < 0 ) {\n                break;\n            }\n        }\n        return e;\n        \n    }\n    \n    \n    public static BigDecimal bigPi(MathContext mc) {\n        int k = 0;\n        BigDecimal ak = BigDecimal.ONE;\n        BigDecimal a = ak;\n        BigDecimal b = BigDecimal.ZERO;\n        BigDecimal c = BigDecimal.valueOf(640320);\n        BigDecimal c3 = c.pow(3);\n        double digitePerTerm = Math.log10(c.pow(3).divide(BigDecimal.valueOf(24), mc).doubleValue()) - Math.log10(72);\n        double digits = 0;\n        while ( digits < mc.getPrecision() ) {\n            k++;\n            digits += digitePerTerm;\n            BigDecimal top = BigDecimal.valueOf(-24).multiply(BigDecimal.valueOf(6*k-5)).multiply(BigDecimal.valueOf(2*k-1)).multiply(BigDecimal.valueOf(6*k-1));\n            BigDecimal term = top.divide(BigDecimal.valueOf(k*k*k).multiply(c3), mc);\n            ak = ak.multiply(term, mc);\n            a = a.add(ak, mc);\n            b = b.add(BigDecimal.valueOf(k).multiply(ak, mc), mc);\n        }\n        BigDecimal total = BigDecimal.valueOf(13591409).multiply(a, mc).add(BigDecimal.valueOf(545140134).multiply(b, mc), mc);\n        return BigDecimal.valueOf(426880).multiply(bigSquareRoot(BigDecimal.valueOf(10005), mc), mc).divide(total, mc);\n    }\n\n    \n    public static BigDecimal bigSquareRoot(BigDecimal squareDecimal, MathContext mc) {\n        \n        double sqrt = Math.sqrt(squareDecimal.doubleValue());\n        BigDecimal x0 = new BigDecimal(sqrt, mc);\n        BigDecimal two = BigDecimal.valueOf(2);\n        while ( true ) {\n            BigDecimal x1 = x0.subtract(x0.multiply(x0, mc).subtract(squareDecimal).divide(two.multiply(x0, mc), mc), mc);\n            String x1String = x1.toPlainString();\n            String x0String = x0.toPlainString();\n            if ( x1String.substring(0, x1String.length()-1).compareTo(x0String.substring(0, x0String.length()-1)) == 0 ) {\n                break;\n            }\n            x0 = x1;\n        }\n        return x0;\n    }\n    \n}", "gold": "#include <iomanip>\n#include <iostream>\n#include <boost/math/constants/constants.hpp>\n#include <boost/multiprecision/cpp_dec_float.hpp>\n\nusing big_float = boost::multiprecision::cpp_dec_float_100;\n\nbig_float f(unsigned int n) {\n    big_float pi(boost::math::constants::pi<big_float>());\n    return exp(sqrt(big_float(n)) * pi);\n}\n\nint main() {\n    std::cout << \"Ramanujan's constant using formula f(N) = exp(pi*sqrt(N)):\\n\"\n        << std::setprecision(80) << f(163) << '\\n';\n    std::cout << \"\\nResult with last four Heegner numbers:\\n\";\n    std::cout << std::setprecision(30);\n    for (unsigned int n : {19, 43, 67, 163}) {\n        auto x = f(n);\n        auto c = ceil(x);\n        auto pc = 100.0 * (x/c);\n        std::cout << \"f(\" << n << \") = \" << x << \" = \"\n            << pc << \"% of \" << c << '\\n';\n    }\n    return 0;\n}", "llm": "cl-13b", "output": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nBigDecimal ramanujanConstant(int sqrt, int digits) {\n    MathContext mc = new MathContext(digits + 5);\n    return bigE(bigPi(mc).multiply(bigSquareRoot(BigDecimal.valueOf(sqrt), mc), mc), mc).round(new MathContext(digits));\n}\n\nBigDecimal bigE(BigDecimal exponent, MathContext mc) {\n    BigDecimal e = BigDecimal.ONE;\n    BigDecimal ak = e;\n    int k = 0;\n    BigDecimal min = BigDecimal.ONE.divide(BigDecimal.TEN.pow(mc.getPrecision()));\n    while (true) {\n        k++;\n        ak = ak.multiply(exponent).divide(BigDecimal.valueOf(k), mc);\n        e = e.add(ak, mc);\n        if (ak.compareTo(min) < 0) {\n            break;\n        }\n    }\n    return e;\n}\n\nBigDecimal bigPi(MathContext mc) {\n    int k = 0;\n    BigDecimal ak = BigDecimal.ONE;\n    BigDecimal a = ak;\n    BigDecimal b = BigDecimal.ZERO;\n    BigDecimal c = BigDecimal.valueOf(640320);\n    BigDecimal c3 = c.pow(3);\n    double digitePerTerm = log10(c.pow(3).divide(BigDecimal.valueOf(24), mc).doubleValue()) - log10(72);\n    double digits = 0;\n    while (digits < mc.getPrecision()) {\n        k++;\n        digits += digitePerTerm;\n        BigDecimal top = BigDecimal.valueOf(-24).multiply(BigDecimal.valueOf(6*k-5)).multiply(BigDecimal.valueOf(2*k-1)).multiply(BigDecimal.valueOf(6*k-1));\n        BigDecimal term = top.divide(BigDecimal.valueOf(k*k*k).multiply(c3), mc);\n        ak = ak.multiply(term, mc);\n        a = a.add(ak, mc);\n        b = b.add(BigDecimal.valueOf(k).multiply(ak, mc), mc);\n    }\n    BigDecimal total = BigDecimal.valueOf(13591409).multiply(a, mc).add(BigDecimal.valueOf(545140134).multiply(b, mc), mc);\n    return BigDecimal.valueOf(426880).multiply(bigSquareRoot(BigDecimal.valueOf(10005), mc), mc).divide(total, mc);\n}\n\nBigDecimal bigSquareRoot(BigDecimal squareDecimal, MathContext mc) {\n    double sqrt = sqrt(squareDecimal.doubleValue());\n    BigDecimal x0 = new BigDecimal(sqrt, mc);\n    BigDecimal two = BigDecimal.valueOf(2);\n    while (true) {\n        BigDecimal x1 = x0.subtract(x0.multiply(x0, mc).subtract(squareDecimal).divide(two.multiply(x0, mc), mc), mc);\n        string x1String = x1.toPlainString();\n        string x0String = x0.toPlainString();\n        if (x1String.substr(0, x1String.length() - 1).compare(x0String.substr(0, x0String.length() - 1)) == 0) {\n            break;\n        }\n        x0 = x1;\n    }\n    return x0;\n}\n\nint main() {\n    cout << \"Ramanujan's Constant to 100 digits = \" << ramanujanConstant(163, 100) << endl;\n    cout << \"Heegner numbers yielding 'almost' integers:\" << endl;\n    vector<int> heegnerNumbers = {19, 43, 67, 163};\n    vector<int> heegnerVals = {96, 960, 5280, 640320};\n    for (int i = 0; i < heegnerNumbers.size(); i++) {\n        int heegnerNumber = heegnerNumbers[i];\n        int heegnerVal = heegnerVals[i];\n        BigDecimal integer = BigDecimal.valueOf(heegnerVal).pow(3).add(BigDecimal.valueOf(744));\n        BigDecimal compute = ramanujanConstant(heegnerNumber, 50);\n        cout << heegnerNumber << \" : \" << compute << \" ~ \" << integer << \" (diff ~ \" << integer.subtract(compute, new MathContext(30)).toPlainString() << \")\" << endl;\n    }\n    return 0;\n}", "index": 117}
{"lang": "Java, C++", "input": "import java.math.BigDecimal;\nimport java.math.MathContext;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class RamanujanConstant {\n\n    public static void main(String[] args) {\n        System.out.printf(\"Ramanujan's Constant to 100 digits = %s%n%n\", ramanujanConstant(163, 100));\n        System.out.printf(\"Heegner numbers yielding 'almost' integers:%n\");\n        List<Integer> heegnerNumbers = Arrays.asList(19, 43, 67, 163);\n        List<Integer> heegnerVals = Arrays.asList(96, 960, 5280, 640320);\n        for ( int i = 0 ; i < heegnerNumbers.size() ; i++ ) {\n            int heegnerNumber = heegnerNumbers.get(i);\n            int heegnerVal = heegnerVals.get(i);\n            BigDecimal integer = BigDecimal.valueOf(heegnerVal).pow(3).add(BigDecimal.valueOf(744));\n            BigDecimal compute = ramanujanConstant(heegnerNumber, 50);\n            System.out.printf(\"%3d\u00a0: %50s ~ %18s (diff ~ %s)%n\", heegnerNumber, compute, integer, integer.subtract(compute, new MathContext(30)).toPlainString());\n        }\n    }\n    \n    public static BigDecimal ramanujanConstant(int sqrt, int digits) {\n        \n        MathContext mc = new MathContext(digits + 5);  \n        return bigE(bigPi(mc).multiply(bigSquareRoot(BigDecimal.valueOf(sqrt), mc), mc), mc).round(new MathContext(digits));\n    }\n\n    \n    public static BigDecimal bigE(BigDecimal exponent, MathContext mc) {\n        BigDecimal e = BigDecimal.ONE;\n        BigDecimal ak = e;\n        int k = 0;\n        BigDecimal min = BigDecimal.ONE.divide(BigDecimal.TEN.pow(mc.getPrecision()));\n        while ( true ) {\n            k++;\n            ak = ak.multiply(exponent).divide(BigDecimal.valueOf(k), mc);\n            e = e.add(ak, mc);\n            if ( ak.compareTo(min) < 0 ) {\n                break;\n            }\n        }\n        return e;\n        \n    }\n    \n    \n    public static BigDecimal bigPi(MathContext mc) {\n        int k = 0;\n        BigDecimal ak = BigDecimal.ONE;\n        BigDecimal a = ak;\n        BigDecimal b = BigDecimal.ZERO;\n        BigDecimal c = BigDecimal.valueOf(640320);\n        BigDecimal c3 = c.pow(3);\n        double digitePerTerm = Math.log10(c.pow(3).divide(BigDecimal.valueOf(24), mc).doubleValue()) - Math.log10(72);\n        double digits = 0;\n        while ( digits < mc.getPrecision() ) {\n            k++;\n            digits += digitePerTerm;\n            BigDecimal top = BigDecimal.valueOf(-24).multiply(BigDecimal.valueOf(6*k-5)).multiply(BigDecimal.valueOf(2*k-1)).multiply(BigDecimal.valueOf(6*k-1));\n            BigDecimal term = top.divide(BigDecimal.valueOf(k*k*k).multiply(c3), mc);\n            ak = ak.multiply(term, mc);\n            a = a.add(ak, mc);\n            b = b.add(BigDecimal.valueOf(k).multiply(ak, mc), mc);\n        }\n        BigDecimal total = BigDecimal.valueOf(13591409).multiply(a, mc).add(BigDecimal.valueOf(545140134).multiply(b, mc), mc);\n        return BigDecimal.valueOf(426880).multiply(bigSquareRoot(BigDecimal.valueOf(10005), mc), mc).divide(total, mc);\n    }\n\n    \n    public static BigDecimal bigSquareRoot(BigDecimal squareDecimal, MathContext mc) {\n        \n        double sqrt = Math.sqrt(squareDecimal.doubleValue());\n        BigDecimal x0 = new BigDecimal(sqrt, mc);\n        BigDecimal two = BigDecimal.valueOf(2);\n        while ( true ) {\n            BigDecimal x1 = x0.subtract(x0.multiply(x0, mc).subtract(squareDecimal).divide(two.multiply(x0, mc), mc), mc);\n            String x1String = x1.toPlainString();\n            String x0String = x0.toPlainString();\n            if ( x1String.substring(0, x1String.length()-1).compareTo(x0String.substring(0, x0String.length()-1)) == 0 ) {\n                break;\n            }\n            x0 = x1;\n        }\n        return x0;\n    }\n    \n}", "gold": "#include <iomanip>\n#include <iostream>\n#include <boost/math/constants/constants.hpp>\n#include <boost/multiprecision/cpp_dec_float.hpp>\n\nusing big_float = boost::multiprecision::cpp_dec_float_100;\n\nbig_float f(unsigned int n) {\n    big_float pi(boost::math::constants::pi<big_float>());\n    return exp(sqrt(big_float(n)) * pi);\n}\n\nint main() {\n    std::cout << \"Ramanujan's constant using formula f(N) = exp(pi*sqrt(N)):\\n\"\n        << std::setprecision(80) << f(163) << '\\n';\n    std::cout << \"\\nResult with last four Heegner numbers:\\n\";\n    std::cout << std::setprecision(30);\n    for (unsigned int n : {19, 43, 67, 163}) {\n        auto x = f(n);\n        auto c = ceil(x);\n        auto pc = 100.0 * (x/c);\n        std::cout << \"f(\" << n << \") = \" << x << \" = \"\n            << pc << \"% of \" << c << '\\n';\n    }\n    return 0;\n}", "llm": "dsc-7b", "output": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <iomanip>\n#include <boost/multiprecision/cpp_dec_float.hpp>\n\nusing namespace boost::multiprecision;\n\ncpp_dec_float_50 ramanujanConstant(int sqrt, int digits) {\n    cpp_dec_float_50 mc = std::pow(10, digits + 5);  \n    return bigE(bigPi(mc) * bigSquareRoot(cpp_dec_float_50(sqrt), mc), mc);\n}\n\ncpp_dec_float_50 bigE(cpp_dec_float_50 exponent, cpp_dec_float_50 mc) {\n    cpp_dec_float_50 e = 1;\n    cpp_dec_float_50 ak = e;\n    int k = 0;\n    cpp_dec_float_50 min = std::pow(10, -mc.precision());\n    while ( true ) {\n        k++;\n        ak = ak * exponent / k;\n        e = e + ak;\n        if ( ak < min ) {\n            break;\n        }\n    }\n    return e;\n}\n\ncpp_dec_float_50 bigPi(cpp_dec_float_50 mc) {\n    int k = 0;\n    cpp_dec_float_50 ak = 1;\n    cpp_dec_float_50 a = 0;\n    cpp_dec_float_50 b = 0;\n    cpp_dec_float_50 c = 640320;\n    cpp_dec_float_50 c3 = std::pow(c, 3);\n    double digitePerTerm = std::log10(c3 / 24) - std::log10(72);\n    double digits = 0;\n    while ( digits < mc.precision() ) {\n        k++;\n        digits += digitePerTerm;\n        cpp_dec_float_50 top = -24 * (6*k-5) * (2*k-1) * (6*k-1);\n        cpp_dec_float_50 term = top / (std::pow(k, 3) * c3);\n        ak = ak * term;\n        a = a + ak;\n        b = b + k * ak;\n    }\n    cpp_dec_float_50 total = 13591409 * a + 545140134 * b;\n    return 426880 * bigSquareRoot(cpp_dec_float_50(10005), mc) / total;\n}\n\ncpp_dec_float_50 bigSquareRoot(cpp_dec_float_50 squareDecimal, cpp_dec_float_50 mc) {\n    double sqrt = std::sqrt(squareDecimal.convert_to<double>());\n    cpp_dec_float_50 x0 = sqrt;\n    cpp_dec_float_50 two = 2;\n    while ( true ) {\n        cpp_dec_float_50 x1 = x0 - (x0 * x0 - squareDecimal) / (two * x0);\n        if ( x1.str().substr(0, x1.str().length()-1) == x0.str().substr(0, x0.str().length()-1) ) {\n            break;\n        }\n        x0 = x1;\n    }\n    return x0;\n}\n\nint main() {\n    std::cout << std::fixed << std::setprecision(100) << ramanujanConstant(163, 100) << std::endl;\n    std::vector<int> heegnerNumbers = {19, 43, 67, 163};\n    std::vector<int> heegnerVals = {96, 960, 5280, 640320};\n    for ( int i = 0 ; i < heegnerNumbers.size() ; i++ ) {\n        int heegnerNumber = heegnerNumbers[i];\n        int heegnerVal = heegnerVals[i];\n        cpp_dec_float_50 integer = std::pow(cpp_dec_float_50(heegnerVal), 3) + 744;\n        cpp_dec_float_50 compute = ramanujanConstant(heegnerNumber, 50);\n        std::cout << heegnerNumber << \" : \" << compute << \" ~ \" << integer << \" (diff ~ \" << integer - compute << \")\" << std::endl;\n    }\n    return 0;\n}", "index": 118}
{"lang": "Java, C++", "input": "import java.math.BigDecimal;\nimport java.math.MathContext;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class RamanujanConstant {\n\n    public static void main(String[] args) {\n        System.out.printf(\"Ramanujan's Constant to 100 digits = %s%n%n\", ramanujanConstant(163, 100));\n        System.out.printf(\"Heegner numbers yielding 'almost' integers:%n\");\n        List<Integer> heegnerNumbers = Arrays.asList(19, 43, 67, 163);\n        List<Integer> heegnerVals = Arrays.asList(96, 960, 5280, 640320);\n        for ( int i = 0 ; i < heegnerNumbers.size() ; i++ ) {\n            int heegnerNumber = heegnerNumbers.get(i);\n            int heegnerVal = heegnerVals.get(i);\n            BigDecimal integer = BigDecimal.valueOf(heegnerVal).pow(3).add(BigDecimal.valueOf(744));\n            BigDecimal compute = ramanujanConstant(heegnerNumber, 50);\n            System.out.printf(\"%3d\u00a0: %50s ~ %18s (diff ~ %s)%n\", heegnerNumber, compute, integer, integer.subtract(compute, new MathContext(30)).toPlainString());\n        }\n    }\n    \n    public static BigDecimal ramanujanConstant(int sqrt, int digits) {\n        \n        MathContext mc = new MathContext(digits + 5);  \n        return bigE(bigPi(mc).multiply(bigSquareRoot(BigDecimal.valueOf(sqrt), mc), mc), mc).round(new MathContext(digits));\n    }\n\n    \n    public static BigDecimal bigE(BigDecimal exponent, MathContext mc) {\n        BigDecimal e = BigDecimal.ONE;\n        BigDecimal ak = e;\n        int k = 0;\n        BigDecimal min = BigDecimal.ONE.divide(BigDecimal.TEN.pow(mc.getPrecision()));\n        while ( true ) {\n            k++;\n            ak = ak.multiply(exponent).divide(BigDecimal.valueOf(k), mc);\n            e = e.add(ak, mc);\n            if ( ak.compareTo(min) < 0 ) {\n                break;\n            }\n        }\n        return e;\n        \n    }\n    \n    \n    public static BigDecimal bigPi(MathContext mc) {\n        int k = 0;\n        BigDecimal ak = BigDecimal.ONE;\n        BigDecimal a = ak;\n        BigDecimal b = BigDecimal.ZERO;\n        BigDecimal c = BigDecimal.valueOf(640320);\n        BigDecimal c3 = c.pow(3);\n        double digitePerTerm = Math.log10(c.pow(3).divide(BigDecimal.valueOf(24), mc).doubleValue()) - Math.log10(72);\n        double digits = 0;\n        while ( digits < mc.getPrecision() ) {\n            k++;\n            digits += digitePerTerm;\n            BigDecimal top = BigDecimal.valueOf(-24).multiply(BigDecimal.valueOf(6*k-5)).multiply(BigDecimal.valueOf(2*k-1)).multiply(BigDecimal.valueOf(6*k-1));\n            BigDecimal term = top.divide(BigDecimal.valueOf(k*k*k).multiply(c3), mc);\n            ak = ak.multiply(term, mc);\n            a = a.add(ak, mc);\n            b = b.add(BigDecimal.valueOf(k).multiply(ak, mc), mc);\n        }\n        BigDecimal total = BigDecimal.valueOf(13591409).multiply(a, mc).add(BigDecimal.valueOf(545140134).multiply(b, mc), mc);\n        return BigDecimal.valueOf(426880).multiply(bigSquareRoot(BigDecimal.valueOf(10005), mc), mc).divide(total, mc);\n    }\n\n    \n    public static BigDecimal bigSquareRoot(BigDecimal squareDecimal, MathContext mc) {\n        \n        double sqrt = Math.sqrt(squareDecimal.doubleValue());\n        BigDecimal x0 = new BigDecimal(sqrt, mc);\n        BigDecimal two = BigDecimal.valueOf(2);\n        while ( true ) {\n            BigDecimal x1 = x0.subtract(x0.multiply(x0, mc).subtract(squareDecimal).divide(two.multiply(x0, mc), mc), mc);\n            String x1String = x1.toPlainString();\n            String x0String = x0.toPlainString();\n            if ( x1String.substring(0, x1String.length()-1).compareTo(x0String.substring(0, x0String.length()-1)) == 0 ) {\n                break;\n            }\n            x0 = x1;\n        }\n        return x0;\n    }\n    \n}", "gold": "#include <iomanip>\n#include <iostream>\n#include <boost/math/constants/constants.hpp>\n#include <boost/multiprecision/cpp_dec_float.hpp>\n\nusing big_float = boost::multiprecision::cpp_dec_float_100;\n\nbig_float f(unsigned int n) {\n    big_float pi(boost::math::constants::pi<big_float>());\n    return exp(sqrt(big_float(n)) * pi);\n}\n\nint main() {\n    std::cout << \"Ramanujan's constant using formula f(N) = exp(pi*sqrt(N)):\\n\"\n        << std::setprecision(80) << f(163) << '\\n';\n    std::cout << \"\\nResult with last four Heegner numbers:\\n\";\n    std::cout << std::setprecision(30);\n    for (unsigned int n : {19, 43, 67, 163}) {\n        auto x = f(n);\n        auto c = ceil(x);\n        auto pc = 100.0 * (x/c);\n        std::cout << \"f(\" << n << \") = \" << x << \" = \"\n            << pc << \"% of \" << c << '\\n';\n    }\n    return 0;\n}", "llm": "cg4-9b", "output": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <stdexcept>\n#include <iomanip>\n#include <boost/multiprecision/cpp_dec_float.hpp>\n\nusing namespace std;\nusing namespace boost::multiprecision;\n\ncpp_dec_float_100 ramanujanConstant(int sqrt, int digits) {\n    \n    cpp_dec_float_100 e = 1;\n    cpp_dec_float_100 ak = e;\n    int k = 0;\n    cpp_dec_float_100 min = 1 / pow(10, digits);\n    while ( true ) {\n        k++;\n        ak = ak * sqrt / k;\n        e = e + ak;\n        if ( ak < min ) {\n            break;\n        }\n    }\n    return e;\n}\n\ncpp_dec_float_100 bigE(cpp_dec_float_100 exponent, int digits) {\n    cpp_dec_float_100 e = 1;\n    cpp_dec_float_100 ak = e;\n    int k = 0;\n    cpp_dec_float_100 min = 1 / pow(10, digits);\n    while ( true ) {\n        k++;\n        ak = ak * exponent / k;\n        e = e + ak;\n        if ( ak < min ) {\n            break;\n        }\n    }\n    return e;\n}\n\ncpp_dec_float_100 bigPi(int digits) {\n    int k = 0;\n    cpp_dec_float_100 ak = 1;\n    cpp_dec_float_100 a = ak;\n    cpp_dec_float_100 b = 0;\n    cpp_dec_float_100 c = 640320;\n    cpp_dec_float_100 c3 = c * c * c;\n    double digitePerTerm = log10(c3 / 24) - log10(72);\n    double digits = 0;\n    while ( digits < digits ) {\n        k++;\n        digits += digitePerTerm;\n        cpp_dec_float_100 top = -24 * (6*k-5) * (2*k-1) * (6*k-1);\n        cpp_dec_float_100 term = top / (k*k*k * c3);\n        ak = ak * term;\n        a = a + ak;\n        b = b + k * ak;\n    }\n    cpp_dec_float_100 total = 13591409 * a + 545140134 * b;\n    return 426880 * bigSquareRoot(10005, digits) / total;\n}\n\ncpp_dec_float_100 bigSquareRoot(cpp_dec_float_100 squareDecimal, int digits) {\n    \n    double sqrt = sqrt(squareDecimal.convert_to<double>());\n    cpp_dec_float_100 x0 = sqrt;\n    cpp_dec_float_100 two = 2;\n    while ( true ) {\n        cpp_dec_float_100 x1 = x0 - (x0 * x0 - squareDecimal) / (two * x0);\n        string x1String = to_string(x1);\n        string x0String = to_string(x0);\n        if ( x1String.substr(0, x1String.length()-1) == x0String.substr(0, x0String.length()-1) ) {\n            break;\n        }\n        x0 = x1;\n    }\n    return x0;\n}\n\nint main() {\n    cout << fixed << setprecision(100) << ramanujanConstant(163, 100) << endl;\n    vector<int> heegnerNumbers = {19, 43, 67, 163};\n    vector<int> heegnerVals = {96, 960, 5280, 640320};\n    for ( int i = 0 ; i < heegnerNumbers.size() ; i++ ) {\n        int heegnerNumber = heegnerNumbers[i];\n        int heegnerVal = heegnerVals[i];\n        cpp_dec_float_100 integer = pow(heegnerVal, 3) + 744;\n        cpp_dec_float_100 compute = ramanujanConstant(heegnerNumber, 50);\n        cout << heegnerNumber << \" : \" << setw(50) << compute << \" ~ \" << setw(18) << integer << \" (diff ~ \" << integer - compute << \")\" << endl;\n    }\n    return 0;\n}", "index": 119}
{"lang": "Java, C++", "input": "import java.util.Arrays;\n\npublic class SpecialVariables {\n\n    public static void main(String[] args) {\n\n        \n        \n        System.out.println(Arrays.toString(args));\n\n        \n        \n        System.out.println(SpecialVariables.class);\n\n\n        \n\n        \n        System.out.println(System.getenv());\n\n        \n        \n        System.out.println(System.getProperties());\n\n        \n        \n        System.out.println(Runtime.getRuntime().availableProcessors());\n\n    }\n}", "gold": "#include <iostream>\n\nstruct SpecialVariables\n{\n    int i = 0;\n\n    SpecialVariables& operator++()\n    {\n        \n        \n        \n        this->i++;  \n\n        \n        return *this;\n    }\n\n};\n\nint main()\n{\n    SpecialVariables sv;\n    auto sv2 = ++sv;     \n    std::cout << \" sv\u00a0:\" << sv.i << \"\\n sv2:\" << sv2.i << \"\\n\";\n}", "llm": "cl-13b", "output": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    vector<string> args(argv, argv + argc);\n    cout << args << endl;\n\n    cout << SpecialVariables::class << endl;\n\n    cout << getenv() << endl;\n\n    cout << getProperties() << endl;\n\n    cout << Runtime::getRuntime().availableProcessors() << endl;\n\n    return 0;\n}", "index": 120}
{"lang": "Java, C++", "input": "import java.util.Arrays;\n\npublic class SpecialVariables {\n\n    public static void main(String[] args) {\n\n        \n        \n        System.out.println(Arrays.toString(args));\n\n        \n        \n        System.out.println(SpecialVariables.class);\n\n\n        \n\n        \n        System.out.println(System.getenv());\n\n        \n        \n        System.out.println(System.getProperties());\n\n        \n        \n        System.out.println(Runtime.getRuntime().availableProcessors());\n\n    }\n}", "gold": "#include <iostream>\n\nstruct SpecialVariables\n{\n    int i = 0;\n\n    SpecialVariables& operator++()\n    {\n        \n        \n        \n        this->i++;  \n\n        \n        return *this;\n    }\n\n};\n\nint main()\n{\n    SpecialVariables sv;\n    auto sv2 = ++sv;     \n    std::cout << \" sv\u00a0:\" << sv.i << \"\\n sv2:\" << sv2.i << \"\\n\";\n}", "llm": "dsc-33b", "output": "#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <map>\n#include <cstdio>\n\nint main(int argc, char** argv) {\n    std::vector<std::string> args(argv, argv + argc);\n    for(auto& arg : args) {\n        std::cout << arg << \" \";\n    }\n    std::cout << std::endl;\n\n    std::cout << \"SpecialVariables\" << std::endl;\n\n    std::map<std::string, std::string> env;\n    char* env_var = *environ;\n    while(env_var) {\n        std::string str = std::string(env_var);\n        int pos = str.find(\"=\");\n        env[str.substr(0, pos)] = str.substr(pos + 1);\n        env_var = *(environ+1);\n    }\n    for(auto& var : env) {\n        std::cout << var.first << \"=\" << var.second << \" \";\n    }\n    std::cout << std::endl;\n\n    std::cout << \"Runtime.getRuntime().availableProcessors()\" << std::endl;\n\n    return 0;\n}", "index": 121}
{"lang": "Java, C++", "input": "import java.util.Arrays;\n\npublic class SpecialVariables {\n\n    public static void main(String[] args) {\n\n        \n        \n        System.out.println(Arrays.toString(args));\n\n        \n        \n        System.out.println(SpecialVariables.class);\n\n\n        \n\n        \n        System.out.println(System.getenv());\n\n        \n        \n        System.out.println(System.getProperties());\n\n        \n        \n        System.out.println(Runtime.getRuntime().availableProcessors());\n\n    }\n}", "gold": "#include <iostream>\n\nstruct SpecialVariables\n{\n    int i = 0;\n\n    SpecialVariables& operator++()\n    {\n        \n        \n        \n        this->i++;  \n\n        \n        return *this;\n    }\n\n};\n\nint main()\n{\n    SpecialVariables sv;\n    auto sv2 = ++sv;     \n    std::cout << \" sv\u00a0:\" << sv.i << \"\\n sv2:\" << sv2.i << \"\\n\";\n}", "llm": "q2.5-7b", "output": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstdlib>\n#include <map>\n#include <thread>\n\nint main(int argc, char* argv[]) {\n\n    std::vector<std::string> args(argv, argv + argc);\n    for (const auto& arg : args) {\n        std::cout << arg << \" \";\n    }\n    std::cout << std::endl;\n\n    std::cout << \"SpecialVariables\" << std::endl;\n\n    std::map<std::string, std::string> env = std::getenv();\n    for (const auto& envVar : env) {\n        std::cout << envVar.first << \"=\" << envVar.second << std::endl;\n    }\n\n    std::map<std::string, std::string> properties = std::get_properties();\n    for (const auto& property : properties) {\n        std::cout << property.first << \"=\" << property.second << std::endl;\n    }\n\n    std::cout << std::thread::hardware_concurrency() << std::endl;\n\n    return 0;\n}", "index": 122}
{"lang": "Java, C++", "input": "import java.util.Comparator;\nimport java.util.Arrays;\n\npublic class Test {\n  public static void main(String[] args) {\n    String[] strings = {\"Here\", \"are\", \"some\", \"sample\", \"strings\", \"to\", \"be\", \"sorted\"};\n\n    Arrays.sort(strings, new Comparator<String>() {\n      public int compare(String s1, String s2) {\n        int c = s2.length() - s1.length();\n        if (c == 0)\n          c = s1.compareToIgnoreCase(s2);\n        return c;\n      }\n    });\n\n    for (String s: strings)\n      System.out.print(s + \" \");\n  }\n}", "gold": "#include <algorithm>\n#include <string>\n#include <cctype>\n\n\nstruct icompare_char {\n  bool operator()(char c1, char c2) {\n    return std::toupper(c1) < std::toupper(c2);\n  }\n};\n\n\nstruct compare {\n  bool operator()(std::string const& s1, std::string const& s2) {\n    if (s1.length() > s2.length())\n      return true;\n    if (s1.length() < s2.length())\n      return false;\n    return std::lexicographical_compare(s1.begin(), s1.end(),\n                                        s2.begin(), s2.end(),\n                                        icompare_char());\n  }\n};\n\nint main() {\n  std::string strings[8] = {\"Here\", \"are\", \"some\", \"sample\", \"strings\", \"to\", \"be\", \"sorted\"};\n  std::sort(strings, strings+8, compare());\n  return 0;\n}", "llm": "cl-13b", "output": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    string strings[] = {\"Here\", \"are\", \"some\", \"sample\", \"strings\", \"to\", \"be\", \"sorted\"};\n\n    sort(strings, strings + sizeof(strings) / sizeof(string), [](string s1, string s2) {\n        int c = s2.length() - s1.length();\n        if (c == 0)\n            c = s1.compare(s2);\n        return c;\n    });\n\n    for (string s: strings)\n        cout << s << \" \";\n\n    return 0;\n}", "index": 123}
{"lang": "Java, C++", "input": "import java.util.Comparator;\nimport java.util.Arrays;\n\npublic class Test {\n  public static void main(String[] args) {\n    String[] strings = {\"Here\", \"are\", \"some\", \"sample\", \"strings\", \"to\", \"be\", \"sorted\"};\n\n    Arrays.sort(strings, new Comparator<String>() {\n      public int compare(String s1, String s2) {\n        int c = s2.length() - s1.length();\n        if (c == 0)\n          c = s1.compareToIgnoreCase(s2);\n        return c;\n      }\n    });\n\n    for (String s: strings)\n      System.out.print(s + \" \");\n  }\n}", "gold": "#include <algorithm>\n#include <string>\n#include <cctype>\n\n\nstruct icompare_char {\n  bool operator()(char c1, char c2) {\n    return std::toupper(c1) < std::toupper(c2);\n  }\n};\n\n\nstruct compare {\n  bool operator()(std::string const& s1, std::string const& s2) {\n    if (s1.length() > s2.length())\n      return true;\n    if (s1.length() < s2.length())\n      return false;\n    return std::lexicographical_compare(s1.begin(), s1.end(),\n                                        s2.begin(), s2.end(),\n                                        icompare_char());\n  }\n};\n\nint main() {\n  std::string strings[8] = {\"Here\", \"are\", \"some\", \"sample\", \"strings\", \"to\", \"be\", \"sorted\"};\n  std::sort(strings, strings+8, compare());\n  return 0;\n}", "llm": "dsc-33b", "output": "#include <algorithm>\n#include <iostream>\n#include <string>\n#include <vector>\n\nstruct StringComparator {\n  bool operator()(const std::string& s1, const std::string& s2) {\n    int c = s2.length() - s1.length();\n    if (c == 0)\n      c = s1.compare(0, std::min(s1.length(), s2.length()), s2, 0, std::min(s1.length(), s2.length()));\n    return c < 0;\n  }\n};\n\nint main() {\n  std::vector<std::string> strings = {\"Here\", \"are\", \"some\", \"sample\", \"strings\", \"to\", \"be\", \"sorted\"};\n\n  std::sort(strings.begin(), strings.end(), StringComparator());\n\n  for (const auto& s : strings)\n    std::cout << s << \" \";\n\n  return 0;\n}", "index": 124}
{"lang": "Java, C++", "input": "import java.util.Comparator;\nimport java.util.Arrays;\n\npublic class Test {\n  public static void main(String[] args) {\n    String[] strings = {\"Here\", \"are\", \"some\", \"sample\", \"strings\", \"to\", \"be\", \"sorted\"};\n\n    Arrays.sort(strings, new Comparator<String>() {\n      public int compare(String s1, String s2) {\n        int c = s2.length() - s1.length();\n        if (c == 0)\n          c = s1.compareToIgnoreCase(s2);\n        return c;\n      }\n    });\n\n    for (String s: strings)\n      System.out.print(s + \" \");\n  }\n}", "gold": "#include <algorithm>\n#include <string>\n#include <cctype>\n\n\nstruct icompare_char {\n  bool operator()(char c1, char c2) {\n    return std::toupper(c1) < std::toupper(c2);\n  }\n};\n\n\nstruct compare {\n  bool operator()(std::string const& s1, std::string const& s2) {\n    if (s1.length() > s2.length())\n      return true;\n    if (s1.length() < s2.length())\n      return false;\n    return std::lexicographical_compare(s1.begin(), s1.end(),\n                                        s2.begin(), s2.end(),\n                                        icompare_char());\n  }\n};\n\nint main() {\n  std::string strings[8] = {\"Here\", \"are\", \"some\", \"sample\", \"strings\", \"to\", \"be\", \"sorted\"};\n  std::sort(strings, strings+8, compare());\n  return 0;\n}", "llm": "cs-22b", "output": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cctype>\n\nint main() {\n    std::vector<std::string> strings = {\"Here\", \"are\", \"some\", \"sample\", \"strings\", \"to\", \"be\", \"sorted\"};\n\n    std::sort(strings.begin(), strings.end(), [](const std::string& s1, const std::string& s2) {\n        int c = s2.length() - s1.length();\n        if (c == 0) {\n            std::string s1_lower, s2_lower;\n            std::transform(s1.begin(), s1.end(), std::back_inserter(s1_lower), ::tolower);\n            std::transform(s2.begin(), s2.end(), std::back_inserter(s2_lower), ::tolower);\n            c = s1_lower.compare(s2_lower);\n        }\n        return c < 0;\n    });\n\n    for (const std::string& s : strings)\n        std::cout << s << \" \";\n\n    return 0;\n}", "index": 125}
{"lang": "Java, Python", "input": "import java.util.Random;\n\npublic class KMeansWithKpp{\n\t\t\n\t\tpublic Point[] points;\n\t\tpublic Point[] centroids;\n\t\tRandom rand;\n\t\tpublic int n;\n\t\tpublic int k;\n\n\t\t\n\t\tprivate KMeansWithKpp(){\n\t\t}\n\n\t\tKMeansWithKpp(Point[] p, int clusters){\n\t\t\t\tpoints = p;\n\t\t\t\tn = p.length;\n\t\t\t\tk = Math.max(1, clusters);\n\t\t\t\tcentroids = new Point[k];\n\t\t\t\trand = new Random();\n\t\t}\n\n\n\t\tprivate static double distance(Point a, Point b){\n\t\t\t\treturn (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n\t\t}\n\n\t\tprivate static int nearest(Point pt, Point[] others, int len){\n\t\t\t\tdouble minD = Double.MAX_VALUE;\n\t\t\t\tint index = pt.group;\n\t\t\t\tlen = Math.min(others.length, len);\n\t\t\t\tdouble dist;\n\t\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\t\t\tif (minD > (dist = distance(pt, others[i]))) {\n\t\t\t\t\t\t\t\tminD = dist;\n\t\t\t\t\t\t\t\tindex = i;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn index;\n\t\t}\n\n\t\tprivate static double nearestDistance(Point pt, Point[] others, int len){\n\t\t\t\tdouble minD = Double.MAX_VALUE;\n\t\t\t\tlen = Math.min(others.length, len);\n\t\t\t\tdouble dist;\n\t\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\t\t\tif (minD > (dist = distance(pt, others[i]))) {\n\t\t\t\t\t\t\t\tminD = dist;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn minD;\n\t\t}\n\n\t\tprivate void kpp(){\n\t\t\t\tcentroids[0] = points[rand.nextInt(n)];\n\t\t\t\tdouble[] dist = new double[n];\n\t\t\t\tdouble sum = 0;\n\t\t\t\tfor (int i = 1; i < k; i++) {\n\t\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\t\t\tdist[j] = nearestDistance(points[j], centroids, i);\n\t\t\t\t\t\t\t\tsum += dist[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsum = (sum * rand.nextInt(Integer.MAX_VALUE)) / Integer.MAX_VALUE;\n\t\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\t\t\tif ((sum -= dist[j]) > 0)\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tcentroids[i].x = points[j].x;\n\t\t\t\t\t\t\t\tcentroids[i].y = points[j].y;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\tpoints[i].group = nearest(points[i], centroids, k);\n\t\t\t\t}\n\t\t}\n\n\t\tpublic void kMeans(int maxTimes){\n\t\t\t\tif (k == 1 || n <= 0) {\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(k >= n){\n\t\t\t\t\t\tfor(int i =0; i < n; i++){\n\t\t\t\t\t\t\t\tpoints[i].group = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tmaxTimes = Math.max(1, maxTimes);\n\t\t\t\tint changed;\n\t\t\t\tint bestPercent = n/1000;\n\t\t\t\tint minIndex;\n\t\t\t\tkpp();\n\t\t\t\tdo {\n\t\t\t\t\t\tfor (Point c : centroids) {\n\t\t\t\t\t\t\t\tc.x = 0.0;\n\t\t\t\t\t\t\t\tc.y = 0.0;\n\t\t\t\t\t\t\t\tc.group = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (Point pt : points) {\n\t\t\t\t\t\t\t\tif(pt.group < 0 || pt.group > centroids.length){\n\t\t\t\t\t\t\t\t\t\tpt.group = rand.nextInt(centroids.length);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcentroids[pt.group].x += pt.x;\n\t\t\t\t\t\t\t\tcentroids[pt.group].y = pt.y;\n\t\t\t\t\t\t\t\tcentroids[pt.group].group++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (Point c : centroids) {\n\t\t\t\t\t\t\t\tc.x /= c.group;\n\t\t\t\t\t\t\t\tc.y /= c.group;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tchanged = 0;\n\t\t\t\t\t\tfor (Point pt : points) {\n\t\t\t\t\t\t\t\tminIndex = nearest(pt, centroids, k);\n\t\t\t\t\t\t\t\tif (k != pt.group) {\n\t\t\t\t\t\t\t\t\t\tchanged++;\n\t\t\t\t\t\t\t\t\t\tpt.group = minIndex;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmaxTimes--;\n\t\t\t\t} while (changed > bestPercent && maxTimes > 0);\n\t\t}\n}\n\n\n\n\nclass Point{\n\t\tpublic double x;\n\t\tpublic double y;\n\t\tpublic int group;\n\n\t\tPoint(){\n\t\t\t\tx = y = 0.0;\n\t\t\t\tgroup = 0;\n\t\t}\n\n\t\t\n\t\tpublic Point[] getRandomPlaneData(double minX, double maxX, double minY, double maxY, int size){\n\t\t\t\tif (size <= 0)\n\t\t\t\t\t\treturn null;\n\t\t\t\tdouble xdiff, ydiff;\n\t\t\t\txdiff = maxX - minX;\n\t\t\t\tydiff = maxY - minY;\n\t\t\t\tif (minX > maxX) {\n\t\t\t\t\t\txdiff = minX - maxX;\n\t\t\t\t\t\tminX = maxX;\n\t\t\t\t}\n\t\t\t\tif (maxY < minY) {\n\t\t\t\t\t\tydiff = minY - maxY;\n\t\t\t\t\t\tminY = maxY;\n\t\t\t\t}\n\t\t\t\tPoint[] data = new Point[size];\n\t\t\t\tRandom rand = new Random();\n\t\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t\t\tdata[i].x = minX + (xdiff * rand.nextInt(Integer.MAX_VALUE)) / Integer.MAX_VALUE;\n\t\t\t\t\t\tdata[i].y = minY + (ydiff * rand.nextInt(Integer.MAX_VALUE)) / Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t\treturn data;\n\t\t}\n\n\t\t\n\t\tpublic Point[] getRandomPolarData(double radius, int size){\n\t\t\t\tif (size <= 0) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tPoint[] data = new Point[size];\n\t\t\t\tdouble radi, arg;\n\t\t\t\tRandom rand = new Random();\n\t\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t\t\tradi = (radius * rand.nextInt(Integer.MAX_VALUE)) / Integer.MAX_VALUE;\n\t\t\t\t\t\targ = (2 * Math.PI * rand.nextInt(Integer.MAX_VALUE)) / Integer.MAX_VALUE;\n\t\t\t\t\t\tdata[i].x = radi * Math.cos(arg);\n\t\t\t\t\t\tdata[i].y = radi * Math.sin(arg);\n\t\t\t\t}\n\t\t\t\treturn data;\n\t\t}\n\t\t\n}", "gold": "from math import pi, sin, cos\nfrom collections import namedtuple\nfrom random import random, choice\nfrom copy import copy\n\ntry:\n    import psyco\n    psyco.full()\nexcept ImportError:\n    pass\n\n\nFLOAT_MAX = 1e100\n\n\nclass Point:\n    __slots__ = [\"x\", \"y\", \"group\"]\n    def __init__(self, x=0.0, y=0.0, group=0):\n        self.x, self.y, self.group = x, y, group\n\n\ndef generate_points(npoints, radius):\n    points = [Point() for _ in xrange(npoints)]\n\n    \n    for p in points:\n        r = random() * radius\n        ang = random() * 2 * pi\n        p.x = r * cos(ang)\n        p.y = r * sin(ang)\n\n    return points\n\n\ndef nearest_cluster_center(point, cluster_centers):\n    \n    def sqr_distance_2D(a, b):\n        return (a.x - b.x) ** 2  +  (a.y - b.y) ** 2\n\n    min_index = point.group\n    min_dist = FLOAT_MAX\n\n    for i, cc in enumerate(cluster_centers):\n        d = sqr_distance_2D(cc, point)\n        if min_dist > d:\n            min_dist = d\n            min_index = i\n\n    return (min_index, min_dist)\n\n\ndef kpp(points, cluster_centers):\n    cluster_centers[0] = copy(choice(points))\n    d = [0.0 for _ in xrange(len(points))]\n\n    for i in xrange(1, len(cluster_centers)):\n        sum = 0\n        for j, p in enumerate(points):\n            d[j] = nearest_cluster_center(p, cluster_centers[:i])[1]\n            sum += d[j]\n\n        sum *= random()\n\n        for j, di in enumerate(d):\n            sum -= di\n            if sum > 0:\n                continue\n            cluster_centers[i] = copy(points[j])\n            break\n\n    for p in points:\n        p.group = nearest_cluster_center(p, cluster_centers)[0]\n\n\ndef lloyd(points, nclusters):\n    cluster_centers = [Point() for _ in xrange(nclusters)]\n\n    \n    kpp(points, cluster_centers)\n\n    lenpts10 = len(points) >> 10\n\n    changed = 0\n    while True:\n        \n        for cc in cluster_centers:\n            cc.x = 0\n            cc.y = 0\n            cc.group = 0\n\n        for p in points:\n            cluster_centers[p.group].group += 1\n            cluster_centers[p.group].x += p.x\n            cluster_centers[p.group].y += p.y\n\n        for cc in cluster_centers:\n            cc.x /= cc.group\n            cc.y /= cc.group\n\n        \n        changed = 0\n        for p in points:\n            min_i = nearest_cluster_center(p, cluster_centers)[0]\n            if min_i != p.group:\n                changed += 1\n                p.group = min_i\n\n        \n        if changed <= lenpts10:\n            break\n\n    for i, cc in enumerate(cluster_centers):\n        cc.group = i\n\n    return cluster_centers\n\n\ndef print_eps(points, cluster_centers, W=400, H=400):\n    Color = namedtuple(\"Color\", \"r g b\");\n\n    colors = []\n    for i in xrange(len(cluster_centers)):\n        colors.append(Color((3 * (i + 1) % 11) / 11.0,\n                            (7 * i % 11) / 11.0,\n                            (9 * i % 11) / 11.0))\n\n    max_x = max_y = -FLOAT_MAX\n    min_x = min_y = FLOAT_MAX\n\n    for p in points:\n        if max_x < p.x: max_x = p.x\n        if min_x > p.x: min_x = p.x\n        if max_y < p.y: max_y = p.y\n        if min_y > p.y: min_y = p.y\n\n    scale = min(W / (max_x - min_x),\n                H / (max_y - min_y))\n    cx = (max_x + min_x) / 2\n    cy = (max_y + min_y) / 2\n\n    print \"%%!PS-Adobe-3.0\\n%%%%BoundingBox: -5 -5 %d %d\" % (W + 10, H + 10)\n\n    print (\"/l {rlineto} def /m {rmoveto} def\\n\" +\n           \"/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def\\n\" +\n           \"/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath \" +\n           \"   gsave 1 setgray fill grestore gsave 3 setlinewidth\" +\n           \" 1 setgray stroke grestore 0 setgray stroke }def\")\n\n    for i, cc in enumerate(cluster_centers):\n        print (\"%g %g %g setrgbcolor\" %\n               (colors[i].r, colors[i].g, colors[i].b))\n\n        for p in points:\n            if p.group != i:\n                continue\n            print (\"%.3f %.3f c\" % ((p.x - cx) * scale + W / 2,\n                                    (p.y - cy) * scale + H / 2))\n\n        print (\"\\n0 setgray %g %g s\" % ((cc.x - cx) * scale + W / 2,\n                                        (cc.y - cy) * scale + H / 2))\n\n    print \"\\n%%%%EOF\"\n\n\ndef main():\n    npoints = 30000\n    k = 7 \n\n    points = generate_points(npoints, 10)\n    cluster_centers = lloyd(points, k)\n    print_eps(points, cluster_centers)\n\n\nmain()", "llm": "dsc-7b", "output": "import random\nimport math\n\nclass Point:\n    def __init__(self):\n        self.x = 0.0\n        self.y = 0.0\n        self.group = 0\n\nclass KMeansWithKpp:\n    def __init__(self, p, clusters):\n        self.points = p\n        self.n = len(p)\n        self.k = max(1, clusters)\n        self.centroids = [Point() for _ in range(self.k)]\n        self.rand = random.Random()\n\n    @staticmethod\n    def distance(a, b):\n        return (a.x - b.x) ** 2 + (a.y - b.y) ** 2\n\n    @staticmethod\n    def nearest(pt, others, len):\n        min_d = float('inf')\n        index = pt.group\n        len = min(len(others), len)\n        for i in range(len):\n            dist = KMeansWithKpp.distance(pt, others[i])\n            if min_d > dist:\n                min_d = dist\n                index = i\n        return index\n\n    @staticmethod\n    def nearest_distance(pt, others, len):\n        min_d = float('inf')\n        len = min(len(others), len)\n        for i in range(len):\n            dist = KMeansWithKpp.distance(pt, others[i])\n            if min_d > dist:\n                min_d = dist\n        return min_d\n\n    def kpp(self):\n        self.centroids[0] = self.points[self.rand.randint(0, self.n - 1)]\n        dist = [0.0] * self.n\n        sum_d = 0.0\n        for i in range(1, self.k):\n            for j in range(self.n):\n                dist[j] = self.nearest_distance(self.points[j], self.centroids, i)\n                sum_d += dist[j]\n            sum_d *= self.rand.random()\n            for j in range(self.n):\n                if (sum_d := sum_d - dist[j]) > 0:\n                    continue\n                self.centroids[i].x = self.points[j].x\n                self.centroids[i].y = self.points[j].y\n                break\n        for i in range(self.n):\n            self.points[i].group = self.nearest(self.points[i], self.centroids, self.k)\n\n    def kMeans(self, max_times):\n        if self.k == 1 or self.n <= 0:\n            return\n        if self.k >= self.n:\n            for i in range(self.n):\n                self.points[i].group = i\n            return\n        max_times = max(1, max_times)\n        changed = 0\n        best_percent = self.n // 1000\n        min_index = 0\n        self.kpp()\n        while changed > best_percent and max_times > 0:\n            for c in self.centroids:\n                c.x = 0.0\n                c.y = 0.0\n                c.group = 0\n            for pt in self.points:\n                if pt.group < 0 or pt.group >= len(self.centroids):\n                    pt.group = self.rand.randint(0, len(self.centroids) - 1)\n                self.centroids[pt.group].x += pt.x\n                self.centroids[pt.group].y += pt.y\n                self.centroids[pt.group].group += 1\n            for c in self.centroids:\n                if c.group != 0:\n                    c.x /= c.group\n                    c.y /= c.group\n            changed = 0\n            for pt in self.points:\n                min_index = self.nearest(pt, self.centroids, self.k)\n                if self.k != pt.group:\n                    changed += 1\n                    pt.group = min_index\n            max_times -= 1", "index": 126}
{"lang": "Java, Python", "input": "import java.util.Random;\n\npublic class KMeansWithKpp{\n\t\t\n\t\tpublic Point[] points;\n\t\tpublic Point[] centroids;\n\t\tRandom rand;\n\t\tpublic int n;\n\t\tpublic int k;\n\n\t\t\n\t\tprivate KMeansWithKpp(){\n\t\t}\n\n\t\tKMeansWithKpp(Point[] p, int clusters){\n\t\t\t\tpoints = p;\n\t\t\t\tn = p.length;\n\t\t\t\tk = Math.max(1, clusters);\n\t\t\t\tcentroids = new Point[k];\n\t\t\t\trand = new Random();\n\t\t}\n\n\n\t\tprivate static double distance(Point a, Point b){\n\t\t\t\treturn (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n\t\t}\n\n\t\tprivate static int nearest(Point pt, Point[] others, int len){\n\t\t\t\tdouble minD = Double.MAX_VALUE;\n\t\t\t\tint index = pt.group;\n\t\t\t\tlen = Math.min(others.length, len);\n\t\t\t\tdouble dist;\n\t\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\t\t\tif (minD > (dist = distance(pt, others[i]))) {\n\t\t\t\t\t\t\t\tminD = dist;\n\t\t\t\t\t\t\t\tindex = i;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn index;\n\t\t}\n\n\t\tprivate static double nearestDistance(Point pt, Point[] others, int len){\n\t\t\t\tdouble minD = Double.MAX_VALUE;\n\t\t\t\tlen = Math.min(others.length, len);\n\t\t\t\tdouble dist;\n\t\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\t\t\tif (minD > (dist = distance(pt, others[i]))) {\n\t\t\t\t\t\t\t\tminD = dist;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn minD;\n\t\t}\n\n\t\tprivate void kpp(){\n\t\t\t\tcentroids[0] = points[rand.nextInt(n)];\n\t\t\t\tdouble[] dist = new double[n];\n\t\t\t\tdouble sum = 0;\n\t\t\t\tfor (int i = 1; i < k; i++) {\n\t\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\t\t\tdist[j] = nearestDistance(points[j], centroids, i);\n\t\t\t\t\t\t\t\tsum += dist[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsum = (sum * rand.nextInt(Integer.MAX_VALUE)) / Integer.MAX_VALUE;\n\t\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\t\t\tif ((sum -= dist[j]) > 0)\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tcentroids[i].x = points[j].x;\n\t\t\t\t\t\t\t\tcentroids[i].y = points[j].y;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\tpoints[i].group = nearest(points[i], centroids, k);\n\t\t\t\t}\n\t\t}\n\n\t\tpublic void kMeans(int maxTimes){\n\t\t\t\tif (k == 1 || n <= 0) {\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(k >= n){\n\t\t\t\t\t\tfor(int i =0; i < n; i++){\n\t\t\t\t\t\t\t\tpoints[i].group = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tmaxTimes = Math.max(1, maxTimes);\n\t\t\t\tint changed;\n\t\t\t\tint bestPercent = n/1000;\n\t\t\t\tint minIndex;\n\t\t\t\tkpp();\n\t\t\t\tdo {\n\t\t\t\t\t\tfor (Point c : centroids) {\n\t\t\t\t\t\t\t\tc.x = 0.0;\n\t\t\t\t\t\t\t\tc.y = 0.0;\n\t\t\t\t\t\t\t\tc.group = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (Point pt : points) {\n\t\t\t\t\t\t\t\tif(pt.group < 0 || pt.group > centroids.length){\n\t\t\t\t\t\t\t\t\t\tpt.group = rand.nextInt(centroids.length);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcentroids[pt.group].x += pt.x;\n\t\t\t\t\t\t\t\tcentroids[pt.group].y = pt.y;\n\t\t\t\t\t\t\t\tcentroids[pt.group].group++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (Point c : centroids) {\n\t\t\t\t\t\t\t\tc.x /= c.group;\n\t\t\t\t\t\t\t\tc.y /= c.group;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tchanged = 0;\n\t\t\t\t\t\tfor (Point pt : points) {\n\t\t\t\t\t\t\t\tminIndex = nearest(pt, centroids, k);\n\t\t\t\t\t\t\t\tif (k != pt.group) {\n\t\t\t\t\t\t\t\t\t\tchanged++;\n\t\t\t\t\t\t\t\t\t\tpt.group = minIndex;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmaxTimes--;\n\t\t\t\t} while (changed > bestPercent && maxTimes > 0);\n\t\t}\n}\n\n\n\n\nclass Point{\n\t\tpublic double x;\n\t\tpublic double y;\n\t\tpublic int group;\n\n\t\tPoint(){\n\t\t\t\tx = y = 0.0;\n\t\t\t\tgroup = 0;\n\t\t}\n\n\t\t\n\t\tpublic Point[] getRandomPlaneData(double minX, double maxX, double minY, double maxY, int size){\n\t\t\t\tif (size <= 0)\n\t\t\t\t\t\treturn null;\n\t\t\t\tdouble xdiff, ydiff;\n\t\t\t\txdiff = maxX - minX;\n\t\t\t\tydiff = maxY - minY;\n\t\t\t\tif (minX > maxX) {\n\t\t\t\t\t\txdiff = minX - maxX;\n\t\t\t\t\t\tminX = maxX;\n\t\t\t\t}\n\t\t\t\tif (maxY < minY) {\n\t\t\t\t\t\tydiff = minY - maxY;\n\t\t\t\t\t\tminY = maxY;\n\t\t\t\t}\n\t\t\t\tPoint[] data = new Point[size];\n\t\t\t\tRandom rand = new Random();\n\t\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t\t\tdata[i].x = minX + (xdiff * rand.nextInt(Integer.MAX_VALUE)) / Integer.MAX_VALUE;\n\t\t\t\t\t\tdata[i].y = minY + (ydiff * rand.nextInt(Integer.MAX_VALUE)) / Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t\treturn data;\n\t\t}\n\n\t\t\n\t\tpublic Point[] getRandomPolarData(double radius, int size){\n\t\t\t\tif (size <= 0) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tPoint[] data = new Point[size];\n\t\t\t\tdouble radi, arg;\n\t\t\t\tRandom rand = new Random();\n\t\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t\t\tradi = (radius * rand.nextInt(Integer.MAX_VALUE)) / Integer.MAX_VALUE;\n\t\t\t\t\t\targ = (2 * Math.PI * rand.nextInt(Integer.MAX_VALUE)) / Integer.MAX_VALUE;\n\t\t\t\t\t\tdata[i].x = radi * Math.cos(arg);\n\t\t\t\t\t\tdata[i].y = radi * Math.sin(arg);\n\t\t\t\t}\n\t\t\t\treturn data;\n\t\t}\n\t\t\n}", "gold": "from math import pi, sin, cos\nfrom collections import namedtuple\nfrom random import random, choice\nfrom copy import copy\n\ntry:\n    import psyco\n    psyco.full()\nexcept ImportError:\n    pass\n\n\nFLOAT_MAX = 1e100\n\n\nclass Point:\n    __slots__ = [\"x\", \"y\", \"group\"]\n    def __init__(self, x=0.0, y=0.0, group=0):\n        self.x, self.y, self.group = x, y, group\n\n\ndef generate_points(npoints, radius):\n    points = [Point() for _ in xrange(npoints)]\n\n    \n    for p in points:\n        r = random() * radius\n        ang = random() * 2 * pi\n        p.x = r * cos(ang)\n        p.y = r * sin(ang)\n\n    return points\n\n\ndef nearest_cluster_center(point, cluster_centers):\n    \n    def sqr_distance_2D(a, b):\n        return (a.x - b.x) ** 2  +  (a.y - b.y) ** 2\n\n    min_index = point.group\n    min_dist = FLOAT_MAX\n\n    for i, cc in enumerate(cluster_centers):\n        d = sqr_distance_2D(cc, point)\n        if min_dist > d:\n            min_dist = d\n            min_index = i\n\n    return (min_index, min_dist)\n\n\ndef kpp(points, cluster_centers):\n    cluster_centers[0] = copy(choice(points))\n    d = [0.0 for _ in xrange(len(points))]\n\n    for i in xrange(1, len(cluster_centers)):\n        sum = 0\n        for j, p in enumerate(points):\n            d[j] = nearest_cluster_center(p, cluster_centers[:i])[1]\n            sum += d[j]\n\n        sum *= random()\n\n        for j, di in enumerate(d):\n            sum -= di\n            if sum > 0:\n                continue\n            cluster_centers[i] = copy(points[j])\n            break\n\n    for p in points:\n        p.group = nearest_cluster_center(p, cluster_centers)[0]\n\n\ndef lloyd(points, nclusters):\n    cluster_centers = [Point() for _ in xrange(nclusters)]\n\n    \n    kpp(points, cluster_centers)\n\n    lenpts10 = len(points) >> 10\n\n    changed = 0\n    while True:\n        \n        for cc in cluster_centers:\n            cc.x = 0\n            cc.y = 0\n            cc.group = 0\n\n        for p in points:\n            cluster_centers[p.group].group += 1\n            cluster_centers[p.group].x += p.x\n            cluster_centers[p.group].y += p.y\n\n        for cc in cluster_centers:\n            cc.x /= cc.group\n            cc.y /= cc.group\n\n        \n        changed = 0\n        for p in points:\n            min_i = nearest_cluster_center(p, cluster_centers)[0]\n            if min_i != p.group:\n                changed += 1\n                p.group = min_i\n\n        \n        if changed <= lenpts10:\n            break\n\n    for i, cc in enumerate(cluster_centers):\n        cc.group = i\n\n    return cluster_centers\n\n\ndef print_eps(points, cluster_centers, W=400, H=400):\n    Color = namedtuple(\"Color\", \"r g b\");\n\n    colors = []\n    for i in xrange(len(cluster_centers)):\n        colors.append(Color((3 * (i + 1) % 11) / 11.0,\n                            (7 * i % 11) / 11.0,\n                            (9 * i % 11) / 11.0))\n\n    max_x = max_y = -FLOAT_MAX\n    min_x = min_y = FLOAT_MAX\n\n    for p in points:\n        if max_x < p.x: max_x = p.x\n        if min_x > p.x: min_x = p.x\n        if max_y < p.y: max_y = p.y\n        if min_y > p.y: min_y = p.y\n\n    scale = min(W / (max_x - min_x),\n                H / (max_y - min_y))\n    cx = (max_x + min_x) / 2\n    cy = (max_y + min_y) / 2\n\n    print \"%%!PS-Adobe-3.0\\n%%%%BoundingBox: -5 -5 %d %d\" % (W + 10, H + 10)\n\n    print (\"/l {rlineto} def /m {rmoveto} def\\n\" +\n           \"/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def\\n\" +\n           \"/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath \" +\n           \"   gsave 1 setgray fill grestore gsave 3 setlinewidth\" +\n           \" 1 setgray stroke grestore 0 setgray stroke }def\")\n\n    for i, cc in enumerate(cluster_centers):\n        print (\"%g %g %g setrgbcolor\" %\n               (colors[i].r, colors[i].g, colors[i].b))\n\n        for p in points:\n            if p.group != i:\n                continue\n            print (\"%.3f %.3f c\" % ((p.x - cx) * scale + W / 2,\n                                    (p.y - cy) * scale + H / 2))\n\n        print (\"\\n0 setgray %g %g s\" % ((cc.x - cx) * scale + W / 2,\n                                        (cc.y - cy) * scale + H / 2))\n\n    print \"\\n%%%%EOF\"\n\n\ndef main():\n    npoints = 30000\n    k = 7 \n\n    points = generate_points(npoints, 10)\n    cluster_centers = lloyd(points, k)\n    print_eps(points, cluster_centers)\n\n\nmain()", "llm": "dsc-33b", "output": "import random\nimport math\n\nclass Point:\n    def __init__(self, x=0.0, y=0.0, group=0):\n        self.x = x\n        self.y = y\n        self.group = group\n\n    @staticmethod\n    def get_random_plane_data(min_x, max_x, min_y, max_y, size):\n        if size <= 0:\n            return None\n        x_diff = max_x - min_x\n        y_diff = max_y - min_y\n        if min_x > max_x:\n            x_diff = min_x - max_x\n            min_x = max_x\n        if max_y < min_y:\n            y_diff = min_y - max_y\n            min_y = max_y\n        data = [Point() for _ in range(size)]\n        for i in range(size):\n            data[i].x = min_x + (x_diff * random.randint(0, 1000000000)) / 1000000000\n            data[i].y = min_y + (y_diff * random.randint(0, 1000000000)) / 1000000000\n        return data\n\n    @staticmethod\n    def get_random_polar_data(radius, size):\n        if size <= 0:\n            return None\n        data = [Point() for _ in range(size)]\n        for i in range(size):\n            radi = (radius * random.randint(0, 1000000000)) / 1000000000\n            arg = (2 * math.pi * random.randint(0, 1000000000)) / 1000000000\n            data[i].x = radi * math.cos(arg)\n            data[i].y = radi * math.sin(arg)\n        return data\n\n\nclass KMeansWithKpp:\n    def __init__(self, p, clusters):\n        self.points = p\n        self.n = len(p)\n        self.k = max(1, clusters)\n        self.centroids = [Point() for _ in range(self.k)]\n        self.rand = random.Random()\n\n    @staticmethod\n    def distance(a, b):\n        return (a.x - b.x) ** 2 + (a.y - b.y) ** 2\n\n    @staticmethod\n    def nearest(pt, others, len):\n        min_d = float('inf')\n        index = pt.group\n        len = min(len, len(others))\n        for i in range(len):\n            dist = KMeansWithKpp.distance(pt, others[i])\n            if min_d > dist:\n                min_d = dist\n                index = i\n        return index\n\n    @staticmethod\n    def nearest_distance(pt, others, len):\n        min_d = float('inf')\n        len = min(len, len(others))\n        for i in range(len):\n            dist = KMeansWithKpp.distance(pt, others[i])\n            if min_d > dist:\n                min_d = dist\n        return min_d\n\n    def kpp(self):\n        self.centroids[0] = self.points[self.rand.randint(0, self.n - 1)]\n        dist = [0.0] * self.n\n        sum_dist = 0.0\n        for i in range(1, self.k):\n            for j in range(self.n):\n                dist[j] = KMeansWithKpp.nearest_distance(self.points[j], self.centroids, i)\n                sum_dist += dist[j]\n            sum_dist = (sum_dist * self.rand.randint(0, 1000000000)) / 1000000000\n            for j in range(self.n):\n                if (sum_dist -= dist[j]) > 0:\n                    continue\n                self.centroids[i].x = self.points[j].x\n                self.centroids[i].y = self.points[j].y\n        for i in range(self.n):\n            self.points[i].group = KMeansWithKpp.nearest(self.points[i], self.centroids, self.k)\n\n    def k_means(self, max_times):\n        if self.k == 1 or self.n <= 0:\n            return\n        if self.k >= self.n:\n            for i in range(self.n):\n                self.points[i].group = i\n            return\n        max_times = max(1, max_times)\n        changed = 0\n        best_percent = self.n // 1000\n        min_index = 0\n        self.kpp()\n        while True:\n            for c in self.centroids:\n                c.x = 0.0\n                c.y = 0.0\n                c.group = 0\n            for pt in self.points:\n                if pt.group < 0 or pt.group > len(self.centroids):\n                    pt.group = self.rand.randint(0, len(self.centroids) - 1)\n                self.centroids[pt.group].x += pt.x\n                self.centroids[pt.group].y += pt.y\n                self.centroids[pt.group].group += 1\n            for c in self.centroids:\n                c.x /= c.group\n                c.y /= c.group\n            changed = 0\n            for pt in self.points:\n                min_index = KMeansWithKpp.nearest(pt, self.centroids, self.k)\n                if self.k != pt.group:\n                    changed += 1\n                    pt.group = min_index\n            max_times -= 1\n            if changed <= best_percent or max_times <= 0:\n                break", "index": 127}
{"lang": "Java, Python", "input": "import java.util.Random;\n\npublic class KMeansWithKpp{\n\t\t\n\t\tpublic Point[] points;\n\t\tpublic Point[] centroids;\n\t\tRandom rand;\n\t\tpublic int n;\n\t\tpublic int k;\n\n\t\t\n\t\tprivate KMeansWithKpp(){\n\t\t}\n\n\t\tKMeansWithKpp(Point[] p, int clusters){\n\t\t\t\tpoints = p;\n\t\t\t\tn = p.length;\n\t\t\t\tk = Math.max(1, clusters);\n\t\t\t\tcentroids = new Point[k];\n\t\t\t\trand = new Random();\n\t\t}\n\n\n\t\tprivate static double distance(Point a, Point b){\n\t\t\t\treturn (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n\t\t}\n\n\t\tprivate static int nearest(Point pt, Point[] others, int len){\n\t\t\t\tdouble minD = Double.MAX_VALUE;\n\t\t\t\tint index = pt.group;\n\t\t\t\tlen = Math.min(others.length, len);\n\t\t\t\tdouble dist;\n\t\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\t\t\tif (minD > (dist = distance(pt, others[i]))) {\n\t\t\t\t\t\t\t\tminD = dist;\n\t\t\t\t\t\t\t\tindex = i;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn index;\n\t\t}\n\n\t\tprivate static double nearestDistance(Point pt, Point[] others, int len){\n\t\t\t\tdouble minD = Double.MAX_VALUE;\n\t\t\t\tlen = Math.min(others.length, len);\n\t\t\t\tdouble dist;\n\t\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\t\t\tif (minD > (dist = distance(pt, others[i]))) {\n\t\t\t\t\t\t\t\tminD = dist;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn minD;\n\t\t}\n\n\t\tprivate void kpp(){\n\t\t\t\tcentroids[0] = points[rand.nextInt(n)];\n\t\t\t\tdouble[] dist = new double[n];\n\t\t\t\tdouble sum = 0;\n\t\t\t\tfor (int i = 1; i < k; i++) {\n\t\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\t\t\tdist[j] = nearestDistance(points[j], centroids, i);\n\t\t\t\t\t\t\t\tsum += dist[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsum = (sum * rand.nextInt(Integer.MAX_VALUE)) / Integer.MAX_VALUE;\n\t\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\t\t\tif ((sum -= dist[j]) > 0)\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tcentroids[i].x = points[j].x;\n\t\t\t\t\t\t\t\tcentroids[i].y = points[j].y;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\tpoints[i].group = nearest(points[i], centroids, k);\n\t\t\t\t}\n\t\t}\n\n\t\tpublic void kMeans(int maxTimes){\n\t\t\t\tif (k == 1 || n <= 0) {\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(k >= n){\n\t\t\t\t\t\tfor(int i =0; i < n; i++){\n\t\t\t\t\t\t\t\tpoints[i].group = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tmaxTimes = Math.max(1, maxTimes);\n\t\t\t\tint changed;\n\t\t\t\tint bestPercent = n/1000;\n\t\t\t\tint minIndex;\n\t\t\t\tkpp();\n\t\t\t\tdo {\n\t\t\t\t\t\tfor (Point c : centroids) {\n\t\t\t\t\t\t\t\tc.x = 0.0;\n\t\t\t\t\t\t\t\tc.y = 0.0;\n\t\t\t\t\t\t\t\tc.group = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (Point pt : points) {\n\t\t\t\t\t\t\t\tif(pt.group < 0 || pt.group > centroids.length){\n\t\t\t\t\t\t\t\t\t\tpt.group = rand.nextInt(centroids.length);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcentroids[pt.group].x += pt.x;\n\t\t\t\t\t\t\t\tcentroids[pt.group].y = pt.y;\n\t\t\t\t\t\t\t\tcentroids[pt.group].group++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (Point c : centroids) {\n\t\t\t\t\t\t\t\tc.x /= c.group;\n\t\t\t\t\t\t\t\tc.y /= c.group;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tchanged = 0;\n\t\t\t\t\t\tfor (Point pt : points) {\n\t\t\t\t\t\t\t\tminIndex = nearest(pt, centroids, k);\n\t\t\t\t\t\t\t\tif (k != pt.group) {\n\t\t\t\t\t\t\t\t\t\tchanged++;\n\t\t\t\t\t\t\t\t\t\tpt.group = minIndex;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmaxTimes--;\n\t\t\t\t} while (changed > bestPercent && maxTimes > 0);\n\t\t}\n}\n\n\n\n\nclass Point{\n\t\tpublic double x;\n\t\tpublic double y;\n\t\tpublic int group;\n\n\t\tPoint(){\n\t\t\t\tx = y = 0.0;\n\t\t\t\tgroup = 0;\n\t\t}\n\n\t\t\n\t\tpublic Point[] getRandomPlaneData(double minX, double maxX, double minY, double maxY, int size){\n\t\t\t\tif (size <= 0)\n\t\t\t\t\t\treturn null;\n\t\t\t\tdouble xdiff, ydiff;\n\t\t\t\txdiff = maxX - minX;\n\t\t\t\tydiff = maxY - minY;\n\t\t\t\tif (minX > maxX) {\n\t\t\t\t\t\txdiff = minX - maxX;\n\t\t\t\t\t\tminX = maxX;\n\t\t\t\t}\n\t\t\t\tif (maxY < minY) {\n\t\t\t\t\t\tydiff = minY - maxY;\n\t\t\t\t\t\tminY = maxY;\n\t\t\t\t}\n\t\t\t\tPoint[] data = new Point[size];\n\t\t\t\tRandom rand = new Random();\n\t\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t\t\tdata[i].x = minX + (xdiff * rand.nextInt(Integer.MAX_VALUE)) / Integer.MAX_VALUE;\n\t\t\t\t\t\tdata[i].y = minY + (ydiff * rand.nextInt(Integer.MAX_VALUE)) / Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t\treturn data;\n\t\t}\n\n\t\t\n\t\tpublic Point[] getRandomPolarData(double radius, int size){\n\t\t\t\tif (size <= 0) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tPoint[] data = new Point[size];\n\t\t\t\tdouble radi, arg;\n\t\t\t\tRandom rand = new Random();\n\t\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t\t\tradi = (radius * rand.nextInt(Integer.MAX_VALUE)) / Integer.MAX_VALUE;\n\t\t\t\t\t\targ = (2 * Math.PI * rand.nextInt(Integer.MAX_VALUE)) / Integer.MAX_VALUE;\n\t\t\t\t\t\tdata[i].x = radi * Math.cos(arg);\n\t\t\t\t\t\tdata[i].y = radi * Math.sin(arg);\n\t\t\t\t}\n\t\t\t\treturn data;\n\t\t}\n\t\t\n}", "gold": "from math import pi, sin, cos\nfrom collections import namedtuple\nfrom random import random, choice\nfrom copy import copy\n\ntry:\n    import psyco\n    psyco.full()\nexcept ImportError:\n    pass\n\n\nFLOAT_MAX = 1e100\n\n\nclass Point:\n    __slots__ = [\"x\", \"y\", \"group\"]\n    def __init__(self, x=0.0, y=0.0, group=0):\n        self.x, self.y, self.group = x, y, group\n\n\ndef generate_points(npoints, radius):\n    points = [Point() for _ in xrange(npoints)]\n\n    \n    for p in points:\n        r = random() * radius\n        ang = random() * 2 * pi\n        p.x = r * cos(ang)\n        p.y = r * sin(ang)\n\n    return points\n\n\ndef nearest_cluster_center(point, cluster_centers):\n    \n    def sqr_distance_2D(a, b):\n        return (a.x - b.x) ** 2  +  (a.y - b.y) ** 2\n\n    min_index = point.group\n    min_dist = FLOAT_MAX\n\n    for i, cc in enumerate(cluster_centers):\n        d = sqr_distance_2D(cc, point)\n        if min_dist > d:\n            min_dist = d\n            min_index = i\n\n    return (min_index, min_dist)\n\n\ndef kpp(points, cluster_centers):\n    cluster_centers[0] = copy(choice(points))\n    d = [0.0 for _ in xrange(len(points))]\n\n    for i in xrange(1, len(cluster_centers)):\n        sum = 0\n        for j, p in enumerate(points):\n            d[j] = nearest_cluster_center(p, cluster_centers[:i])[1]\n            sum += d[j]\n\n        sum *= random()\n\n        for j, di in enumerate(d):\n            sum -= di\n            if sum > 0:\n                continue\n            cluster_centers[i] = copy(points[j])\n            break\n\n    for p in points:\n        p.group = nearest_cluster_center(p, cluster_centers)[0]\n\n\ndef lloyd(points, nclusters):\n    cluster_centers = [Point() for _ in xrange(nclusters)]\n\n    \n    kpp(points, cluster_centers)\n\n    lenpts10 = len(points) >> 10\n\n    changed = 0\n    while True:\n        \n        for cc in cluster_centers:\n            cc.x = 0\n            cc.y = 0\n            cc.group = 0\n\n        for p in points:\n            cluster_centers[p.group].group += 1\n            cluster_centers[p.group].x += p.x\n            cluster_centers[p.group].y += p.y\n\n        for cc in cluster_centers:\n            cc.x /= cc.group\n            cc.y /= cc.group\n\n        \n        changed = 0\n        for p in points:\n            min_i = nearest_cluster_center(p, cluster_centers)[0]\n            if min_i != p.group:\n                changed += 1\n                p.group = min_i\n\n        \n        if changed <= lenpts10:\n            break\n\n    for i, cc in enumerate(cluster_centers):\n        cc.group = i\n\n    return cluster_centers\n\n\ndef print_eps(points, cluster_centers, W=400, H=400):\n    Color = namedtuple(\"Color\", \"r g b\");\n\n    colors = []\n    for i in xrange(len(cluster_centers)):\n        colors.append(Color((3 * (i + 1) % 11) / 11.0,\n                            (7 * i % 11) / 11.0,\n                            (9 * i % 11) / 11.0))\n\n    max_x = max_y = -FLOAT_MAX\n    min_x = min_y = FLOAT_MAX\n\n    for p in points:\n        if max_x < p.x: max_x = p.x\n        if min_x > p.x: min_x = p.x\n        if max_y < p.y: max_y = p.y\n        if min_y > p.y: min_y = p.y\n\n    scale = min(W / (max_x - min_x),\n                H / (max_y - min_y))\n    cx = (max_x + min_x) / 2\n    cy = (max_y + min_y) / 2\n\n    print \"%%!PS-Adobe-3.0\\n%%%%BoundingBox: -5 -5 %d %d\" % (W + 10, H + 10)\n\n    print (\"/l {rlineto} def /m {rmoveto} def\\n\" +\n           \"/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def\\n\" +\n           \"/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath \" +\n           \"   gsave 1 setgray fill grestore gsave 3 setlinewidth\" +\n           \" 1 setgray stroke grestore 0 setgray stroke }def\")\n\n    for i, cc in enumerate(cluster_centers):\n        print (\"%g %g %g setrgbcolor\" %\n               (colors[i].r, colors[i].g, colors[i].b))\n\n        for p in points:\n            if p.group != i:\n                continue\n            print (\"%.3f %.3f c\" % ((p.x - cx) * scale + W / 2,\n                                    (p.y - cy) * scale + H / 2))\n\n        print (\"\\n0 setgray %g %g s\" % ((cc.x - cx) * scale + W / 2,\n                                        (cc.y - cy) * scale + H / 2))\n\n    print \"\\n%%%%EOF\"\n\n\ndef main():\n    npoints = 30000\n    k = 7 \n\n    points = generate_points(npoints, 10)\n    cluster_centers = lloyd(points, k)\n    print_eps(points, cluster_centers)\n\n\nmain()", "llm": "cs-22b", "output": "import random\nimport math\n\nclass Point:\n    def __init__(self):\n        self.x = 0.0\n        self.y = 0.0\n        self.group = 0\n\n    @staticmethod\n    def get_random_plane_data(min_x, max_x, min_y, max_y, size):\n        if size <= 0:\n            return None\n        xdiff = max_x - min_x\n        ydiff = max_y - min_y\n        if min_x > max_x:\n            xdiff = min_x - max_x\n            min_x = max_x\n        if max_y < min_y:\n            ydiff = min_y - max_y\n            min_y = max_y\n        data = [Point() for _ in range(size)]\n        for i in range(size):\n            data[i].x = min_x + (xdiff * random.random())\n            data[i].y = min_y + (ydiff * random.random())\n        return data\n\n    @staticmethod\n    def get_random_polar_data(radius, size):\n        if size <= 0:\n            return None\n        data = [Point() for _ in range(size)]\n        for i in range(size):\n            radi = radius * random.random()\n            arg = 2 * math.pi * random.random()\n            data[i].x = radi * math.cos(arg)\n            data[i].y = radi * math.sin(arg)\n        return data\n\nclass KMeansWithKpp:\n    def __init__(self, p, clusters):\n        self.points = p\n        self.n = len(p)\n        self.k = max(1, clusters)\n        self.centroids = [None] * self.k\n        self.rand = random.Random()\n\n    @staticmethod\n    def distance(a, b):\n        return (a.x - b.x) ** 2 + (a.y - b.y) ** 2\n\n    @staticmethod\n    def nearest(pt, others, length):\n        min_d = float('inf')\n        index = pt.group\n        length = min(len(others), length)\n        for i in range(length):\n            dist = KMeansWithKpp.distance(pt, others[i])\n            if min_d > dist:\n                min_d = dist\n                index = i\n        return index\n\n    @staticmethod\n    def nearest_distance(pt, others, length):\n        min_d = float('inf')\n        length = min(len(others), length)\n        for i in range(length):\n            dist = KMeansWithKpp.distance(pt, others[i])\n            if min_d > dist:\n                min_d = dist\n        return min_d\n\n    def kpp(self):\n        self.centroids[0] = self.points[self.rand.randint(0, self.n - 1)]\n        dist = [0.0] * self.n\n        sum_dist = 0.0\n        for i in range(1, self.k):\n            for j in range(self.n):\n                dist[j] = KMeansWithKpp.nearest_distance(self.points[j], self.centroids, i)\n                sum_dist += dist[j]\n            sum_dist = sum_dist * self.rand.random()\n            for j in range(self.n):\n                if (sum_dist -= dist[j]) > 0:\n                    continue\n                self.centroids[i] = Point()\n                self.centroids[i].x = self.points[j].x\n                self.centroids[i].y = self.points[j].y\n        for i in range(self.n):\n            self.points[i].group = KMeansWithKpp.nearest(self.points[i], self.centroids, self.k)\n\n    def k_means(self, max_times):\n        if self.k == 1 or self.n <= 0:\n            return\n        if self.k >= self.n:\n            for i in range(self.n):\n                self.points[i].group = i\n            return\n        max_times = max(1, max_times)\n        best_percent = self.n // 1000\n        self.kpp()\n        while max_times > 0:\n            for c in self.centroids:\n                c.x = 0.0\n                c.y = 0.0\n                c.group = 0\n            for pt in self.points:\n                if pt.group < 0 or pt.group > len(self.centroids):\n                    pt.group = self.rand.randint(0, len(self.centroids) - 1)\n                self.centroids[pt.group].x += pt.x\n                self.centroids[pt.group].y += pt.y\n                self.centroids[pt.group].group += 1\n            for c in self.centroids:\n                c.x /= c.group\n                c.y /= c.group\n            changed = 0\n            for pt in self.points:\n                min_index = KMeansWithKpp.nearest(pt, self.centroids, self.k)\n                if self.k != pt.group:\n                    changed += 1\n                    pt.group = min_index\n            max_times -= 1\n            if changed <= best_percent:\n                break", "index": 128}
{"lang": "Java, C", "input": "import java.util.function.Function;\n\npublic interface YCombinator {\n  interface RecursiveFunction<F> extends Function<RecursiveFunction<F>, F> { }\n  public static <A,B> Function<A,B> Y(Function<Function<A,B>, Function<A,B>> f) {\n    RecursiveFunction<Function<A,B>> r = w -> f.apply(x -> w.apply(w).apply(x));\n    return r.apply(r);\n  }\n\n  public static void main(String... arguments) {\n    Function<Integer,Integer> fib = Y(f -> n ->\n      (n <= 2)\n        ? 1\n        : (f.apply(n - 1) + f.apply(n - 2))\n    );\n    Function<Integer,Integer> fac = Y(f -> n ->\n      (n <= 1)\n        ? 1\n        : (n * f.apply(n - 1))\n    );\n\n    System.out.println(\"fib(10) = \" + fib.apply(10));\n    System.out.println(\"fac(10) = \" + fac.apply(10));\n  }\n}", "gold": "#include <stdio.h>\n#include <stdlib.h>\n\n\ntypedef struct func_t *func;\ntypedef struct func_t {\n        func (*fn) (func, func);\n        func _;\n        int num;\n} func_t;\n\nfunc new(func(*f)(func, func), func _) {\n        func x = malloc(sizeof(func_t));\n        x->fn = f;\n        x->_ = _;       \n        x->num = 0;\n        return x;\n}\n\nfunc call(func f, func n) {\n        return f->fn(f, n);\n}\n\nfunc Y(func(*f)(func, func)) {\n        func g = new(f, 0);\n        g->_ = g;\n        return g;\n}\n\nfunc num(int n) {\n        func x = new(0, 0);\n        x->num = n;\n        return x;\n}\n\n\nfunc fac(func self, func n) {\n        int nn = n->num;\n        return nn > 1   ? num(nn * call(self->_, num(nn - 1))->num)\n                        : num(1);\n}\n\nfunc fib(func self, func n) {\n        int nn = n->num;\n        return nn > 1\n                ? num(  call(self->_, num(nn - 1))->num +\n                        call(self->_, num(nn - 2))->num )\n                : num(1);\n}\n\nvoid show(func n) { printf(\" %d\", n->num); }\n\nint main() {\n        int i;\n        func f = Y(fac);\n        printf(\"fac: \");\n        for (i = 1; i < 10; i++)\n                show( call(f, num(i)) );\n        printf(\"\\n\");\n\n        f = Y(fib);\n        printf(\"fib: \");\n        for (i = 1; i < 10; i++)\n                show( call(f, num(i)) );\n        printf(\"\\n\");\n\n        return 0;\n}", "llm": "dsc-33b", "output": "#include <stdio.h>\n\ntypedef int (*RecursiveFunction)(int, RecursiveFunction);\n\nint Y(int (*f)(int, RecursiveFunction)) {\n    RecursiveFunction r = (int n, RecursiveFunction w) {\n        return f(n, (int m, RecursiveFunction x) {\n            return w(w, m);\n        });\n    };\n    return r(r, r);\n}\n\nint main() {\n    int fib = Y((int n, RecursiveFunction f) {\n        return (n <= 2) ? 1 : (f(n - 1, f) + f(n - 2, f));\n    });\n\n    int fac = Y((int n, RecursiveFunction f) {\n        return (n <= 1) ? 1 : (n * f(n - 1, f));\n    });\n\n    printf(\"fib(10) = %d\\n\", fib(10, fib));\n    printf(\"fac(10) = %d\\n\", fac(10, fac));\n\n    return 0;\n}", "index": 129}
{"lang": "Java, C", "input": "import java.util.function.Function;\n\npublic interface YCombinator {\n  interface RecursiveFunction<F> extends Function<RecursiveFunction<F>, F> { }\n  public static <A,B> Function<A,B> Y(Function<Function<A,B>, Function<A,B>> f) {\n    RecursiveFunction<Function<A,B>> r = w -> f.apply(x -> w.apply(w).apply(x));\n    return r.apply(r);\n  }\n\n  public static void main(String... arguments) {\n    Function<Integer,Integer> fib = Y(f -> n ->\n      (n <= 2)\n        ? 1\n        : (f.apply(n - 1) + f.apply(n - 2))\n    );\n    Function<Integer,Integer> fac = Y(f -> n ->\n      (n <= 1)\n        ? 1\n        : (n * f.apply(n - 1))\n    );\n\n    System.out.println(\"fib(10) = \" + fib.apply(10));\n    System.out.println(\"fac(10) = \" + fac.apply(10));\n  }\n}", "gold": "#include <stdio.h>\n#include <stdlib.h>\n\n\ntypedef struct func_t *func;\ntypedef struct func_t {\n        func (*fn) (func, func);\n        func _;\n        int num;\n} func_t;\n\nfunc new(func(*f)(func, func), func _) {\n        func x = malloc(sizeof(func_t));\n        x->fn = f;\n        x->_ = _;       \n        x->num = 0;\n        return x;\n}\n\nfunc call(func f, func n) {\n        return f->fn(f, n);\n}\n\nfunc Y(func(*f)(func, func)) {\n        func g = new(f, 0);\n        g->_ = g;\n        return g;\n}\n\nfunc num(int n) {\n        func x = new(0, 0);\n        x->num = n;\n        return x;\n}\n\n\nfunc fac(func self, func n) {\n        int nn = n->num;\n        return nn > 1   ? num(nn * call(self->_, num(nn - 1))->num)\n                        : num(1);\n}\n\nfunc fib(func self, func n) {\n        int nn = n->num;\n        return nn > 1\n                ? num(  call(self->_, num(nn - 1))->num +\n                        call(self->_, num(nn - 2))->num )\n                : num(1);\n}\n\nvoid show(func n) { printf(\" %d\", n->num); }\n\nint main() {\n        int i;\n        func f = Y(fac);\n        printf(\"fac: \");\n        for (i = 1; i < 10; i++)\n                show( call(f, num(i)) );\n        printf(\"\\n\");\n\n        f = Y(fib);\n        printf(\"fib: \");\n        for (i = 1; i < 10; i++)\n                show( call(f, num(i)) );\n        printf(\"\\n\");\n\n        return 0;\n}", "llm": "q2.5-7b", "output": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef int (*Function)(int);\n\nFunction Y(Function f) {\n    Function r = (Function)malloc(sizeof(Function));\n    *r = (Function)(f((Function)(w) => f((Function)(x) => w(w)(x)))));\n    return r(r);\n}\n\nint fib(int n) {\n    return (n <= 2) ? 1 : (fib(n - 1) + fib(n - 2));\n}\n\nint fac(int n) {\n    return (n <= 1) ? 1 : (n * fac(n - 1));\n}\n\nint main() {\n    Function fib_func = Y(fib);\n    Function fac_func = Y(fac);\n\n    printf(\"fib(10) = %d\\n\", fib_func(10));\n    printf(\"fac(10) = %d\\n\", fac_func(10));\n\n    free(fib_func);\n    free(fac_func);\n\n    return 0;\n}", "index": 130}
{"lang": "Java, C", "input": "import java.util.function.Function;\n\npublic interface YCombinator {\n  interface RecursiveFunction<F> extends Function<RecursiveFunction<F>, F> { }\n  public static <A,B> Function<A,B> Y(Function<Function<A,B>, Function<A,B>> f) {\n    RecursiveFunction<Function<A,B>> r = w -> f.apply(x -> w.apply(w).apply(x));\n    return r.apply(r);\n  }\n\n  public static void main(String... arguments) {\n    Function<Integer,Integer> fib = Y(f -> n ->\n      (n <= 2)\n        ? 1\n        : (f.apply(n - 1) + f.apply(n - 2))\n    );\n    Function<Integer,Integer> fac = Y(f -> n ->\n      (n <= 1)\n        ? 1\n        : (n * f.apply(n - 1))\n    );\n\n    System.out.println(\"fib(10) = \" + fib.apply(10));\n    System.out.println(\"fac(10) = \" + fac.apply(10));\n  }\n}", "gold": "#include <stdio.h>\n#include <stdlib.h>\n\n\ntypedef struct func_t *func;\ntypedef struct func_t {\n        func (*fn) (func, func);\n        func _;\n        int num;\n} func_t;\n\nfunc new(func(*f)(func, func), func _) {\n        func x = malloc(sizeof(func_t));\n        x->fn = f;\n        x->_ = _;       \n        x->num = 0;\n        return x;\n}\n\nfunc call(func f, func n) {\n        return f->fn(f, n);\n}\n\nfunc Y(func(*f)(func, func)) {\n        func g = new(f, 0);\n        g->_ = g;\n        return g;\n}\n\nfunc num(int n) {\n        func x = new(0, 0);\n        x->num = n;\n        return x;\n}\n\n\nfunc fac(func self, func n) {\n        int nn = n->num;\n        return nn > 1   ? num(nn * call(self->_, num(nn - 1))->num)\n                        : num(1);\n}\n\nfunc fib(func self, func n) {\n        int nn = n->num;\n        return nn > 1\n                ? num(  call(self->_, num(nn - 1))->num +\n                        call(self->_, num(nn - 2))->num )\n                : num(1);\n}\n\nvoid show(func n) { printf(\" %d\", n->num); }\n\nint main() {\n        int i;\n        func f = Y(fac);\n        printf(\"fac: \");\n        for (i = 1; i < 10; i++)\n                show( call(f, num(i)) );\n        printf(\"\\n\");\n\n        f = Y(fib);\n        printf(\"fib: \");\n        for (i = 1; i < 10; i++)\n                show( call(f, num(i)) );\n        printf(\"\\n\");\n\n        return 0;\n}", "llm": "magic-7b", "output": "#include <stdio.h>\n\ntypedef int (*RecursiveFunction)(int);\n\nRecursiveFunction Y(RecursiveFunction f) {\n    RecursiveFunction r = f;\n    return r(r);\n}\n\nint fib(int n) {\n    return (n <= 2) ? 1 : fib(n - 1) + fib(n - 2);\n}\n\nint fac(int n) {\n    return (n <= 1) ? 1 : n * fac(n - 1);\n}\n\nint main() {\n    RecursiveFunction fib_func = Y(fib);\n    RecursiveFunction fac_func = Y(fac);\n\n    printf(\"fib(10) = %d\\n\", fib_func(10));\n    printf(\"fac(10) = %d\\n\", fac_func(10));\n\n    return 0;\n}", "index": 131}
{"lang": "Python, Java", "input": "import sys\nprint(sys.getrecursionlimit())", "gold": "public class RecursionTest {\n\t\n    private static void recurse(int i) {\n        try {\n\t    recurse(i+1);\n\t} catch (StackOverflowError e) {\n\t    System.out.print(\"Recursion depth on this system is \" + i + \".\");\n\t}\n    }\n\t\n    public static void main(String[] args) {\n        recurse(0);\n    }\n}", "llm": "cl-7b", "output": "System.out.println(Runtime.getRuntime().availableProcessors());", "index": 132}
{"lang": "Python, Java", "input": "import sys\nprint(sys.getrecursionlimit())", "gold": "public class RecursionTest {\n\t\n    private static void recurse(int i) {\n        try {\n\t    recurse(i+1);\n\t} catch (StackOverflowError e) {\n\t    System.out.print(\"Recursion depth on this system is \" + i + \".\");\n\t}\n    }\n\t\n    public static void main(String[] args) {\n        recurse(0);\n    }\n}", "llm": "cl-34b", "output": "import java.lang.System;\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(System.getRecursionLimit());\n    }\n}", "index": 133}
{"lang": "Python, Java", "input": "import sys\nprint(sys.getrecursionlimit())", "gold": "public class RecursionTest {\n\t\n    private static void recurse(int i) {\n        try {\n\t    recurse(i+1);\n\t} catch (StackOverflowError e) {\n\t    System.out.print(\"Recursion depth on this system is \" + i + \".\");\n\t}\n    }\n\t\n    public static void main(String[] args) {\n        recurse(0);\n    }\n}", "llm": "cs-22b", "output": "public class Main {\n    public static void main(String[] args) {\n        System.out.println(getRecursionLimit());\n    }\n\n    public static int getRecursionLimit() {\n        return Thread.currentThread().getStackTrace().length;\n    }\n}", "index": 134}
{"lang": "Python, C", "input": "import turtle\nfrom itertools import cycle\nfrom time import sleep\n\ndef rect(t, x, y):\n    x2, y2 = x/2, y/2\n    t.setpos(-x2, -y2)\n    t.pendown()\n    for pos in [(-x2, y2), (x2, y2), (x2, -y2), (-x2, -y2)]: \n        t.goto(pos)\n    t.penup()\n\ndef rects(t, colour, wait_between_rect=0.1):\n    for x in range(550, 0, -25):\n        t.color(colour)\n        rect(t, x, x*.75)\n        sleep(wait_between_rect)\n\ntl=turtle.Turtle()\nscreen=turtle.Screen()\nscreen.setup(620,620)\nscreen.bgcolor('black')\nscreen.title('Rosetta Code Vibrating Rectangles')\ntl.pensize(3)\ntl.speed(0)\ntl.penup()\ntl.ht() \ncolours = 'red green blue orange white yellow'.split()\nfor colour in cycle(colours):\n    rects(tl, colour)\n    sleep(0.5)", "gold": "#include<graphics.h>\n\nvoid vibratingRectangles(int winWidth,int winHeight,int leastLength,int leastWidth,int num, int msec)\n{\n\tint color = 1,i,x = winWidth/2, y = winHeight/2;\n\t\n\twhile(!kbhit()){\n\t\tsetcolor(color++);\n\t\tfor(i=num;i>0;i--){\n\t\t\trectangle(x - i*leastLength,y - i*leastWidth,x + i*leastLength,y + i*leastWidth);\n\t\t\tdelay(msec);\n\t\t}\n\n\t\tif(color>MAXCOLORS){\n\t\t\tcolor = 1;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tinitwindow(1000,1000,\"Vibrating Rectangles...\");\n\t\n\tvibratingRectangles(1000,1000,30,15,20,500);\n\t\n\tclosegraph();\n\t\n\treturn 0;\n}", "llm": "dsc-33b", "output": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\ntypedef struct {\n    double x, y;\n} Position;\n\ntypedef struct {\n    Position pos;\n    char color[10];\n} Turtle;\n\nvoid rect(Turtle *t, double x, double y) {\n    double x2 = x / 2, y2 = y / 2;\n    t->pos.x = -x2;\n    t->pos.y = -y2;\n    printf(\"Turtle is at position (%.2f, %.2f)\\n\", t->pos.x, t->pos.y);\n    for (int i = 0; i < 4; i++) {\n        Position pos;\n        if (i == 0) { pos.x = -x2; pos.y = y2; }\n        else if (i == 1) { pos.x = x2; pos.y = y2; }\n        else if (i == 2) { pos.x = x2; pos.y = -y2; }\n        else { pos.x = -x2; pos.y = -y2; }\n        printf(\"Turtle is moving to position (%.2f, %.2f)\\n\", pos.x, pos.y);\n        t->pos = pos;\n    }\n}\n\nvoid rects(Turtle *t, char *colour, double wait_between_rect) {\n    for (double x = 550; x > 0; x -= 25) {\n        strcpy(t->color, colour);\n        rect(t, x, x * 0.75);\n        usleep(wait_between_rect * 1000000);\n    }\n}\n\nint main() {\n    Turtle tl;\n    tl.pos.x = 0;\n    tl.pos.y = 0;\n    strcpy(tl.color, \"white\");\n    char *colours[] = { \"red\", \"green\", \"blue\", \"orange\", \"white\", \"yellow\" };\n    int num_colors = sizeof(colours) / sizeof(colours[0]);\n    int color_index = 0;\n    while (1) {\n        rects(&tl, colours[color_index], 0.1);\n        usleep(0.5 * 1000000);\n        color_index = (color_index + 1) % num_colors;\n    }\n    return 0;\n}", "index": 135}
{"lang": "Python, C", "input": "import turtle\nfrom itertools import cycle\nfrom time import sleep\n\ndef rect(t, x, y):\n    x2, y2 = x/2, y/2\n    t.setpos(-x2, -y2)\n    t.pendown()\n    for pos in [(-x2, y2), (x2, y2), (x2, -y2), (-x2, -y2)]: \n        t.goto(pos)\n    t.penup()\n\ndef rects(t, colour, wait_between_rect=0.1):\n    for x in range(550, 0, -25):\n        t.color(colour)\n        rect(t, x, x*.75)\n        sleep(wait_between_rect)\n\ntl=turtle.Turtle()\nscreen=turtle.Screen()\nscreen.setup(620,620)\nscreen.bgcolor('black')\nscreen.title('Rosetta Code Vibrating Rectangles')\ntl.pensize(3)\ntl.speed(0)\ntl.penup()\ntl.ht() \ncolours = 'red green blue orange white yellow'.split()\nfor colour in cycle(colours):\n    rects(tl, colour)\n    sleep(0.5)", "gold": "#include<graphics.h>\n\nvoid vibratingRectangles(int winWidth,int winHeight,int leastLength,int leastWidth,int num, int msec)\n{\n\tint color = 1,i,x = winWidth/2, y = winHeight/2;\n\t\n\twhile(!kbhit()){\n\t\tsetcolor(color++);\n\t\tfor(i=num;i>0;i--){\n\t\t\trectangle(x - i*leastLength,y - i*leastWidth,x + i*leastLength,y + i*leastWidth);\n\t\t\tdelay(msec);\n\t\t}\n\n\t\tif(color>MAXCOLORS){\n\t\t\tcolor = 1;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tinitwindow(1000,1000,\"Vibrating Rectangles...\");\n\t\n\tvibratingRectangles(1000,1000,30,15,20,500);\n\t\n\tclosegraph();\n\t\n\treturn 0;\n}", "llm": "q2.5-1.5b", "output": "#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nvoid rect(int x, int y) {\n    int x2 = x / 2, y2 = y / 2;\n    printf(\"goto -%d, -%d\\n\", -x2, -y2);\n    printf(\"pendown\\n\");\n    for (int pos = 0; pos < 4; pos++) {\n        printf(\"goto %d, %d\\n\", x2, y2);\n    }\n    printf(\"penup\\n\");\n}\n\nvoid rects(int t, char *colour, double wait_between_rect) {\n    for (int x = 550; x > 0; x -= 25) {\n        printf(\"color %s\\n\", colour);\n        rect(x, x * 0.75);\n        sleep(wait_between_rect);\n    }\n}\n\nint main() {\n    srand(time(NULL));\n    turtle_t *tl = turtle_create();\n    turtle_set_screen(tl, 620, 620);\n    turtle_set_bgcolor(tl, \"black\");\n    turtle_set_title(tl, \"Rosetta Code Vibrating Rectangles\");\n    turtle_set_pen_size(tl, 3);\n    turtle_set_speed(tl, 0);\n    turtle_penup(tl);\n    turtle_hideturtle(tl);\n    char *colours[] = {\"red\", \"green\", \"blue\", \"orange\", \"white\", \"yellow\"};\n    for (int i = 0; i < 5; i++) {\n        char *colour = colours[rand() % 6];\n        rects(tl, colour, 0.1);\n        sleep(0.5);\n    }\n    turtle_destroy(tl);\n    return 0;\n}", "index": 136}
{"lang": "Python, C", "input": "import turtle\nfrom itertools import cycle\nfrom time import sleep\n\ndef rect(t, x, y):\n    x2, y2 = x/2, y/2\n    t.setpos(-x2, -y2)\n    t.pendown()\n    for pos in [(-x2, y2), (x2, y2), (x2, -y2), (-x2, -y2)]: \n        t.goto(pos)\n    t.penup()\n\ndef rects(t, colour, wait_between_rect=0.1):\n    for x in range(550, 0, -25):\n        t.color(colour)\n        rect(t, x, x*.75)\n        sleep(wait_between_rect)\n\ntl=turtle.Turtle()\nscreen=turtle.Screen()\nscreen.setup(620,620)\nscreen.bgcolor('black')\nscreen.title('Rosetta Code Vibrating Rectangles')\ntl.pensize(3)\ntl.speed(0)\ntl.penup()\ntl.ht() \ncolours = 'red green blue orange white yellow'.split()\nfor colour in cycle(colours):\n    rects(tl, colour)\n    sleep(0.5)", "gold": "#include<graphics.h>\n\nvoid vibratingRectangles(int winWidth,int winHeight,int leastLength,int leastWidth,int num, int msec)\n{\n\tint color = 1,i,x = winWidth/2, y = winHeight/2;\n\t\n\twhile(!kbhit()){\n\t\tsetcolor(color++);\n\t\tfor(i=num;i>0;i--){\n\t\t\trectangle(x - i*leastLength,y - i*leastWidth,x + i*leastLength,y + i*leastWidth);\n\t\t\tdelay(msec);\n\t\t}\n\n\t\tif(color>MAXCOLORS){\n\t\t\tcolor = 1;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tinitwindow(1000,1000,\"Vibrating Rectangles...\");\n\t\n\tvibratingRectangles(1000,1000,30,15,20,500);\n\t\n\tclosegraph();\n\t\n\treturn 0;\n}", "llm": "cs-22b", "output": "#include <stdio.h>\n#include <stdlib.h>\n#include <turtle.h>\n#include <unistd.h>\n\nvoid rect(Turtle *t, int x, int y) {\n    int x2 = x / 2;\n    int y2 = y / 2;\n    turtle_setpos(t, -x2, -y2);\n    turtle_pendown(t);\n    turtle_goto(t, -x2, y2);\n    turtle_goto(t, x2, y2);\n    turtle_goto(t, x2, -y2);\n    turtle_goto(t, -x2, -y2);\n    turtle_penup(t);\n}\n\nvoid rects(Turtle *t, const char *colour, int wait_between_rect) {\n    for (int x = 550; x > 0; x -= 25) {\n        turtle_color(t, colour);\n        rect(t, x, x * 3 / 4);\n        usleep(wait_between_rect * 1000000);\n    }\n}\n\nint main() {\n    Turtle *tl = turtle_create(620, 620, 30);\n    turtle_bgcolor(tl, \"black\");\n    turtle_title(tl, \"Rosetta Code Vibrating Rectangles\");\n    turtle_pensize(tl, 3);\n    turtle_speed(tl, 0);\n    turtle_penup(tl);\n    turtle_ht(tl);\n\n    const char *colours[] = {\"red\", \"green\", \"blue\", \"orange\", \"white\", \"yellow\"};\n    int colour_index = 0;\n\n    while (1) {\n        rects(tl, colours[colour_index], 100000);\n        usleep(500000);\n        colour_index = (colour_index + 1) % 6;\n    }\n\n    turtle_destroy(tl);\n    return 0;\n}", "index": 137}
{"lang": "Java, Python", "input": "public class BeadSort \n{\n\tpublic static void main(String[] args)\n\t{\n\t\tBeadSort now=new BeadSort();\n\t\tint[] arr=new int[(int)(Math.random()*11)+5];\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t\tarr[i]=(int)(Math.random()*10);\n\t\tSystem.out.print(\"Unsorted: \");\n\t\tnow.display1D(arr);\n\t\t\n\t\tint[] sort=now.beadSort(arr);\n\t\tSystem.out.print(\"Sorted: \");\n\t\tnow.display1D(sort);\n\t}\n\tint[] beadSort(int[] arr)\n\t{\n\t\tint max=a[0];\n\t\tfor(int i=1;i<arr.length;i++)\n\t\t\tif(arr[i]>max)\n\t\t\t\tmax=arr[i];\n\t\t\n\t\t\n\t\tchar[][] grid=new char[arr.length][max];\n\t\tint[] levelcount=new int[max];\n\t\tfor(int i=0;i<max;i++)\n\t\t{\n\t\t\tlevelcount[i]=0;\n\t\t\tfor(int j=0;j<arr.length;j++)\n\t\t\t\tgrid[j][i]='_';\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t{\n\t\t\tint num=arr[i];\n\t\t\tfor(int j=0;num>0;j++)\n\t\t\t{\n\t\t\t\tgrid[levelcount[j]++][j]='*';\n\t\t\t\tnum--;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println();\n\t\tdisplay2D(grid);\n\t\t\n\t\tint[] sorted=new int[arr.length];\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t{\n\t\t\tint putt=0;\n\t\t\tfor(int j=0;j<max&&grid[arr.length-1-i][j]=='*';j++)\n\t\t\t\tputt++;\n\t\t\tsorted[i]=putt;\n\t\t}\n\t\t\n\t\treturn sorted;\n\t}\n\tvoid display1D(int[] arr)\n\t{\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t\tSystem.out.print(arr[i]+\" \");\n\t\tSystem.out.println();\n\t}\n\tvoid display1D(char[] arr)\n\t{\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t\tSystem.out.print(arr[i]+\" \");\n\t\tSystem.out.println();\n\t}\n\tvoid display2D(char[][] arr)\n\t{\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t\tdisplay1D(arr[i]);\n\t\tSystem.out.println();\n\t}\n}", "gold": "from itertools import zip_longest\n\n\ndef beadsort(l):\n    return list(map(sum, zip_longest(*[[1] * e for e in l], fillvalue=0)))\n\n\n\nprint(beadsort([5,3,1,7,4,1,1]))", "llm": "q2.5-1.5b", "output": "class BeadSort:\n    def main(self):\n        now = BeadSort()\n        arr = [int(random.random() * 11) + 5 for _ in range(int(random.random() * 11) + 5)]\n        print(\"Unsorted: \", end=\"\")\n        self.display1D(arr)\n        \n        sort = now.beadSort(arr)\n        print(\"Sorted: \", end=\"\")\n        self.display1D(sort)\n    \n    def beadSort(self, arr):\n        max = arr[0]\n        for i in range(1, len(arr)):\n            if arr[i] > max:\n                max = arr[i]\n        \n        grid = [['_' for _ in range(max)] for _ in range(len(arr))]\n        levelcount = [0] * max\n        for i in range(max):\n            levelcount[i] = 0\n            for j in range(len(arr)):\n                grid[j][i] = '_'\n        \n        for i in range(len(arr)):\n            num = arr[i]\n            for j in range(num, 0, -1):\n                grid[levelcount[j - 1]][j - 1] = '*'\n                levelcount[j - 1] += 1\n            grid[len(arr) - 1 - i][0] = '*'\n        \n        print()\n        self.display2D(grid)\n        \n        sorted = [0] * len(arr)\n        for i in range(len(arr)):\n            putt = 0\n            for j in range(max) and grid[len(arr) - 1 - i][j] == '*':\n                putt += 1\n            sorted[i] = putt\n        \n        return sorted\n    \n    def display1D(self, arr):\n        for i in range(len(arr)):\n            print(arr[i], end=\" \")\n        print()\n    \n    def display1D(self, arr):\n        for i in range(len(arr)):\n            print(arr[i], end=\" \")\n        print()\n    \n    def display2D(self, arr):\n        for row in arr:\n            self.display1D(row)\n        print()", "index": 138}
{"lang": "Java, Python", "input": "public class BeadSort \n{\n\tpublic static void main(String[] args)\n\t{\n\t\tBeadSort now=new BeadSort();\n\t\tint[] arr=new int[(int)(Math.random()*11)+5];\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t\tarr[i]=(int)(Math.random()*10);\n\t\tSystem.out.print(\"Unsorted: \");\n\t\tnow.display1D(arr);\n\t\t\n\t\tint[] sort=now.beadSort(arr);\n\t\tSystem.out.print(\"Sorted: \");\n\t\tnow.display1D(sort);\n\t}\n\tint[] beadSort(int[] arr)\n\t{\n\t\tint max=a[0];\n\t\tfor(int i=1;i<arr.length;i++)\n\t\t\tif(arr[i]>max)\n\t\t\t\tmax=arr[i];\n\t\t\n\t\t\n\t\tchar[][] grid=new char[arr.length][max];\n\t\tint[] levelcount=new int[max];\n\t\tfor(int i=0;i<max;i++)\n\t\t{\n\t\t\tlevelcount[i]=0;\n\t\t\tfor(int j=0;j<arr.length;j++)\n\t\t\t\tgrid[j][i]='_';\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t{\n\t\t\tint num=arr[i];\n\t\t\tfor(int j=0;num>0;j++)\n\t\t\t{\n\t\t\t\tgrid[levelcount[j]++][j]='*';\n\t\t\t\tnum--;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println();\n\t\tdisplay2D(grid);\n\t\t\n\t\tint[] sorted=new int[arr.length];\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t{\n\t\t\tint putt=0;\n\t\t\tfor(int j=0;j<max&&grid[arr.length-1-i][j]=='*';j++)\n\t\t\t\tputt++;\n\t\t\tsorted[i]=putt;\n\t\t}\n\t\t\n\t\treturn sorted;\n\t}\n\tvoid display1D(int[] arr)\n\t{\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t\tSystem.out.print(arr[i]+\" \");\n\t\tSystem.out.println();\n\t}\n\tvoid display1D(char[] arr)\n\t{\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t\tSystem.out.print(arr[i]+\" \");\n\t\tSystem.out.println();\n\t}\n\tvoid display2D(char[][] arr)\n\t{\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t\tdisplay1D(arr[i]);\n\t\tSystem.out.println();\n\t}\n}", "gold": "from itertools import zip_longest\n\n\ndef beadsort(l):\n    return list(map(sum, zip_longest(*[[1] * e for e in l], fillvalue=0)))\n\n\n\nprint(beadsort([5,3,1,7,4,1,1]))", "llm": "q2.5-7b", "output": "import random\n\nclass BeadSort:\n    def __init__(self):\n        pass\n\n    def main(self):\n        now = BeadSort()\n        arr = [random.randint(0, 9) for _ in range(random.randint(5, 16))]\n        print(\"Unsorted: \", end=\"\")\n        now.display1D(arr)\n        \n        sort = now.beadSort(arr)\n        print(\"Sorted: \", end=\"\")\n        now.display1D(sort)\n\n    def beadSort(self, arr):\n        max_val = max(arr)\n        grid = [['_' for _ in range(max_val)] for _ in range(len(arr))]\n        levelcount = [0] * max_val\n        \n        for i in range(max_val):\n            for j in range(len(arr)):\n                grid[j][i] = '_'\n        \n        for i, num in enumerate(arr):\n            for j in range(num):\n                grid[levelcount[j]++][i] = '*'\n        \n        print()\n        self.display2D(grid)\n        \n        sorted_arr = [0] * len(arr)\n        for i in range(len(arr)):\n            putt = 0\n            for j in range(max_val):\n                if grid[len(arr) - 1 - i][j] == '*':\n                    putt += 1\n                else:\n                    break\n            sorted_arr[i] = putt\n        \n        return sorted_arr\n\n    def display1D(self, arr):\n        print(' '.join(map(str, arr)))\n\n    def display2D(self, arr):\n        for row in arr:\n            self.display1D(row)\n        print()\n\n# Uncomment the following line to run the main method\n# BeadSort().main()", "index": 139}
{"lang": "Java, Python", "input": "public class BeadSort \n{\n\tpublic static void main(String[] args)\n\t{\n\t\tBeadSort now=new BeadSort();\n\t\tint[] arr=new int[(int)(Math.random()*11)+5];\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t\tarr[i]=(int)(Math.random()*10);\n\t\tSystem.out.print(\"Unsorted: \");\n\t\tnow.display1D(arr);\n\t\t\n\t\tint[] sort=now.beadSort(arr);\n\t\tSystem.out.print(\"Sorted: \");\n\t\tnow.display1D(sort);\n\t}\n\tint[] beadSort(int[] arr)\n\t{\n\t\tint max=a[0];\n\t\tfor(int i=1;i<arr.length;i++)\n\t\t\tif(arr[i]>max)\n\t\t\t\tmax=arr[i];\n\t\t\n\t\t\n\t\tchar[][] grid=new char[arr.length][max];\n\t\tint[] levelcount=new int[max];\n\t\tfor(int i=0;i<max;i++)\n\t\t{\n\t\t\tlevelcount[i]=0;\n\t\t\tfor(int j=0;j<arr.length;j++)\n\t\t\t\tgrid[j][i]='_';\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t{\n\t\t\tint num=arr[i];\n\t\t\tfor(int j=0;num>0;j++)\n\t\t\t{\n\t\t\t\tgrid[levelcount[j]++][j]='*';\n\t\t\t\tnum--;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println();\n\t\tdisplay2D(grid);\n\t\t\n\t\tint[] sorted=new int[arr.length];\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t{\n\t\t\tint putt=0;\n\t\t\tfor(int j=0;j<max&&grid[arr.length-1-i][j]=='*';j++)\n\t\t\t\tputt++;\n\t\t\tsorted[i]=putt;\n\t\t}\n\t\t\n\t\treturn sorted;\n\t}\n\tvoid display1D(int[] arr)\n\t{\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t\tSystem.out.print(arr[i]+\" \");\n\t\tSystem.out.println();\n\t}\n\tvoid display1D(char[] arr)\n\t{\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t\tSystem.out.print(arr[i]+\" \");\n\t\tSystem.out.println();\n\t}\n\tvoid display2D(char[][] arr)\n\t{\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t\tdisplay1D(arr[i]);\n\t\tSystem.out.println();\n\t}\n}", "gold": "from itertools import zip_longest\n\n\ndef beadsort(l):\n    return list(map(sum, zip_longest(*[[1] * e for e in l], fillvalue=0)))\n\n\n\nprint(beadsort([5,3,1,7,4,1,1]))", "llm": "magic-7b", "output": "import random\n\nclass BeadSort:\n    def __init__(self):\n        pass\n\n    def beadSort(self, arr):\n        max_val = max(arr)\n        grid = [['_' for _ in range(max_val)] for _ in range(len(arr))]\n        level_count = [0] * max_val\n\n        for i in range(len(arr)):\n            num = arr[i]\n            for j in range(num):\n                grid[level_count[j]][j] = '*'\n                level_count[j] += 1\n\n        sorted_arr = [0] * len(arr)\n        for i in range(len(arr)):\n            putt = 0\n            for j in range(max_val):\n                if grid[len(arr) - 1 - i][j] == '*':\n                    putt += 1\n            sorted_arr[i] = putt\n\n        return sorted_arr\n\n    def display1D(self, arr):\n        print(' '.join(map(str, arr)))\n\n    def display2D(self, arr):\n        for row in arr:\n            self.display1D(row)\n\n\nif __name__ == \"__main__\":\n    now = BeadSort()\n    arr = [random.randint(0, 9) for _ in range(random.randint(5, 15))]\n    print(\"Unsorted: \", end='')\n    now.display1D(arr)\n\n    sorted_arr = now.beadSort(arr)\n    print(\"Sorted: \", end='')\n    now.display1D(sorted_arr)", "index": 140}
{"lang": "Java, C", "input": "public class Compare\n{\n\t\n    \n    public static void compare (String A, String B)\n    {\n        if (A.equals(B))\n            System.debug(A + ' and  ' + B + ' are lexically equal.');\n        else\n            System.debug(A + ' and  ' + B + ' are not lexically equal.');\n\n        if (A.equalsIgnoreCase(B))\n            System.debug(A + ' and  ' + B + ' are case-insensitive lexically equal.');\n        else\n            System.debug(A + ' and  ' + B + ' are not case-insensitive lexically equal.');\n \n        if (A.compareTo(B) < 0)\n            System.debug(A + ' is lexically before ' + B);\n        else if (A.compareTo(B) > 0)\n            System.debug(A + ' is lexically after ' + B);\n \n        if (A.compareTo(B) >= 0)\n            System.debug(A + ' is not lexically before ' + B);\n        if (A.compareTo(B) <= 0)\n            System.debug(A + ' is not lexically after ' + B);\n \n        System.debug('The lexical relationship is: ' + A.compareTo(B));\n    }\n}", "gold": "if (strcmp(a,b)) action_on_equality();", "llm": "dsc-7b", "output": "#include <stdio.h>\n#include <string.h>\n\nvoid compare(char* A, char* B) {\n    if (strcmp(A, B) == 0)\n        printf(\"%s and %s are lexically equal.\\n\", A, B);\n    else\n        printf(\"%s and %s are not lexically equal.\\n\", A, B);\n\n    if (strcasecmp(A, B) == 0)\n        printf(\"%s and %s are case-insensitive lexically equal.\\n\", A, B);\n    else\n        printf(\"%s and %s are not case-insensitive lexically equal.\\n\", A, B);\n\n    if (strcmp(A, B) < 0)\n        printf(\"%s is lexically before %s\\n\", A, B);\n    else if (strcmp(A, B) > 0)\n        printf(\"%s is lexically after %s\\n\", A, B);\n\n    if (strcmp(A, B) >= 0)\n        printf(\"%s is not lexically before %s\\n\", A, B);\n    if (strcmp(A, B) <= 0)\n        printf(\"%s is not lexically after %s\\n\", A, B);\n\n    printf(\"The lexical relationship is: %d\\n\", strcmp(A, B));\n}", "index": 141}
{"lang": "Java, C", "input": "public class Compare\n{\n\t\n    \n    public static void compare (String A, String B)\n    {\n        if (A.equals(B))\n            System.debug(A + ' and  ' + B + ' are lexically equal.');\n        else\n            System.debug(A + ' and  ' + B + ' are not lexically equal.');\n\n        if (A.equalsIgnoreCase(B))\n            System.debug(A + ' and  ' + B + ' are case-insensitive lexically equal.');\n        else\n            System.debug(A + ' and  ' + B + ' are not case-insensitive lexically equal.');\n \n        if (A.compareTo(B) < 0)\n            System.debug(A + ' is lexically before ' + B);\n        else if (A.compareTo(B) > 0)\n            System.debug(A + ' is lexically after ' + B);\n \n        if (A.compareTo(B) >= 0)\n            System.debug(A + ' is not lexically before ' + B);\n        if (A.compareTo(B) <= 0)\n            System.debug(A + ' is not lexically after ' + B);\n \n        System.debug('The lexical relationship is: ' + A.compareTo(B));\n    }\n}", "gold": "if (strcmp(a,b)) action_on_equality();", "llm": "q2.5-7b", "output": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nvoid compare(char* A, char* B) {\n    if (strcmp(A, B) == 0)\n        printf(\"%s and %s are lexically equal.\\n\", A, B);\n    else\n        printf(\"%s and %s are not lexically equal.\\n\", A, B);\n\n    if (strcasecmp(A, B) == 0)\n        printf(\"%s and %s are case-insensitive lexically equal.\\n\", A, B);\n    else\n        printf(\"%s and %s are not case-insensitive lexically equal.\\n\", A, B);\n\n    if (strcmp(A, B) < 0)\n        printf(\"%s is lexically before %s\\n\", A, B);\n    else if (strcmp(A, B) > 0)\n        printf(\"%s is lexically after %s\\n\", A, B);\n\n    if (strcmp(A, B) >= 0)\n        printf(\"%s is not lexically before %s\\n\", A, B);\n    if (strcmp(A, B) <= 0)\n        printf(\"%s is not lexically after %s\\n\", A, B);\n\n    printf(\"The lexical relationship is: %d\\n\", strcmp(A, B));\n}", "index": 142}
{"lang": "Java, C", "input": "public class Compare\n{\n\t\n    \n    public static void compare (String A, String B)\n    {\n        if (A.equals(B))\n            System.debug(A + ' and  ' + B + ' are lexically equal.');\n        else\n            System.debug(A + ' and  ' + B + ' are not lexically equal.');\n\n        if (A.equalsIgnoreCase(B))\n            System.debug(A + ' and  ' + B + ' are case-insensitive lexically equal.');\n        else\n            System.debug(A + ' and  ' + B + ' are not case-insensitive lexically equal.');\n \n        if (A.compareTo(B) < 0)\n            System.debug(A + ' is lexically before ' + B);\n        else if (A.compareTo(B) > 0)\n            System.debug(A + ' is lexically after ' + B);\n \n        if (A.compareTo(B) >= 0)\n            System.debug(A + ' is not lexically before ' + B);\n        if (A.compareTo(B) <= 0)\n            System.debug(A + ' is not lexically after ' + B);\n \n        System.debug('The lexical relationship is: ' + A.compareTo(B));\n    }\n}", "gold": "if (strcmp(a,b)) action_on_equality();", "llm": "cs-22b", "output": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nvoid compare(const char *A, const char *B) {\n    if (strcmp(A, B) == 0)\n        printf(\"%s and %s are lexically equal.\\n\", A, B);\n    else\n        printf(\"%s and %s are not lexically equal.\\n\", A, B);\n\n    if (strcasecmp(A, B) == 0)\n        printf(\"%s and %s are case-insensitive lexically equal.\\n\", A, B);\n    else\n        printf(\"%s and %s are not case-insensitive lexically equal.\\n\", A, B);\n\n    if (strcmp(A, B) < 0)\n        printf(\"%s is lexically before %s\\n\", A, B);\n    else if (strcmp(A, B) > 0)\n        printf(\"%s is lexically after %s\\n\", A, B);\n\n    if (strcmp(A, B) >= 0)\n        printf(\"%s is not lexically before %s\\n\", A, B);\n    if (strcmp(A, B) <= 0)\n        printf(\"%s is not lexically after %s\\n\", A, B);\n\n    printf(\"The lexical relationship is: %d\\n\", strcmp(A, B));\n}", "index": 143}
{"lang": "Java, Python", "input": "public class ProductOfDivisors {\n    private static long divisorCount(long n) {\n        long total = 1;\n        \n        for (; (n & 1) == 0; n >>= 1) {\n            ++total;\n        }\n        \n        for (long p = 3; p * p <= n; p += 2) {\n            long count = 1;\n            for (; n % p == 0; n /= p) {\n                ++count;\n            }\n            total *= count;\n        }\n        \n        if (n > 1) {\n            total *= 2;\n        }\n        return total;\n    }\n\n    private static long divisorProduct(long n) {\n        return (long) Math.pow(n, divisorCount(n) / 2.0);\n    }\n\n    public static void main(String[] args) {\n        final long limit = 50;\n        System.out.printf(\"Product of divisors for the first %d positive integers:%n\", limit);\n        for (long n = 1; n <= limit; n++) {\n            System.out.printf(\"%11d\", divisorProduct(n));\n            if (n % 5 == 0) {\n                System.out.println();\n            }\n        }\n    }\n}", "gold": "def product_of_divisors(n):\n    assert(isinstance(n, int) and 0 < n)\n    ans = i = j = 1\n    while i*i <= n:\n        if 0 == n%i:\n            ans *= i\n            j = n//i\n            if j != i:\n                ans *= j\n        i += 1\n    return ans\n    \nif __name__ == \"__main__\":\n    print([product_of_divisors(n) for n in range(1,51)])", "llm": "cl-7b", "output": "class ProductOfDivisors:\n    @staticmethod\n    def divisor_count(n):\n        total = 1\n        for n in range(2, int(n ** 0.5) + 1):\n            if n % 2 == 0:\n                total *= (n + 1)\n        return total\n\n    @staticmethod\n    def divisor_product(n):\n        return n ** (ProductOfDivisors.divisor_count(n) / 2.0)\n\n    def main(self):\n        limit = 50\n        for n in range(1, limit + 1):\n            print(f\"{ProductOfDivisors.divisor_product(n):11d}\", end=\"\")\n            if n % 5 == 0:\n                print()", "index": 144}
{"lang": "Java, Python", "input": "public class ProductOfDivisors {\n    private static long divisorCount(long n) {\n        long total = 1;\n        \n        for (; (n & 1) == 0; n >>= 1) {\n            ++total;\n        }\n        \n        for (long p = 3; p * p <= n; p += 2) {\n            long count = 1;\n            for (; n % p == 0; n /= p) {\n                ++count;\n            }\n            total *= count;\n        }\n        \n        if (n > 1) {\n            total *= 2;\n        }\n        return total;\n    }\n\n    private static long divisorProduct(long n) {\n        return (long) Math.pow(n, divisorCount(n) / 2.0);\n    }\n\n    public static void main(String[] args) {\n        final long limit = 50;\n        System.out.printf(\"Product of divisors for the first %d positive integers:%n\", limit);\n        for (long n = 1; n <= limit; n++) {\n            System.out.printf(\"%11d\", divisorProduct(n));\n            if (n % 5 == 0) {\n                System.out.println();\n            }\n        }\n    }\n}", "gold": "def product_of_divisors(n):\n    assert(isinstance(n, int) and 0 < n)\n    ans = i = j = 1\n    while i*i <= n:\n        if 0 == n%i:\n            ans *= i\n            j = n//i\n            if j != i:\n                ans *= j\n        i += 1\n    return ans\n    \nif __name__ == \"__main__\":\n    print([product_of_divisors(n) for n in range(1,51)])", "llm": "q2.5-7b", "output": "def divisor_count(n):\n    total = 1\n    while n % 2 == 0:\n        n >>= 1\n        total += 1\n    p = 3\n    while p * p <= n:\n        count = 1\n        while n % p == 0:\n            n //= p\n            count += 1\n        total *= count\n        p += 2\n    if n > 1:\n        total *= 2\n    return total\n\ndef divisor_product(n):\n    return n ** (divisor_count(n) / 2)\n\nlimit = 50\nprint(f\"Product of divisors for the first {limit} positive integers:\")\nfor n in range(1, limit + 1):\n    print(f\"{divisor_product(n):11d}\", end=\"\")\n    if n % 5 == 0:\n        print()", "index": 145}
{"lang": "Java, Python", "input": "public class ProductOfDivisors {\n    private static long divisorCount(long n) {\n        long total = 1;\n        \n        for (; (n & 1) == 0; n >>= 1) {\n            ++total;\n        }\n        \n        for (long p = 3; p * p <= n; p += 2) {\n            long count = 1;\n            for (; n % p == 0; n /= p) {\n                ++count;\n            }\n            total *= count;\n        }\n        \n        if (n > 1) {\n            total *= 2;\n        }\n        return total;\n    }\n\n    private static long divisorProduct(long n) {\n        return (long) Math.pow(n, divisorCount(n) / 2.0);\n    }\n\n    public static void main(String[] args) {\n        final long limit = 50;\n        System.out.printf(\"Product of divisors for the first %d positive integers:%n\", limit);\n        for (long n = 1; n <= limit; n++) {\n            System.out.printf(\"%11d\", divisorProduct(n));\n            if (n % 5 == 0) {\n                System.out.println();\n            }\n        }\n    }\n}", "gold": "def product_of_divisors(n):\n    assert(isinstance(n, int) and 0 < n)\n    ans = i = j = 1\n    while i*i <= n:\n        if 0 == n%i:\n            ans *= i\n            j = n//i\n            if j != i:\n                ans *= j\n        i += 1\n    return ans\n    \nif __name__ == \"__main__\":\n    print([product_of_divisors(n) for n in range(1,51)])", "llm": "cg4-9b", "output": "def divisor_count(n):\n    total = 1\n    \n    while (n & 1) == 0:\n        n >>= 1\n        total += 1\n    \n    p = 3\n    while p * p <= n:\n        count = 1\n        while n % p == 0:\n            n //= p\n            count += 1\n        total *= count\n        p += 2\n    \n    if n > 1:\n        total *= 2\n    return total\n\ndef divisor_product(n):\n    return int(n ** (divisor_count(n) / 2.0))\n\nlimit = 50\nprint(f\"Product of divisors for the first {limit} positive integers:\")\nfor n in range(1, limit + 1):\n    print(f\"{divisor_product(n):11d}\", end='')\n    if n % 5 == 0:\n        print()", "index": 146}
{"lang": "Java, C++", "input": "public class SelfDescribingNumbers{\n    public static boolean isSelfDescribing(int a){\n        String s = Integer.toString(a);\n        for(int i = 0; i < s.length(); i++){\n            String s0 = s.charAt(i) + \"\";\n            int b = Integer.parseInt(s0); \n            int count = 0;\n            for(int j = 0; j < s.length(); j++){\n                int temp = Integer.parseInt(s.charAt(j) + \"\");\n                if(temp == i){\n                    count++;\n                }\n                if (count > b) return false;\n            }\n            if(count != b) return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args){\n        for(int i = 0; i < 100000000; i++){\n            if(isSelfDescribing(i)){\n                System.out.println(i);\n             }\n        }\n    }\n}", "gold": "#include <iostream>\n \n\ntypedef unsigned long long bigint;\n \n\nusing namespace std;\n \n\nclass sdn\n{\npublic:\n    bool check( bigint n )\n    {\n\tint cc = digitsCount( n );\n\treturn compare( n, cc );\n    }\n \n    void displayAll( bigint s )\n    {\n\tfor( bigint y = 1; y < s; y++ )\n\t    if( check( y ) )\n\t\tcout << y << \" is a Self-Describing Number.\" << endl;\n    }\n \nprivate:\n    bool compare( bigint n, int cc )\n    {\n\tbigint a;\n\twhile( cc )\n\t{\n\t    cc--; a = n % 10;\n\t    if( dig[cc] != a ) return false;\n\t    n -= a; n /= 10;\n\t}\n\treturn true;\n    }\n \n    int digitsCount( bigint n )\n    {\n\tint cc = 0; bigint a;\n\tmemset( dig, 0, sizeof( dig ) );\n\twhile( n )\n\t{\n\t    a = n % 10; dig[a]++;\n\t    cc++ ; n -= a; n /= 10;\n\t}\n\treturn cc;\n    }\n \n    int dig[10];\n};\n\nint main( int argc, char* argv[] )\n{\n    sdn s;\n    s. displayAll( 1000000000000 );\n    cout << endl << endl; system( \"pause\" );\n \n    bigint n;\n    while( true )\n    {\n\tsystem( \"cls\" );\n\tcout << \"Enter a positive whole number ( 0 to QUIT ): \"; cin >> n;\n\tif( !n ) return 0;\n\tif( s.check( n ) ) cout << n << \" is\";\n\telse cout << n << \" is NOT\";\n\tcout << \" a Self-Describing Number!\" << endl << endl;\n\tsystem( \"pause\" );\n    }\n \n    return 0;\n}", "llm": "cl-34b", "output": "#include <iostream>\n#include <string>\n#include <cmath>\n\nusing namespace std;\n\nbool isSelfDescribing(int a) {\n    string s = to_string(a);\n    for (int i = 0; i < s.length(); i++) {\n        string s0 = s.substr(i, 1);\n        int b = stoi(s0);\n        int count = 0;\n        for (int j = 0; j < s.length(); j++) {\n            int temp = stoi(s.substr(j, 1));\n            if (temp == i) {\n                count++;\n            }\n            if (count > b) return false;\n        }\n        if (count != b) return false;\n    }\n    return true;\n}\n\nint main() {\n    for (int i = 0; i < 100000000; i++) {\n        if (isSelfDescribing(i)) {\n            cout << i << endl;\n        }\n    }\n    return 0;\n}", "index": 147}
{"lang": "Java, C++", "input": "public class SelfDescribingNumbers{\n    public static boolean isSelfDescribing(int a){\n        String s = Integer.toString(a);\n        for(int i = 0; i < s.length(); i++){\n            String s0 = s.charAt(i) + \"\";\n            int b = Integer.parseInt(s0); \n            int count = 0;\n            for(int j = 0; j < s.length(); j++){\n                int temp = Integer.parseInt(s.charAt(j) + \"\");\n                if(temp == i){\n                    count++;\n                }\n                if (count > b) return false;\n            }\n            if(count != b) return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args){\n        for(int i = 0; i < 100000000; i++){\n            if(isSelfDescribing(i)){\n                System.out.println(i);\n             }\n        }\n    }\n}", "gold": "#include <iostream>\n \n\ntypedef unsigned long long bigint;\n \n\nusing namespace std;\n \n\nclass sdn\n{\npublic:\n    bool check( bigint n )\n    {\n\tint cc = digitsCount( n );\n\treturn compare( n, cc );\n    }\n \n    void displayAll( bigint s )\n    {\n\tfor( bigint y = 1; y < s; y++ )\n\t    if( check( y ) )\n\t\tcout << y << \" is a Self-Describing Number.\" << endl;\n    }\n \nprivate:\n    bool compare( bigint n, int cc )\n    {\n\tbigint a;\n\twhile( cc )\n\t{\n\t    cc--; a = n % 10;\n\t    if( dig[cc] != a ) return false;\n\t    n -= a; n /= 10;\n\t}\n\treturn true;\n    }\n \n    int digitsCount( bigint n )\n    {\n\tint cc = 0; bigint a;\n\tmemset( dig, 0, sizeof( dig ) );\n\twhile( n )\n\t{\n\t    a = n % 10; dig[a]++;\n\t    cc++ ; n -= a; n /= 10;\n\t}\n\treturn cc;\n    }\n \n    int dig[10];\n};\n\nint main( int argc, char* argv[] )\n{\n    sdn s;\n    s. displayAll( 1000000000000 );\n    cout << endl << endl; system( \"pause\" );\n \n    bigint n;\n    while( true )\n    {\n\tsystem( \"cls\" );\n\tcout << \"Enter a positive whole number ( 0 to QUIT ): \"; cin >> n;\n\tif( !n ) return 0;\n\tif( s.check( n ) ) cout << n << \" is\";\n\telse cout << n << \" is NOT\";\n\tcout << \" a Self-Describing Number!\" << endl << endl;\n\tsystem( \"pause\" );\n    }\n \n    return 0;\n}", "llm": "q2.5-7b", "output": "#include <iostream>\n#include <string>\n\nbool isSelfDescribing(int a) {\n    std::string s = std::to_string(a);\n    for (int i = 0; i < s.length(); i++) {\n        char s0 = s[i];\n        int b = s0 - '0';\n        int count = 0;\n        for (int j = 0; j < s.length(); j++) {\n            int temp = s[j] - '0';\n            if (temp == i) {\n                count++;\n            }\n            if (count > b) return false;\n        }\n        if (count != b) return false;\n    }\n    return true;\n}\n\nint main() {\n    for (int i = 0; i < 100000000; i++) {\n        if (isSelfDescribing(i)) {\n            std::cout << i << std::endl;\n        }\n    }\n    return 0;\n}", "index": 148}
{"lang": "Java, C++", "input": "public class SelfDescribingNumbers{\n    public static boolean isSelfDescribing(int a){\n        String s = Integer.toString(a);\n        for(int i = 0; i < s.length(); i++){\n            String s0 = s.charAt(i) + \"\";\n            int b = Integer.parseInt(s0); \n            int count = 0;\n            for(int j = 0; j < s.length(); j++){\n                int temp = Integer.parseInt(s.charAt(j) + \"\");\n                if(temp == i){\n                    count++;\n                }\n                if (count > b) return false;\n            }\n            if(count != b) return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args){\n        for(int i = 0; i < 100000000; i++){\n            if(isSelfDescribing(i)){\n                System.out.println(i);\n             }\n        }\n    }\n}", "gold": "#include <iostream>\n \n\ntypedef unsigned long long bigint;\n \n\nusing namespace std;\n \n\nclass sdn\n{\npublic:\n    bool check( bigint n )\n    {\n\tint cc = digitsCount( n );\n\treturn compare( n, cc );\n    }\n \n    void displayAll( bigint s )\n    {\n\tfor( bigint y = 1; y < s; y++ )\n\t    if( check( y ) )\n\t\tcout << y << \" is a Self-Describing Number.\" << endl;\n    }\n \nprivate:\n    bool compare( bigint n, int cc )\n    {\n\tbigint a;\n\twhile( cc )\n\t{\n\t    cc--; a = n % 10;\n\t    if( dig[cc] != a ) return false;\n\t    n -= a; n /= 10;\n\t}\n\treturn true;\n    }\n \n    int digitsCount( bigint n )\n    {\n\tint cc = 0; bigint a;\n\tmemset( dig, 0, sizeof( dig ) );\n\twhile( n )\n\t{\n\t    a = n % 10; dig[a]++;\n\t    cc++ ; n -= a; n /= 10;\n\t}\n\treturn cc;\n    }\n \n    int dig[10];\n};\n\nint main( int argc, char* argv[] )\n{\n    sdn s;\n    s. displayAll( 1000000000000 );\n    cout << endl << endl; system( \"pause\" );\n \n    bigint n;\n    while( true )\n    {\n\tsystem( \"cls\" );\n\tcout << \"Enter a positive whole number ( 0 to QUIT ): \"; cin >> n;\n\tif( !n ) return 0;\n\tif( s.check( n ) ) cout << n << \" is\";\n\telse cout << n << \" is NOT\";\n\tcout << \" a Self-Describing Number!\" << endl << endl;\n\tsystem( \"pause\" );\n    }\n \n    return 0;\n}", "llm": "dsc2-16b", "output": "#include <iostream>\n#include <string>\n#include <cmath>\n\nbool isSelfDescribing(int a) {\n    std::string s = std::to_string(a);\n    for (int i = 0; i < s.length(); i++) {\n        std::string s0 = s.at(i) + \"\";\n        int b = std::stoi(s0);\n        int count = 0;\n        for (int j = 0; j < s.length(); j++) {\n            int temp = s.at(j) - '0';\n            if (temp == i) {\n                count++;\n            }\n            if (count > b) return false;\n        }\n        if (count != b) return false;\n    }\n    return true;\n}\n\nint main() {\n    for (int i = 0; i < 100000000; i++) {\n        if (isSelfDescribing(i)) {\n            std::cout << i << std::endl;\n        }\n    }\n    return 0;\n}", "index": 149}
